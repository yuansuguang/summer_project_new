{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Base from './core/Base';\nimport glenum from './core/glenum';\nimport Cache from './core/Cache';\nimport vendor from './core/vendor';\nfunction getArrayCtorByType(type) {\n  return {\n    'byte': vendor.Int8Array,\n    'ubyte': vendor.Uint8Array,\n    'short': vendor.Int16Array,\n    'ushort': vendor.Uint16Array\n  }[type] || vendor.Float32Array;\n}\nfunction makeAttrKey(attrName) {\n  return 'attr_' + attrName;\n}\n/**\n * GeometryBase attribute\n * @alias clay.GeometryBase.Attribute\n * @constructor\n */\nfunction Attribute(name, type, size, semantic) {\n  /**\n   * Attribute name\n   * @type {string}\n   */\n  this.name = name;\n  /**\n   * Attribute type\n   * Possible values:\n   *  + `'byte'`\n   *  + `'ubyte'`\n   *  + `'short'`\n   *  + `'ushort'`\n   *  + `'float'` Most commonly used.\n   * @type {string}\n   */\n  this.type = type;\n  /**\n   * Size of attribute component. 1 - 4.\n   * @type {number}\n   */\n  this.size = size;\n  /**\n   * Semantic of this attribute.\n   * Possible values:\n   *  + `'POSITION'`\n   *  + `'NORMAL'`\n   *  + `'BINORMAL'`\n   *  + `'TANGENT'`\n   *  + `'TEXCOORD'`\n   *  + `'TEXCOORD_0'`\n   *  + `'TEXCOORD_1'`\n   *  + `'COLOR'`\n   *  + `'JOINT'`\n   *  + `'WEIGHT'`\n   *\n   * In shader, attribute with same semantic will be automatically mapped. For example:\n   * ```glsl\n   * attribute vec3 pos: POSITION\n   * ```\n   * will use the attribute value with semantic POSITION in geometry, no matter what name it used.\n   * @type {string}\n   */\n  this.semantic = semantic || '';\n\n  /**\n   * Value of the attribute.\n   * @type {TypedArray}\n   */\n  this.value = null;\n\n  // Init getter setter\n  switch (size) {\n    case 1:\n      this.get = function (idx) {\n        return this.value[idx];\n      };\n      this.set = function (idx, value) {\n        this.value[idx] = value;\n      };\n      // Copy from source to target\n      this.copy = function (target, source) {\n        this.value[target] = this.value[target];\n      };\n      break;\n    case 2:\n      this.get = function (idx, out) {\n        var arr = this.value;\n        out[0] = arr[idx * 2];\n        out[1] = arr[idx * 2 + 1];\n        return out;\n      };\n      this.set = function (idx, val) {\n        var arr = this.value;\n        arr[idx * 2] = val[0];\n        arr[idx * 2 + 1] = val[1];\n      };\n      this.copy = function (target, source) {\n        var arr = this.value;\n        source *= 2;\n        target *= 2;\n        arr[target] = arr[source];\n        arr[target + 1] = arr[source + 1];\n      };\n      break;\n    case 3:\n      this.get = function (idx, out) {\n        var idx3 = idx * 3;\n        var arr = this.value;\n        out[0] = arr[idx3];\n        out[1] = arr[idx3 + 1];\n        out[2] = arr[idx3 + 2];\n        return out;\n      };\n      this.set = function (idx, val) {\n        var idx3 = idx * 3;\n        var arr = this.value;\n        arr[idx3] = val[0];\n        arr[idx3 + 1] = val[1];\n        arr[idx3 + 2] = val[2];\n      };\n      this.copy = function (target, source) {\n        var arr = this.value;\n        source *= 3;\n        target *= 3;\n        arr[target] = arr[source];\n        arr[target + 1] = arr[source + 1];\n        arr[target + 2] = arr[source + 2];\n      };\n      break;\n    case 4:\n      this.get = function (idx, out) {\n        var arr = this.value;\n        var idx4 = idx * 4;\n        out[0] = arr[idx4];\n        out[1] = arr[idx4 + 1];\n        out[2] = arr[idx4 + 2];\n        out[3] = arr[idx4 + 3];\n        return out;\n      };\n      this.set = function (idx, val) {\n        var arr = this.value;\n        var idx4 = idx * 4;\n        arr[idx4] = val[0];\n        arr[idx4 + 1] = val[1];\n        arr[idx4 + 2] = val[2];\n        arr[idx4 + 3] = val[3];\n      };\n      this.copy = function (target, source) {\n        var arr = this.value;\n        source *= 4;\n        target *= 4;\n        // copyWithin is extremely slow\n        arr[target] = arr[source];\n        arr[target + 1] = arr[source + 1];\n        arr[target + 2] = arr[source + 2];\n        arr[target + 3] = arr[source + 3];\n      };\n  }\n}\n\n/**\n * Set item value at give index. Second parameter val is number if size is 1\n * @function\n * @name clay.GeometryBase.Attribute#set\n * @param {number} idx\n * @param {number[]|number} val\n * @example\n * geometry.getAttribute('position').set(0, [1, 1, 1]);\n */\n\n/**\n * Get item value at give index. Second parameter out is no need if size is 1\n * @function\n * @name clay.GeometryBase.Attribute#set\n * @param {number} idx\n * @param {number[]} [out]\n * @example\n * geometry.getAttribute('position').get(0, out);\n */\n\n/**\n * Initialize attribute with given vertex count\n * @param {number} nVertex\n */\nAttribute.prototype.init = function (nVertex) {\n  if (!this.value || this.value.length !== nVertex * this.size) {\n    var ArrayConstructor = getArrayCtorByType(this.type);\n    this.value = new ArrayConstructor(nVertex * this.size);\n  }\n};\n\n/**\n * Initialize attribute with given array. Which can be 1 dimensional or 2 dimensional\n * @param {Array} array\n * @example\n *  geometry.getAttribute('position').fromArray(\n *      [-1, 0, 0, 1, 0, 0, 0, 1, 0]\n *  );\n *  geometry.getAttribute('position').fromArray(\n *      [ [-1, 0, 0], [1, 0, 0], [0, 1, 0] ]\n *  );\n */\nAttribute.prototype.fromArray = function (array) {\n  var ArrayConstructor = getArrayCtorByType(this.type);\n  var value;\n  // Convert 2d array to flat\n  if (array[0] && array[0].length) {\n    var n = 0;\n    var size = this.size;\n    value = new ArrayConstructor(array.length * size);\n    for (var i = 0; i < array.length; i++) {\n      for (var j = 0; j < size; j++) {\n        value[n++] = array[i][j];\n      }\n    }\n  } else {\n    value = new ArrayConstructor(array);\n  }\n  this.value = value;\n};\nAttribute.prototype.clone = function (copyValue) {\n  var ret = new Attribute(this.name, this.type, this.size, this.semantic);\n  // FIXME\n  if (copyValue) {\n    console.warn('todo');\n  }\n  return ret;\n};\nfunction AttributeBuffer(name, type, buffer, size, semantic) {\n  this.name = name;\n  this.type = type;\n  this.buffer = buffer;\n  this.size = size;\n  this.semantic = semantic;\n\n  // To be set in mesh\n  // symbol in the shader\n  this.symbol = '';\n\n  // Needs remove flag\n  this.needsRemove = false;\n}\nfunction IndicesBuffer(buffer) {\n  this.buffer = buffer;\n  this.count = 0;\n}\n\n/**\n * Base of all geometry. Use {@link clay.Geometry} for common 3D usage.\n * @constructor clay.GeometryBase\n * @extends clay.core.Base\n */\nvar GeometryBase = Base.extend(function () {\n  return /** @lends clay.GeometryBase# */{\n    /**\n     * Attributes of geometry.\n     * @type {Object.<string, clay.GeometryBase.Attribute>}\n     */\n    attributes: {},\n    /**\n     * Indices of geometry.\n     * @type {Uint16Array|Uint32Array}\n     */\n    indices: null,\n    /**\n     * Is vertices data dynamically updated.\n     * Attributes value can't be changed after first render if dyanmic is false.\n     * @type {boolean}\n     */\n    dynamic: true,\n    _enabledAttributes: null,\n    // PENDING\n    // Init it here to avoid deoptimization when it's assigned in application dynamically\n    __used: 0\n  };\n}, function () {\n  // Use cache\n  this._cache = new Cache();\n  this._attributeList = Object.keys(this.attributes);\n  this.__vaoCache = {};\n}, /** @lends clay.GeometryBase.prototype */\n{\n  /**\n   * Main attribute will be used to count vertex number\n   * @type {string}\n   */\n  mainAttribute: '',\n  /**\n   * User defined picking algorithm instead of default\n   * triangle ray intersection\n   * x, y are NDC.\n   * ```typescript\n   * (x, y, renderer, camera, renderable, out) => boolean\n   * ```\n   * @type {?Function}\n   */\n  pick: null,\n  /**\n   * User defined ray picking algorithm instead of default\n   * triangle ray intersection\n   * ```typescript\n   * (ray: clay.Ray, renderable: clay.Renderable, out: Array) => boolean\n   * ```\n   * @type {?Function}\n   */\n  pickByRay: null,\n  /**\n   * Mark attributes and indices in geometry needs to update.\n   * Usually called after you change the data in attributes.\n   */\n  dirty: function () {\n    var enabledAttributes = this.getEnabledAttributes();\n    for (var i = 0; i < enabledAttributes.length; i++) {\n      this.dirtyAttribute(enabledAttributes[i]);\n    }\n    this.dirtyIndices();\n    this._enabledAttributes = null;\n    this._cache.dirty('any');\n  },\n  /**\n   * Mark the indices needs to update.\n   */\n  dirtyIndices: function () {\n    this._cache.dirtyAll('indices');\n  },\n  /**\n   * Mark the attributes needs to update.\n   * @param {string} [attrName]\n   */\n  dirtyAttribute: function (attrName) {\n    this._cache.dirtyAll(makeAttrKey(attrName));\n    this._cache.dirtyAll('attributes');\n  },\n  /**\n   * Get indices of triangle at given index.\n   * @param {number} idx\n   * @param {Array.<number>} out\n   * @return {Array.<number>}\n   */\n  getTriangleIndices: function (idx, out) {\n    if (idx < this.triangleCount && idx >= 0) {\n      if (!out) {\n        out = [];\n      }\n      var indices = this.indices;\n      out[0] = indices[idx * 3];\n      out[1] = indices[idx * 3 + 1];\n      out[2] = indices[idx * 3 + 2];\n      return out;\n    }\n  },\n  /**\n   * Set indices of triangle at given index.\n   * @param {number} idx\n   * @param {Array.<number>} arr\n   */\n  setTriangleIndices: function (idx, arr) {\n    var indices = this.indices;\n    indices[idx * 3] = arr[0];\n    indices[idx * 3 + 1] = arr[1];\n    indices[idx * 3 + 2] = arr[2];\n  },\n  isUseIndices: function () {\n    return !!this.indices;\n  },\n  /**\n   * Initialize indices from an array.\n   * @param {Array} array\n   */\n  initIndicesFromArray: function (array) {\n    var value;\n    var ArrayConstructor = this.vertexCount > 0xffff ? vendor.Uint32Array : vendor.Uint16Array;\n    // Convert 2d array to flat\n    if (array[0] && array[0].length) {\n      var n = 0;\n      var size = 3;\n      value = new ArrayConstructor(array.length * size);\n      for (var i = 0; i < array.length; i++) {\n        for (var j = 0; j < size; j++) {\n          value[n++] = array[i][j];\n        }\n      }\n    } else {\n      value = new ArrayConstructor(array);\n    }\n    this.indices = value;\n  },\n  /**\n   * Create a new attribute\n   * @param {string} name\n   * @param {string} type\n   * @param {number} size\n   * @param {string} [semantic]\n   */\n  createAttribute: function (name, type, size, semantic) {\n    var attrib = new Attribute(name, type, size, semantic);\n    if (this.attributes[name]) {\n      this.removeAttribute(name);\n    }\n    this.attributes[name] = attrib;\n    this._attributeList.push(name);\n    return attrib;\n  },\n  /**\n   * Remove attribute\n   * @param {string} name\n   */\n  removeAttribute: function (name) {\n    var attributeList = this._attributeList;\n    var idx = attributeList.indexOf(name);\n    if (idx >= 0) {\n      attributeList.splice(idx, 1);\n      delete this.attributes[name];\n      return true;\n    }\n    return false;\n  },\n  /**\n   * Get attribute\n   * @param {string} name\n   * @return {clay.GeometryBase.Attribute}\n   */\n  getAttribute: function (name) {\n    return this.attributes[name];\n  },\n  /**\n   * Get enabled attributes name list\n   * Attribute which has the same vertex number with position is treated as a enabled attribute\n   * @return {string[]}\n   */\n  getEnabledAttributes: function () {\n    var enabledAttributes = this._enabledAttributes;\n    var attributeList = this._attributeList;\n    // Cache\n    if (enabledAttributes) {\n      return enabledAttributes;\n    }\n    var result = [];\n    var nVertex = this.vertexCount;\n    for (var i = 0; i < attributeList.length; i++) {\n      var name = attributeList[i];\n      var attrib = this.attributes[name];\n      if (attrib.value) {\n        if (attrib.value.length === nVertex * attrib.size) {\n          result.push(name);\n        }\n      }\n    }\n    this._enabledAttributes = result;\n    return result;\n  },\n  getBufferChunks: function (renderer) {\n    var cache = this._cache;\n    cache.use(renderer.__uid__);\n    var isAttributesDirty = cache.isDirty('attributes');\n    var isIndicesDirty = cache.isDirty('indices');\n    if (isAttributesDirty || isIndicesDirty) {\n      this._updateBuffer(renderer.gl, isAttributesDirty, isIndicesDirty);\n      var enabledAttributes = this.getEnabledAttributes();\n      for (var i = 0; i < enabledAttributes.length; i++) {\n        cache.fresh(makeAttrKey(enabledAttributes[i]));\n      }\n      cache.fresh('attributes');\n      cache.fresh('indices');\n    }\n    cache.fresh('any');\n    return cache.get('chunks');\n  },\n  _updateBuffer: function (_gl, isAttributesDirty, isIndicesDirty) {\n    var cache = this._cache;\n    var chunks = cache.get('chunks');\n    var firstUpdate = false;\n    if (!chunks) {\n      chunks = [];\n      // Intialize\n      chunks[0] = {\n        attributeBuffers: [],\n        indicesBuffer: null\n      };\n      cache.put('chunks', chunks);\n      firstUpdate = true;\n    }\n    var chunk = chunks[0];\n    var attributeBuffers = chunk.attributeBuffers;\n    var indicesBuffer = chunk.indicesBuffer;\n    if (isAttributesDirty || firstUpdate) {\n      var attributeList = this.getEnabledAttributes();\n      var attributeBufferMap = {};\n      if (!firstUpdate) {\n        for (var i = 0; i < attributeBuffers.length; i++) {\n          attributeBufferMap[attributeBuffers[i].name] = attributeBuffers[i];\n        }\n      }\n      // FIXME If some attributes removed\n      for (var k = 0; k < attributeList.length; k++) {\n        var name = attributeList[k];\n        var attribute = this.attributes[name];\n        var bufferInfo;\n        if (!firstUpdate) {\n          bufferInfo = attributeBufferMap[name];\n        }\n        var buffer;\n        if (bufferInfo) {\n          buffer = bufferInfo.buffer;\n        } else {\n          buffer = _gl.createBuffer();\n        }\n        if (cache.isDirty(makeAttrKey(name))) {\n          // Only update when they are dirty.\n          // TODO: Use BufferSubData?\n          _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);\n          _gl.bufferData(_gl.ARRAY_BUFFER, attribute.value, this.dynamic ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW);\n        }\n        attributeBuffers[k] = new AttributeBuffer(name, attribute.type, buffer, attribute.size, attribute.semantic);\n      }\n      // Remove unused attributes buffers.\n      // PENDING\n      for (var i = k; i < attributeBuffers.length; i++) {\n        _gl.deleteBuffer(attributeBuffers[i].buffer);\n      }\n      attributeBuffers.length = k;\n    }\n    if (this.isUseIndices() && (isIndicesDirty || firstUpdate)) {\n      if (!indicesBuffer) {\n        indicesBuffer = new IndicesBuffer(_gl.createBuffer());\n        chunk.indicesBuffer = indicesBuffer;\n      }\n      indicesBuffer.count = this.indices.length;\n      _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, indicesBuffer.buffer);\n      _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, this.indices, this.dynamic ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW);\n    }\n  },\n  /**\n   * Dispose geometry data in GL context.\n   * @param {clay.Renderer} renderer\n   */\n  dispose: function (renderer) {\n    var cache = this._cache;\n    cache.use(renderer.__uid__);\n    var chunks = cache.get('chunks');\n    if (chunks) {\n      for (var c = 0; c < chunks.length; c++) {\n        var chunk = chunks[c];\n        for (var k = 0; k < chunk.attributeBuffers.length; k++) {\n          var attribs = chunk.attributeBuffers[k];\n          renderer.gl.deleteBuffer(attribs.buffer);\n        }\n        if (chunk.indicesBuffer) {\n          renderer.gl.deleteBuffer(chunk.indicesBuffer.buffer);\n        }\n      }\n    }\n    if (this.__vaoCache) {\n      var vaoExt = renderer.getGLExtension('OES_vertex_array_object');\n      for (var id in this.__vaoCache) {\n        var vao = this.__vaoCache[id].vao;\n        if (vao) {\n          vaoExt.deleteVertexArrayOES(vao);\n        }\n      }\n    }\n    this.__vaoCache = {};\n    cache.deleteContext(renderer.__uid__);\n  }\n});\nif (Object.defineProperty) {\n  /**\n   * @name clay.GeometryBase#vertexCount\n   * @type {number}\n   * @readOnly\n   */\n  Object.defineProperty(GeometryBase.prototype, 'vertexCount', {\n    enumerable: false,\n    get: function () {\n      var mainAttribute = this.attributes[this.mainAttribute];\n      if (!mainAttribute) {\n        mainAttribute = this.attributes[this._attributeList[0]];\n      }\n      if (!mainAttribute || !mainAttribute.value) {\n        return 0;\n      }\n      return mainAttribute.value.length / mainAttribute.size;\n    }\n  });\n  /**\n   * @name clay.GeometryBase#triangleCount\n   * @type {number}\n   * @readOnly\n   */\n  Object.defineProperty(GeometryBase.prototype, 'triangleCount', {\n    enumerable: false,\n    get: function () {\n      var indices = this.indices;\n      if (!indices) {\n        return 0;\n      } else {\n        return indices.length / 3;\n      }\n    }\n  });\n}\nGeometryBase.STATIC_DRAW = glenum.STATIC_DRAW;\nGeometryBase.DYNAMIC_DRAW = glenum.DYNAMIC_DRAW;\nGeometryBase.STREAM_DRAW = glenum.STREAM_DRAW;\nGeometryBase.AttributeBuffer = AttributeBuffer;\nGeometryBase.IndicesBuffer = IndicesBuffer;\nGeometryBase.Attribute = Attribute;\nexport default GeometryBase;","map":{"version":3,"names":["Base","glenum","Cache","vendor","getArrayCtorByType","type","Int8Array","Uint8Array","Int16Array","Uint16Array","Float32Array","makeAttrKey","attrName","Attribute","name","size","semantic","value","get","idx","set","copy","target","source","out","arr","val","idx3","idx4","prototype","init","nVertex","length","ArrayConstructor","fromArray","array","n","i","j","clone","copyValue","ret","console","warn","AttributeBuffer","buffer","symbol","needsRemove","IndicesBuffer","count","GeometryBase","extend","attributes","indices","dynamic","_enabledAttributes","__used","_cache","_attributeList","Object","keys","__vaoCache","mainAttribute","pick","pickByRay","dirty","enabledAttributes","getEnabledAttributes","dirtyAttribute","dirtyIndices","dirtyAll","getTriangleIndices","triangleCount","setTriangleIndices","isUseIndices","initIndicesFromArray","vertexCount","Uint32Array","createAttribute","attrib","removeAttribute","push","attributeList","indexOf","splice","getAttribute","result","getBufferChunks","renderer","cache","use","__uid__","isAttributesDirty","isDirty","isIndicesDirty","_updateBuffer","gl","fresh","_gl","chunks","firstUpdate","attributeBuffers","indicesBuffer","put","chunk","attributeBufferMap","k","attribute","bufferInfo","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","DYNAMIC_DRAW","STATIC_DRAW","deleteBuffer","ELEMENT_ARRAY_BUFFER","dispose","c","attribs","vaoExt","getGLExtension","id","vao","deleteVertexArrayOES","deleteContext","defineProperty","enumerable","STREAM_DRAW"],"sources":["E:/mytest/node_modules/claygl/src/GeometryBase.js"],"sourcesContent":["import Base from './core/Base';\nimport glenum from './core/glenum';\nimport Cache from './core/Cache';\nimport vendor from './core/vendor';\n\nfunction getArrayCtorByType (type) {\n    return ({\n        'byte': vendor.Int8Array,\n        'ubyte': vendor.Uint8Array,\n        'short': vendor.Int16Array,\n        'ushort': vendor.Uint16Array\n    })[type] || vendor.Float32Array;\n}\n\nfunction makeAttrKey(attrName) {\n    return 'attr_' + attrName;\n}\n/**\n * GeometryBase attribute\n * @alias clay.GeometryBase.Attribute\n * @constructor\n */\nfunction Attribute(name, type, size, semantic) {\n    /**\n     * Attribute name\n     * @type {string}\n     */\n    this.name = name;\n    /**\n     * Attribute type\n     * Possible values:\n     *  + `'byte'`\n     *  + `'ubyte'`\n     *  + `'short'`\n     *  + `'ushort'`\n     *  + `'float'` Most commonly used.\n     * @type {string}\n     */\n    this.type = type;\n    /**\n     * Size of attribute component. 1 - 4.\n     * @type {number}\n     */\n    this.size = size;\n    /**\n     * Semantic of this attribute.\n     * Possible values:\n     *  + `'POSITION'`\n     *  + `'NORMAL'`\n     *  + `'BINORMAL'`\n     *  + `'TANGENT'`\n     *  + `'TEXCOORD'`\n     *  + `'TEXCOORD_0'`\n     *  + `'TEXCOORD_1'`\n     *  + `'COLOR'`\n     *  + `'JOINT'`\n     *  + `'WEIGHT'`\n     *\n     * In shader, attribute with same semantic will be automatically mapped. For example:\n     * ```glsl\n     * attribute vec3 pos: POSITION\n     * ```\n     * will use the attribute value with semantic POSITION in geometry, no matter what name it used.\n     * @type {string}\n     */\n    this.semantic = semantic || '';\n\n    /**\n     * Value of the attribute.\n     * @type {TypedArray}\n     */\n    this.value = null;\n\n    // Init getter setter\n    switch (size) {\n        case 1:\n            this.get = function (idx) {\n                return this.value[idx];\n            };\n            this.set = function (idx, value) {\n                this.value[idx] = value;\n            };\n            // Copy from source to target\n            this.copy = function (target, source) {\n                this.value[target] = this.value[target];\n            };\n            break;\n        case 2:\n            this.get = function (idx, out) {\n                var arr = this.value;\n                out[0] = arr[idx * 2];\n                out[1] = arr[idx * 2 + 1];\n                return out;\n            };\n            this.set = function (idx, val) {\n                var arr = this.value;\n                arr[idx * 2] = val[0];\n                arr[idx * 2 + 1] = val[1];\n            };\n            this.copy = function (target, source) {\n                var arr = this.value;\n                source *= 2;\n                target *= 2;\n                arr[target] = arr[source];\n                arr[target + 1] = arr[source + 1];\n            };\n            break;\n        case 3:\n            this.get = function (idx, out) {\n                var idx3 = idx * 3;\n                var arr = this.value;\n                out[0] = arr[idx3];\n                out[1] = arr[idx3 + 1];\n                out[2] = arr[idx3 + 2];\n                return out;\n            };\n            this.set = function (idx, val) {\n                var idx3 = idx * 3;\n                var arr = this.value;\n                arr[idx3] = val[0];\n                arr[idx3 + 1] = val[1];\n                arr[idx3 + 2] = val[2];\n            };\n            this.copy = function (target, source) {\n                var arr = this.value;\n                source *= 3;\n                target *= 3;\n                arr[target] = arr[source];\n                arr[target + 1] = arr[source + 1];\n                arr[target + 2] = arr[source + 2];\n            };\n            break;\n        case 4:\n            this.get = function (idx, out) {\n                var arr = this.value;\n                var idx4 = idx * 4;\n                out[0] = arr[idx4];\n                out[1] = arr[idx4 + 1];\n                out[2] = arr[idx4 + 2];\n                out[3] = arr[idx4 + 3];\n                return out;\n            };\n            this.set = function (idx, val) {\n                var arr = this.value;\n                var idx4 = idx * 4;\n                arr[idx4] = val[0];\n                arr[idx4 + 1] = val[1];\n                arr[idx4 + 2] = val[2];\n                arr[idx4 + 3] = val[3];\n            };\n            this.copy = function (target, source) {\n                var arr = this.value;\n                source *= 4;\n                target *= 4;\n                // copyWithin is extremely slow\n                arr[target] = arr[source];\n                arr[target + 1] = arr[source + 1];\n                arr[target + 2] = arr[source + 2];\n                arr[target + 3] = arr[source + 3];\n            };\n    }\n}\n\n/**\n * Set item value at give index. Second parameter val is number if size is 1\n * @function\n * @name clay.GeometryBase.Attribute#set\n * @param {number} idx\n * @param {number[]|number} val\n * @example\n * geometry.getAttribute('position').set(0, [1, 1, 1]);\n */\n\n/**\n * Get item value at give index. Second parameter out is no need if size is 1\n * @function\n * @name clay.GeometryBase.Attribute#set\n * @param {number} idx\n * @param {number[]} [out]\n * @example\n * geometry.getAttribute('position').get(0, out);\n */\n\n/**\n * Initialize attribute with given vertex count\n * @param {number} nVertex\n */\nAttribute.prototype.init = function (nVertex) {\n    if (!this.value || this.value.length !== nVertex * this.size) {\n        var ArrayConstructor = getArrayCtorByType(this.type);\n        this.value = new ArrayConstructor(nVertex * this.size);\n    }\n};\n\n/**\n * Initialize attribute with given array. Which can be 1 dimensional or 2 dimensional\n * @param {Array} array\n * @example\n *  geometry.getAttribute('position').fromArray(\n *      [-1, 0, 0, 1, 0, 0, 0, 1, 0]\n *  );\n *  geometry.getAttribute('position').fromArray(\n *      [ [-1, 0, 0], [1, 0, 0], [0, 1, 0] ]\n *  );\n */\nAttribute.prototype.fromArray = function (array) {\n    var ArrayConstructor = getArrayCtorByType(this.type);\n    var value;\n    // Convert 2d array to flat\n    if (array[0] && (array[0].length)) {\n        var n = 0;\n        var size = this.size;\n        value = new ArrayConstructor(array.length * size);\n        for (var i = 0; i < array.length; i++) {\n            for (var j = 0; j < size; j++) {\n                value[n++] = array[i][j];\n            }\n        }\n    }\n    else {\n        value = new ArrayConstructor(array);\n    }\n    this.value = value;\n};\n\nAttribute.prototype.clone = function(copyValue) {\n    var ret = new Attribute(this.name, this.type, this.size, this.semantic);\n    // FIXME\n    if (copyValue) {\n        console.warn('todo');\n    }\n    return ret;\n};\n\nfunction AttributeBuffer(name, type, buffer, size, semantic) {\n    this.name = name;\n    this.type = type;\n    this.buffer = buffer;\n    this.size = size;\n    this.semantic = semantic;\n\n    // To be set in mesh\n    // symbol in the shader\n    this.symbol = '';\n\n    // Needs remove flag\n    this.needsRemove = false;\n}\n\nfunction IndicesBuffer(buffer) {\n    this.buffer = buffer;\n    this.count = 0;\n}\n\n/**\n * Base of all geometry. Use {@link clay.Geometry} for common 3D usage.\n * @constructor clay.GeometryBase\n * @extends clay.core.Base\n */\nvar GeometryBase = Base.extend(function () {\n    return /** @lends clay.GeometryBase# */ {\n        /**\n         * Attributes of geometry.\n         * @type {Object.<string, clay.GeometryBase.Attribute>}\n         */\n        attributes: {},\n\n        /**\n         * Indices of geometry.\n         * @type {Uint16Array|Uint32Array}\n         */\n        indices: null,\n\n        /**\n         * Is vertices data dynamically updated.\n         * Attributes value can't be changed after first render if dyanmic is false.\n         * @type {boolean}\n         */\n        dynamic: true,\n\n        _enabledAttributes: null,\n\n        // PENDING\n        // Init it here to avoid deoptimization when it's assigned in application dynamically\n        __used: 0\n    };\n}, function () {\n    // Use cache\n    this._cache = new Cache();\n\n    this._attributeList = Object.keys(this.attributes);\n\n    this.__vaoCache = {};\n},\n/** @lends clay.GeometryBase.prototype */\n{\n    /**\n     * Main attribute will be used to count vertex number\n     * @type {string}\n     */\n    mainAttribute: '',\n    /**\n     * User defined picking algorithm instead of default\n     * triangle ray intersection\n     * x, y are NDC.\n     * ```typescript\n     * (x, y, renderer, camera, renderable, out) => boolean\n     * ```\n     * @type {?Function}\n     */\n    pick: null,\n\n    /**\n     * User defined ray picking algorithm instead of default\n     * triangle ray intersection\n     * ```typescript\n     * (ray: clay.Ray, renderable: clay.Renderable, out: Array) => boolean\n     * ```\n     * @type {?Function}\n     */\n    pickByRay: null,\n\n    /**\n     * Mark attributes and indices in geometry needs to update.\n     * Usually called after you change the data in attributes.\n     */\n    dirty: function () {\n        var enabledAttributes = this.getEnabledAttributes();\n        for (var i = 0; i < enabledAttributes.length; i++) {\n            this.dirtyAttribute(enabledAttributes[i]);\n        }\n        this.dirtyIndices();\n        this._enabledAttributes = null;\n\n        this._cache.dirty('any');\n    },\n    /**\n     * Mark the indices needs to update.\n     */\n    dirtyIndices: function () {\n        this._cache.dirtyAll('indices');\n    },\n    /**\n     * Mark the attributes needs to update.\n     * @param {string} [attrName]\n     */\n    dirtyAttribute: function (attrName) {\n        this._cache.dirtyAll(makeAttrKey(attrName));\n        this._cache.dirtyAll('attributes');\n    },\n    /**\n     * Get indices of triangle at given index.\n     * @param {number} idx\n     * @param {Array.<number>} out\n     * @return {Array.<number>}\n     */\n    getTriangleIndices: function (idx, out) {\n        if (idx < this.triangleCount && idx >= 0) {\n            if (!out) {\n                out = [];\n            }\n            var indices = this.indices;\n            out[0] = indices[idx * 3];\n            out[1] = indices[idx * 3 + 1];\n            out[2] = indices[idx * 3 + 2];\n            return out;\n        }\n    },\n\n    /**\n     * Set indices of triangle at given index.\n     * @param {number} idx\n     * @param {Array.<number>} arr\n     */\n    setTriangleIndices: function (idx, arr) {\n        var indices = this.indices;\n        indices[idx * 3] = arr[0];\n        indices[idx * 3 + 1] = arr[1];\n        indices[idx * 3 + 2] = arr[2];\n    },\n\n    isUseIndices: function () {\n        return !!this.indices;\n    },\n\n    /**\n     * Initialize indices from an array.\n     * @param {Array} array\n     */\n    initIndicesFromArray: function (array) {\n        var value;\n        var ArrayConstructor = this.vertexCount > 0xffff\n            ? vendor.Uint32Array : vendor.Uint16Array;\n        // Convert 2d array to flat\n        if (array[0] && (array[0].length)) {\n            var n = 0;\n            var size = 3;\n\n            value = new ArrayConstructor(array.length * size);\n            for (var i = 0; i < array.length; i++) {\n                for (var j = 0; j < size; j++) {\n                    value[n++] = array[i][j];\n                }\n            }\n        }\n        else {\n            value = new ArrayConstructor(array);\n        }\n\n        this.indices = value;\n    },\n    /**\n     * Create a new attribute\n     * @param {string} name\n     * @param {string} type\n     * @param {number} size\n     * @param {string} [semantic]\n     */\n    createAttribute: function (name, type, size, semantic) {\n        var attrib = new Attribute(name, type, size, semantic);\n        if (this.attributes[name]) {\n            this.removeAttribute(name);\n        }\n        this.attributes[name] = attrib;\n        this._attributeList.push(name);\n        return attrib;\n    },\n    /**\n     * Remove attribute\n     * @param {string} name\n     */\n    removeAttribute: function (name) {\n        var attributeList = this._attributeList;\n        var idx = attributeList.indexOf(name);\n        if (idx >= 0) {\n            attributeList.splice(idx, 1);\n            delete this.attributes[name];\n            return true;\n        }\n        return false;\n    },\n\n    /**\n     * Get attribute\n     * @param {string} name\n     * @return {clay.GeometryBase.Attribute}\n     */\n    getAttribute: function (name) {\n        return this.attributes[name];\n    },\n\n    /**\n     * Get enabled attributes name list\n     * Attribute which has the same vertex number with position is treated as a enabled attribute\n     * @return {string[]}\n     */\n    getEnabledAttributes: function () {\n        var enabledAttributes = this._enabledAttributes;\n        var attributeList = this._attributeList;\n        // Cache\n        if (enabledAttributes) {\n            return enabledAttributes;\n        }\n\n        var result = [];\n        var nVertex = this.vertexCount;\n\n        for (var i = 0; i < attributeList.length; i++) {\n            var name = attributeList[i];\n            var attrib = this.attributes[name];\n            if (attrib.value) {\n                if (attrib.value.length === nVertex * attrib.size) {\n                    result.push(name);\n                }\n            }\n        }\n\n        this._enabledAttributes = result;\n\n        return result;\n    },\n\n    getBufferChunks: function (renderer) {\n        var cache = this._cache;\n        cache.use(renderer.__uid__);\n        var isAttributesDirty = cache.isDirty('attributes');\n        var isIndicesDirty = cache.isDirty('indices');\n        if (isAttributesDirty || isIndicesDirty) {\n            this._updateBuffer(renderer.gl, isAttributesDirty, isIndicesDirty);\n            var enabledAttributes = this.getEnabledAttributes();\n            for (var i = 0; i < enabledAttributes.length; i++) {\n                cache.fresh(makeAttrKey(enabledAttributes[i]));\n            }\n            cache.fresh('attributes');\n            cache.fresh('indices');\n        }\n        cache.fresh('any');\n        return cache.get('chunks');\n    },\n\n    _updateBuffer: function (_gl, isAttributesDirty, isIndicesDirty) {\n        var cache = this._cache;\n        var chunks = cache.get('chunks');\n        var firstUpdate = false;\n        if (!chunks) {\n            chunks = [];\n            // Intialize\n            chunks[0] = {\n                attributeBuffers: [],\n                indicesBuffer: null\n            };\n            cache.put('chunks', chunks);\n            firstUpdate = true;\n        }\n\n        var chunk = chunks[0];\n        var attributeBuffers = chunk.attributeBuffers;\n        var indicesBuffer = chunk.indicesBuffer;\n\n        if (isAttributesDirty || firstUpdate) {\n            var attributeList = this.getEnabledAttributes();\n\n            var attributeBufferMap = {};\n            if (!firstUpdate) {\n                for (var i = 0; i < attributeBuffers.length; i++) {\n                    attributeBufferMap[attributeBuffers[i].name] = attributeBuffers[i];\n                }\n            }\n            // FIXME If some attributes removed\n            for (var k = 0; k < attributeList.length; k++) {\n                var name = attributeList[k];\n                var attribute = this.attributes[name];\n\n                var bufferInfo;\n\n                if (!firstUpdate) {\n                    bufferInfo = attributeBufferMap[name];\n                }\n                var buffer;\n                if (bufferInfo) {\n                    buffer = bufferInfo.buffer;\n                }\n                else {\n                    buffer = _gl.createBuffer();\n                }\n                if (cache.isDirty(makeAttrKey(name))) {\n                    // Only update when they are dirty.\n                    // TODO: Use BufferSubData?\n                    _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);\n                    _gl.bufferData(_gl.ARRAY_BUFFER, attribute.value, this.dynamic ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW);\n                }\n\n                attributeBuffers[k] = new AttributeBuffer(name, attribute.type, buffer, attribute.size, attribute.semantic);\n            }\n            // Remove unused attributes buffers.\n            // PENDING\n            for (var i = k; i < attributeBuffers.length; i++) {\n                _gl.deleteBuffer(attributeBuffers[i].buffer);\n            }\n            attributeBuffers.length = k;\n\n        }\n\n        if (this.isUseIndices() && (isIndicesDirty || firstUpdate)) {\n            if (!indicesBuffer) {\n                indicesBuffer = new IndicesBuffer(_gl.createBuffer());\n                chunk.indicesBuffer = indicesBuffer;\n            }\n            indicesBuffer.count = this.indices.length;\n            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, indicesBuffer.buffer);\n            _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, this.indices, this.dynamic ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW);\n        }\n    },\n\n    /**\n     * Dispose geometry data in GL context.\n     * @param {clay.Renderer} renderer\n     */\n    dispose: function (renderer) {\n\n        var cache = this._cache;\n\n        cache.use(renderer.__uid__);\n        var chunks = cache.get('chunks');\n        if (chunks) {\n            for (var c = 0; c < chunks.length; c++) {\n                var chunk = chunks[c];\n\n                for (var k = 0; k < chunk.attributeBuffers.length; k++) {\n                    var attribs = chunk.attributeBuffers[k];\n                    renderer.gl.deleteBuffer(attribs.buffer);\n                }\n\n                if (chunk.indicesBuffer) {\n                    renderer.gl.deleteBuffer(chunk.indicesBuffer.buffer);\n                }\n            }\n        }\n        if (this.__vaoCache) {\n            var vaoExt = renderer.getGLExtension('OES_vertex_array_object');\n            for (var id in this.__vaoCache) {\n                var vao = this.__vaoCache[id].vao;\n                if (vao) {\n                    vaoExt.deleteVertexArrayOES(vao);\n                }\n            }\n        }\n        this.__vaoCache = {};\n        cache.deleteContext(renderer.__uid__);\n    }\n\n});\n\nif (Object.defineProperty) {\n    /**\n     * @name clay.GeometryBase#vertexCount\n     * @type {number}\n     * @readOnly\n     */\n    Object.defineProperty(GeometryBase.prototype, 'vertexCount', {\n\n        enumerable: false,\n\n        get: function () {\n\n            var mainAttribute = this.attributes[this.mainAttribute];\n\n            if (!mainAttribute) {\n                mainAttribute = this.attributes[this._attributeList[0]];\n            }\n\n            if (!mainAttribute || !mainAttribute.value) {\n                return 0;\n            }\n            return mainAttribute.value.length / mainAttribute.size;\n        }\n    });\n    /**\n     * @name clay.GeometryBase#triangleCount\n     * @type {number}\n     * @readOnly\n     */\n    Object.defineProperty(GeometryBase.prototype, 'triangleCount', {\n\n        enumerable: false,\n\n        get: function () {\n            var indices = this.indices;\n            if (!indices) {\n                return 0;\n            }\n            else {\n                return indices.length / 3;\n            }\n        }\n    });\n}\n\nGeometryBase.STATIC_DRAW = glenum.STATIC_DRAW;\nGeometryBase.DYNAMIC_DRAW = glenum.DYNAMIC_DRAW;\nGeometryBase.STREAM_DRAW = glenum.STREAM_DRAW;\n\nGeometryBase.AttributeBuffer = AttributeBuffer;\nGeometryBase.IndicesBuffer = IndicesBuffer;\n\nGeometryBase.Attribute = Attribute;\n\nexport default GeometryBase;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}