{"ast":null,"code":"import * as echarts from 'echarts/lib/echarts';\nimport graphicGL from '../../util/graphicGL';\nimport glmatrix from 'claygl/src/dep/glmatrix';\nimport Lines3DGeometry from '../../util/geometry/Lines3D';\nimport trail2GLSL from './shader/trail2.glsl.js';\nimport { getItemVisualColor, getItemVisualOpacity } from '../../util/visual';\nvar vec3 = glmatrix.vec3;\nfunction sign(a) {\n  return a > 0 ? 1 : -1;\n}\ngraphicGL.Shader.import(trail2GLSL);\nexport default graphicGL.Mesh.extend(function () {\n  var material = new graphicGL.Material({\n    shader: new graphicGL.Shader(graphicGL.Shader.source('ecgl.trail2.vertex'), graphicGL.Shader.source('ecgl.trail2.fragment')),\n    transparent: true,\n    depthMask: false\n  });\n  var geometry = new Lines3DGeometry({\n    dynamic: true\n  });\n  geometry.createAttribute('dist', 'float', 1);\n  geometry.createAttribute('distAll', 'float', 1);\n  geometry.createAttribute('start', 'float', 1);\n  return {\n    geometry: geometry,\n    material: material,\n    culling: false,\n    $ignorePicking: true\n  };\n}, {\n  updateData: function (data, api, lines3DGeometry) {\n    var seriesModel = data.hostModel;\n    var geometry = this.geometry;\n    var effectModel = seriesModel.getModel('effect');\n    var size = effectModel.get('trailWidth') * api.getDevicePixelRatio();\n    var trailLength = effectModel.get('trailLength');\n    var speed = seriesModel.get('effect.constantSpeed');\n    var period = seriesModel.get('effect.period') * 1000;\n    var useConstantSpeed = speed != null;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!this.getScene()) {\n        console.error('TrailMesh must been add to scene before updateData');\n      }\n    }\n    useConstantSpeed ? this.material.set('speed', speed / 1000) : this.material.set('period', period);\n    this.material[useConstantSpeed ? 'define' : 'undefine']('vertex', 'CONSTANT_SPEED');\n    var isPolyline = seriesModel.get('polyline');\n    geometry.trailLength = trailLength;\n    this.material.set('trailLength', trailLength);\n    geometry.resetOffset();\n    ['position', 'positionPrev', 'positionNext'].forEach(function (attrName) {\n      geometry.attributes[attrName].value = lines3DGeometry.attributes[attrName].value;\n    });\n    var extraAttrs = ['dist', 'distAll', 'start', 'offset', 'color'];\n    extraAttrs.forEach(function (attrName) {\n      geometry.attributes[attrName].init(geometry.vertexCount);\n    });\n    geometry.indices = lines3DGeometry.indices;\n    var colorArr = [];\n    var effectColor = effectModel.get('trailColor');\n    var effectOpacity = effectModel.get('trailOpacity');\n    var hasEffectColor = effectColor != null;\n    var hasEffectOpacity = effectOpacity != null;\n    this.updateWorldTransform();\n    var xScale = this.worldTransform.x.len();\n    var yScale = this.worldTransform.y.len();\n    var zScale = this.worldTransform.z.len();\n    var vertexOffset = 0;\n    var maxDistance = 0;\n    data.each(function (idx) {\n      var pts = data.getItemLayout(idx);\n      var opacity = hasEffectOpacity ? effectOpacity : getItemVisualOpacity(data, idx);\n      var color = getItemVisualColor(data, idx);\n      if (opacity == null) {\n        opacity = 1;\n      }\n      colorArr = graphicGL.parseColor(hasEffectColor ? effectColor : color, colorArr);\n      colorArr[3] *= opacity;\n      var vertexCount = isPolyline ? lines3DGeometry.getPolylineVertexCount(pts) : lines3DGeometry.getCubicCurveVertexCount(pts[0], pts[1], pts[2], pts[3]);\n      var dist = 0;\n      var pos = [];\n      var posPrev = [];\n      for (var i = vertexOffset; i < vertexOffset + vertexCount; i++) {\n        geometry.attributes.position.get(i, pos);\n        pos[0] *= xScale;\n        pos[1] *= yScale;\n        pos[2] *= zScale;\n        if (i > vertexOffset) {\n          dist += vec3.dist(pos, posPrev);\n        }\n        geometry.attributes.dist.set(i, dist);\n        vec3.copy(posPrev, pos);\n      }\n      maxDistance = Math.max(maxDistance, dist);\n      var randomStart = Math.random() * (useConstantSpeed ? dist : period);\n      for (var i = vertexOffset; i < vertexOffset + vertexCount; i++) {\n        geometry.attributes.distAll.set(i, dist);\n        geometry.attributes.start.set(i, randomStart);\n        geometry.attributes.offset.set(i, sign(lines3DGeometry.attributes.offset.get(i)) * size / 2);\n        geometry.attributes.color.set(i, colorArr);\n      }\n      vertexOffset += vertexCount;\n    });\n    this.material.set('spotSize', maxDistance * 0.1 * trailLength);\n    this.material.set('spotIntensity', effectModel.get('spotIntensity'));\n    geometry.dirty();\n  },\n  setAnimationTime: function (time) {\n    this.material.set('time', time);\n  }\n});","map":{"version":3,"names":["echarts","graphicGL","glmatrix","Lines3DGeometry","trail2GLSL","getItemVisualColor","getItemVisualOpacity","vec3","sign","a","Shader","import","Mesh","extend","material","Material","shader","source","transparent","depthMask","geometry","dynamic","createAttribute","culling","$ignorePicking","updateData","data","api","lines3DGeometry","seriesModel","hostModel","effectModel","getModel","size","get","getDevicePixelRatio","trailLength","speed","period","useConstantSpeed","process","env","NODE_ENV","getScene","console","error","set","isPolyline","resetOffset","forEach","attrName","attributes","value","extraAttrs","init","vertexCount","indices","colorArr","effectColor","effectOpacity","hasEffectColor","hasEffectOpacity","updateWorldTransform","xScale","worldTransform","x","len","yScale","y","zScale","z","vertexOffset","maxDistance","each","idx","pts","getItemLayout","opacity","color","parseColor","getPolylineVertexCount","getCubicCurveVertexCount","dist","pos","posPrev","i","position","copy","Math","max","randomStart","random","distAll","start","offset","dirty","setAnimationTime","time"],"sources":["E:/mytest/node_modules/echarts-gl/lib/chart/lines3D/TrailMesh2.js"],"sourcesContent":["import * as echarts from 'echarts/lib/echarts';\nimport graphicGL from '../../util/graphicGL';\nimport glmatrix from 'claygl/src/dep/glmatrix';\nimport Lines3DGeometry from '../../util/geometry/Lines3D';\nimport trail2GLSL from './shader/trail2.glsl.js';\nimport { getItemVisualColor, getItemVisualOpacity } from '../../util/visual';\nvar vec3 = glmatrix.vec3;\n\nfunction sign(a) {\n  return a > 0 ? 1 : -1;\n}\n\ngraphicGL.Shader.import(trail2GLSL);\nexport default graphicGL.Mesh.extend(function () {\n  var material = new graphicGL.Material({\n    shader: new graphicGL.Shader(graphicGL.Shader.source('ecgl.trail2.vertex'), graphicGL.Shader.source('ecgl.trail2.fragment')),\n    transparent: true,\n    depthMask: false\n  });\n  var geometry = new Lines3DGeometry({\n    dynamic: true\n  });\n  geometry.createAttribute('dist', 'float', 1);\n  geometry.createAttribute('distAll', 'float', 1);\n  geometry.createAttribute('start', 'float', 1);\n  return {\n    geometry: geometry,\n    material: material,\n    culling: false,\n    $ignorePicking: true\n  };\n}, {\n  updateData: function (data, api, lines3DGeometry) {\n    var seriesModel = data.hostModel;\n    var geometry = this.geometry;\n    var effectModel = seriesModel.getModel('effect');\n    var size = effectModel.get('trailWidth') * api.getDevicePixelRatio();\n    var trailLength = effectModel.get('trailLength');\n    var speed = seriesModel.get('effect.constantSpeed');\n    var period = seriesModel.get('effect.period') * 1000;\n    var useConstantSpeed = speed != null;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!this.getScene()) {\n        console.error('TrailMesh must been add to scene before updateData');\n      }\n    }\n\n    useConstantSpeed ? this.material.set('speed', speed / 1000) : this.material.set('period', period);\n    this.material[useConstantSpeed ? 'define' : 'undefine']('vertex', 'CONSTANT_SPEED');\n    var isPolyline = seriesModel.get('polyline');\n    geometry.trailLength = trailLength;\n    this.material.set('trailLength', trailLength);\n    geometry.resetOffset();\n    ['position', 'positionPrev', 'positionNext'].forEach(function (attrName) {\n      geometry.attributes[attrName].value = lines3DGeometry.attributes[attrName].value;\n    });\n    var extraAttrs = ['dist', 'distAll', 'start', 'offset', 'color'];\n    extraAttrs.forEach(function (attrName) {\n      geometry.attributes[attrName].init(geometry.vertexCount);\n    });\n    geometry.indices = lines3DGeometry.indices;\n    var colorArr = [];\n    var effectColor = effectModel.get('trailColor');\n    var effectOpacity = effectModel.get('trailOpacity');\n    var hasEffectColor = effectColor != null;\n    var hasEffectOpacity = effectOpacity != null;\n    this.updateWorldTransform();\n    var xScale = this.worldTransform.x.len();\n    var yScale = this.worldTransform.y.len();\n    var zScale = this.worldTransform.z.len();\n    var vertexOffset = 0;\n    var maxDistance = 0;\n    data.each(function (idx) {\n      var pts = data.getItemLayout(idx);\n      var opacity = hasEffectOpacity ? effectOpacity : getItemVisualOpacity(data, idx);\n      var color = getItemVisualColor(data, idx);\n\n      if (opacity == null) {\n        opacity = 1;\n      }\n\n      colorArr = graphicGL.parseColor(hasEffectColor ? effectColor : color, colorArr);\n      colorArr[3] *= opacity;\n      var vertexCount = isPolyline ? lines3DGeometry.getPolylineVertexCount(pts) : lines3DGeometry.getCubicCurveVertexCount(pts[0], pts[1], pts[2], pts[3]);\n      var dist = 0;\n      var pos = [];\n      var posPrev = [];\n\n      for (var i = vertexOffset; i < vertexOffset + vertexCount; i++) {\n        geometry.attributes.position.get(i, pos);\n        pos[0] *= xScale;\n        pos[1] *= yScale;\n        pos[2] *= zScale;\n\n        if (i > vertexOffset) {\n          dist += vec3.dist(pos, posPrev);\n        }\n\n        geometry.attributes.dist.set(i, dist);\n        vec3.copy(posPrev, pos);\n      }\n\n      maxDistance = Math.max(maxDistance, dist);\n      var randomStart = Math.random() * (useConstantSpeed ? dist : period);\n\n      for (var i = vertexOffset; i < vertexOffset + vertexCount; i++) {\n        geometry.attributes.distAll.set(i, dist);\n        geometry.attributes.start.set(i, randomStart);\n        geometry.attributes.offset.set(i, sign(lines3DGeometry.attributes.offset.get(i)) * size / 2);\n        geometry.attributes.color.set(i, colorArr);\n      }\n\n      vertexOffset += vertexCount;\n    });\n    this.material.set('spotSize', maxDistance * 0.1 * trailLength);\n    this.material.set('spotIntensity', effectModel.get('spotIntensity'));\n    geometry.dirty();\n  },\n  setAnimationTime: function (time) {\n    this.material.set('time', time);\n  }\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}