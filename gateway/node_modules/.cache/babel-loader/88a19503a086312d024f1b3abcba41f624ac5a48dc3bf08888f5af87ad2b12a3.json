{"ast":null,"code":"import \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport vendor from './core/vendor';\nimport vec3 from './glmatrix/vec3';\nimport mat4 from './glmatrix/mat4';\nimport BoundingBox from './math/BoundingBox';\nimport GeometryBase from './GeometryBase';\nvar vec3Create = vec3.create;\nvar vec3Add = vec3.add;\nvar vec3Set = vec3.set;\nvar Attribute = GeometryBase.Attribute;\n\n/**\n * Geometry in ClayGL contains vertex attributes of mesh. These vertex attributes will be finally provided to the {@link clay.Shader}.\n * Different {@link clay.Shader} needs different attributes. Here is a list of attributes used in the builtin shaders.\n *\n * + position: `clay.basic`, `clay.lambert`, `clay.standard`\n * + texcoord0: `clay.basic`, `clay.lambert`, `clay.standard`\n * + color: `clay.basic`, `clay.lambert`, `clay.standard`\n * + weight: `clay.basic`, `clay.lambert`, `clay.standard`\n * + joint: `clay.basic`, `clay.lambert`, `clay.standard`\n * + normal: `clay.lambert`, `clay.standard`\n * + tangent: `clay.standard`\n *\n * #### Create a procedural geometry\n *\n * ClayGL provides a couple of builtin procedural geometries. Inlcuding:\n *\n *  + {@link clay.geometry.Cube}\n *  + {@link clay.geometry.Sphere}\n *  + {@link clay.geometry.Plane}\n *  + {@link clay.geometry.Cylinder}\n *  + {@link clay.geometry.Cone}\n *  + {@link clay.geometry.ParametricSurface}\n *\n * It's simple to create a basic geometry with these classes.\n *\n```js\nvar sphere = new clay.geometry.Sphere({\n    radius: 2\n});\n```\n *\n * #### Create the geometry data by yourself\n *\n * Usually the vertex attributes data are created by the {@link clay.loader.GLTF} or procedural geometries like {@link clay.geometry.Sphere}.\n * Besides these, you can create the data manually. Here is a simple example to create a triangle.\n```js\nvar TRIANGLE_POSITIONS = [\n    [-0.5, -0.5, 0],\n    [0.5, -0.5, 0],\n    [0, 0.5, 0]\n];\nvar geometry = new clay.StaticGeometryBase();\n// Add triangle vertices to position attribute.\ngeometry.attributes.position.fromArray(TRIANGLE_POSITIONS);\n```\n * Then you can use the utility methods like `generateVertexNormals`, `generateTangents` to create the remaining necessary attributes.\n *\n *\n * #### Use with custom shaders\n *\n * If you wan't to write custom shaders. Don't forget to add SEMANTICS to these attributes. For example\n *\n ```glsl\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform mat4 worldInverseTranspose : WORLDINVERSETRANSPOSE;\nuniform mat4 world : WORLD;\n\nattribute vec3 position : POSITION;\nattribute vec2 texcoord : TEXCOORD_0;\nattribute vec3 normal : NORMAL;\n```\n * These `POSITION`, `TEXCOORD_0`, `NORMAL` are SEMANTICS which will map the attributes in shader to the attributes in the GeometryBase\n *\n * Available attributes SEMANTICS includes `POSITION`, `TEXCOORD_0`, `TEXCOORD_1` `NORMAL`, `TANGENT`, `COLOR`, `WEIGHT`, `JOINT`.\n *\n *\n * @constructor clay.Geometry\n * @extends clay.GeometryBase\n */\nvar Geometry = GeometryBase.extend(function () {\n  return /** @lends clay.Geometry# */{\n    /**\n     * Attributes of geometry. Including:\n     *  + `position`\n     *  + `texcoord0`\n     *  + `texcoord1`\n     *  + `normal`\n     *  + `tangent`\n     *  + `color`\n     *  + `weight`\n     *  + `joint`\n     *  + `barycentric`\n     *\n     * @type {Object.<string, clay.Geometry.Attribute>}\n     */\n    attributes: {\n      position: new Attribute('position', 'float', 3, 'POSITION'),\n      texcoord0: new Attribute('texcoord0', 'float', 2, 'TEXCOORD_0'),\n      texcoord1: new Attribute('texcoord1', 'float', 2, 'TEXCOORD_1'),\n      normal: new Attribute('normal', 'float', 3, 'NORMAL'),\n      tangent: new Attribute('tangent', 'float', 4, 'TANGENT'),\n      color: new Attribute('color', 'float', 4, 'COLOR'),\n      // Skinning attributes\n      // Each vertex can be bind to 4 bones, because the\n      // sum of weights is 1, so the weights is stored in vec3 and the last\n      // can be calculated by 1-w.x-w.y-w.z\n      weight: new Attribute('weight', 'float', 3, 'WEIGHT'),\n      joint: new Attribute('joint', 'float', 4, 'JOINT'),\n      // For wireframe display\n      // http://codeflow.org/entries/2012/aug/02/easy-wireframe-display-with-barycentric-coordinates/\n      barycentric: new Attribute('barycentric', 'float', 3, null)\n    },\n    /**\n     * Calculated bounding box of geometry.\n     * @type {clay.BoundingBox}\n     */\n    boundingBox: null\n  };\n}, /** @lends clay.Geometry.prototype */\n{\n  mainAttribute: 'position',\n  /**\n   * Update boundingBox of Geometry\n   */\n  updateBoundingBox: function () {\n    var bbox = this.boundingBox;\n    if (!bbox) {\n      bbox = this.boundingBox = new BoundingBox();\n    }\n    var posArr = this.attributes.position.value;\n    if (posArr && posArr.length) {\n      var min = bbox.min;\n      var max = bbox.max;\n      var minArr = min.array;\n      var maxArr = max.array;\n      vec3.set(minArr, posArr[0], posArr[1], posArr[2]);\n      vec3.set(maxArr, posArr[0], posArr[1], posArr[2]);\n      for (var i = 3; i < posArr.length;) {\n        var x = posArr[i++];\n        var y = posArr[i++];\n        var z = posArr[i++];\n        if (x < minArr[0]) {\n          minArr[0] = x;\n        }\n        if (y < minArr[1]) {\n          minArr[1] = y;\n        }\n        if (z < minArr[2]) {\n          minArr[2] = z;\n        }\n        if (x > maxArr[0]) {\n          maxArr[0] = x;\n        }\n        if (y > maxArr[1]) {\n          maxArr[1] = y;\n        }\n        if (z > maxArr[2]) {\n          maxArr[2] = z;\n        }\n      }\n      min._dirty = true;\n      max._dirty = true;\n    }\n  },\n  /**\n   * Generate normals per vertex.\n   */\n  generateVertexNormals: function () {\n    if (!this.vertexCount) {\n      return;\n    }\n    var indices = this.indices;\n    var attributes = this.attributes;\n    var positions = attributes.position.value;\n    var normals = attributes.normal.value;\n    if (!normals || normals.length !== positions.length) {\n      normals = attributes.normal.value = new vendor.Float32Array(positions.length);\n    } else {\n      // Reset\n      for (var i = 0; i < normals.length; i++) {\n        normals[i] = 0;\n      }\n    }\n    var p1 = vec3Create();\n    var p2 = vec3Create();\n    var p3 = vec3Create();\n    var v21 = vec3Create();\n    var v32 = vec3Create();\n    var n = vec3Create();\n    var len = indices ? indices.length : this.vertexCount;\n    var i1, i2, i3;\n    for (var f = 0; f < len;) {\n      if (indices) {\n        i1 = indices[f++];\n        i2 = indices[f++];\n        i3 = indices[f++];\n      } else {\n        i1 = f++;\n        i2 = f++;\n        i3 = f++;\n      }\n      vec3Set(p1, positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);\n      vec3Set(p2, positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);\n      vec3Set(p3, positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);\n      vec3.sub(v21, p1, p2);\n      vec3.sub(v32, p2, p3);\n      vec3.cross(n, v21, v32);\n      // Already be weighted by the triangle area\n      for (var i = 0; i < 3; i++) {\n        normals[i1 * 3 + i] = normals[i1 * 3 + i] + n[i];\n        normals[i2 * 3 + i] = normals[i2 * 3 + i] + n[i];\n        normals[i3 * 3 + i] = normals[i3 * 3 + i] + n[i];\n      }\n    }\n    for (var i = 0; i < normals.length;) {\n      vec3Set(n, normals[i], normals[i + 1], normals[i + 2]);\n      vec3.normalize(n, n);\n      normals[i++] = n[0];\n      normals[i++] = n[1];\n      normals[i++] = n[2];\n    }\n    this.dirty();\n  },\n  /**\n   * Generate normals per face.\n   */\n  generateFaceNormals: function () {\n    if (!this.vertexCount) {\n      return;\n    }\n    if (!this.isUniqueVertex()) {\n      this.generateUniqueVertex();\n    }\n    var indices = this.indices;\n    var attributes = this.attributes;\n    var positions = attributes.position.value;\n    var normals = attributes.normal.value;\n    var p1 = vec3Create();\n    var p2 = vec3Create();\n    var p3 = vec3Create();\n    var v21 = vec3Create();\n    var v32 = vec3Create();\n    var n = vec3Create();\n    if (!normals) {\n      normals = attributes.normal.value = new Float32Array(positions.length);\n    }\n    var len = indices ? indices.length : this.vertexCount;\n    var i1, i2, i3;\n    for (var f = 0; f < len;) {\n      if (indices) {\n        i1 = indices[f++];\n        i2 = indices[f++];\n        i3 = indices[f++];\n      } else {\n        i1 = f++;\n        i2 = f++;\n        i3 = f++;\n      }\n      vec3Set(p1, positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);\n      vec3Set(p2, positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);\n      vec3Set(p3, positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);\n      vec3.sub(v21, p1, p2);\n      vec3.sub(v32, p2, p3);\n      vec3.cross(n, v21, v32);\n      vec3.normalize(n, n);\n      for (var i = 0; i < 3; i++) {\n        normals[i1 * 3 + i] = n[i];\n        normals[i2 * 3 + i] = n[i];\n        normals[i3 * 3 + i] = n[i];\n      }\n    }\n    this.dirty();\n  },\n  /**\n   * Generate tangents attributes.\n   */\n  generateTangents: function () {\n    if (!this.vertexCount) {\n      return;\n    }\n    var nVertex = this.vertexCount;\n    var attributes = this.attributes;\n    if (!attributes.tangent.value) {\n      attributes.tangent.value = new Float32Array(nVertex * 4);\n    }\n    var texcoords = attributes.texcoord0.value;\n    var positions = attributes.position.value;\n    var tangents = attributes.tangent.value;\n    var normals = attributes.normal.value;\n    if (!texcoords) {\n      console.warn('Geometry without texcoords can\\'t generate tangents.');\n      return;\n    }\n    var tan1 = [];\n    var tan2 = [];\n    for (var i = 0; i < nVertex; i++) {\n      tan1[i] = [0.0, 0.0, 0.0];\n      tan2[i] = [0.0, 0.0, 0.0];\n    }\n    var sdir = [0.0, 0.0, 0.0];\n    var tdir = [0.0, 0.0, 0.0];\n    var indices = this.indices;\n    var len = indices ? indices.length : this.vertexCount;\n    var i1, i2, i3;\n    for (var i = 0; i < len;) {\n      if (indices) {\n        i1 = indices[i++];\n        i2 = indices[i++];\n        i3 = indices[i++];\n      } else {\n        i1 = i++;\n        i2 = i++;\n        i3 = i++;\n      }\n      var st1s = texcoords[i1 * 2],\n        st2s = texcoords[i2 * 2],\n        st3s = texcoords[i3 * 2],\n        st1t = texcoords[i1 * 2 + 1],\n        st2t = texcoords[i2 * 2 + 1],\n        st3t = texcoords[i3 * 2 + 1],\n        p1x = positions[i1 * 3],\n        p2x = positions[i2 * 3],\n        p3x = positions[i3 * 3],\n        p1y = positions[i1 * 3 + 1],\n        p2y = positions[i2 * 3 + 1],\n        p3y = positions[i3 * 3 + 1],\n        p1z = positions[i1 * 3 + 2],\n        p2z = positions[i2 * 3 + 2],\n        p3z = positions[i3 * 3 + 2];\n      var x1 = p2x - p1x,\n        x2 = p3x - p1x,\n        y1 = p2y - p1y,\n        y2 = p3y - p1y,\n        z1 = p2z - p1z,\n        z2 = p3z - p1z;\n      var s1 = st2s - st1s,\n        s2 = st3s - st1s,\n        t1 = st2t - st1t,\n        t2 = st3t - st1t;\n      var r = 1.0 / (s1 * t2 - t1 * s2);\n      sdir[0] = (t2 * x1 - t1 * x2) * r;\n      sdir[1] = (t2 * y1 - t1 * y2) * r;\n      sdir[2] = (t2 * z1 - t1 * z2) * r;\n      tdir[0] = (s1 * x2 - s2 * x1) * r;\n      tdir[1] = (s1 * y2 - s2 * y1) * r;\n      tdir[2] = (s1 * z2 - s2 * z1) * r;\n      vec3Add(tan1[i1], tan1[i1], sdir);\n      vec3Add(tan1[i2], tan1[i2], sdir);\n      vec3Add(tan1[i3], tan1[i3], sdir);\n      vec3Add(tan2[i1], tan2[i1], tdir);\n      vec3Add(tan2[i2], tan2[i2], tdir);\n      vec3Add(tan2[i3], tan2[i3], tdir);\n    }\n    var tmp = vec3Create();\n    var nCrossT = vec3Create();\n    var n = vec3Create();\n    for (var i = 0; i < nVertex; i++) {\n      n[0] = normals[i * 3];\n      n[1] = normals[i * 3 + 1];\n      n[2] = normals[i * 3 + 2];\n      var t = tan1[i];\n\n      // Gram-Schmidt orthogonalize\n      vec3.scale(tmp, n, vec3.dot(n, t));\n      vec3.sub(tmp, t, tmp);\n      vec3.normalize(tmp, tmp);\n      // Calculate handedness.\n      vec3.cross(nCrossT, n, t);\n      tangents[i * 4] = tmp[0];\n      tangents[i * 4 + 1] = tmp[1];\n      tangents[i * 4 + 2] = tmp[2];\n      // PENDING can config ?\n      tangents[i * 4 + 3] = vec3.dot(nCrossT, tan2[i]) < 0.0 ? -1.0 : 1.0;\n    }\n    this.dirty();\n  },\n  /**\n   * If vertices are not shared by different indices.\n   */\n  isUniqueVertex: function () {\n    if (this.isUseIndices()) {\n      return this.vertexCount === this.indices.length;\n    } else {\n      return true;\n    }\n  },\n  /**\n   * Create a unique vertex for each index.\n   */\n  generateUniqueVertex: function () {\n    if (!this.vertexCount || !this.indices) {\n      return;\n    }\n    if (this.indices.length > 0xffff) {\n      this.indices = new vendor.Uint32Array(this.indices);\n    }\n    var attributes = this.attributes;\n    var indices = this.indices;\n    var attributeNameList = this.getEnabledAttributes();\n    var oldAttrValues = {};\n    for (var a = 0; a < attributeNameList.length; a++) {\n      var name = attributeNameList[a];\n      oldAttrValues[name] = attributes[name].value;\n      attributes[name].init(this.indices.length);\n    }\n    var cursor = 0;\n    for (var i = 0; i < indices.length; i++) {\n      var ii = indices[i];\n      for (var a = 0; a < attributeNameList.length; a++) {\n        var name = attributeNameList[a];\n        var array = attributes[name].value;\n        var size = attributes[name].size;\n        for (var k = 0; k < size; k++) {\n          array[cursor * size + k] = oldAttrValues[name][ii * size + k];\n        }\n      }\n      indices[i] = cursor;\n      cursor++;\n    }\n    this.dirty();\n  },\n  /**\n   * Generate barycentric coordinates for wireframe draw.\n   */\n  generateBarycentric: function () {\n    if (!this.vertexCount) {\n      return;\n    }\n    if (!this.isUniqueVertex()) {\n      this.generateUniqueVertex();\n    }\n    var attributes = this.attributes;\n    var array = attributes.barycentric.value;\n    var indices = this.indices;\n    // Already existed;\n    if (array && array.length === indices.length * 3) {\n      return;\n    }\n    array = attributes.barycentric.value = new Float32Array(indices.length * 3);\n    for (var i = 0; i < (indices ? indices.length : this.vertexCount / 3);) {\n      for (var j = 0; j < 3; j++) {\n        var ii = indices ? indices[i++] : i * 3 + j;\n        array[ii * 3 + j] = 1;\n      }\n    }\n    this.dirty();\n  },\n  /**\n   * Apply transform to geometry attributes.\n   * @param {clay.Matrix4} matrix\n   */\n  applyTransform: function (matrix) {\n    var attributes = this.attributes;\n    var positions = attributes.position.value;\n    var normals = attributes.normal.value;\n    var tangents = attributes.tangent.value;\n    matrix = matrix.array;\n    // Normal Matrix\n    var inverseTransposeMatrix = mat4.create();\n    mat4.invert(inverseTransposeMatrix, matrix);\n    mat4.transpose(inverseTransposeMatrix, inverseTransposeMatrix);\n    var vec3TransformMat4 = vec3.transformMat4;\n    var vec3ForEach = vec3.forEach;\n    vec3ForEach(positions, 3, 0, null, vec3TransformMat4, matrix);\n    if (normals) {\n      vec3ForEach(normals, 3, 0, null, vec3TransformMat4, inverseTransposeMatrix);\n    }\n    if (tangents) {\n      vec3ForEach(tangents, 4, 0, null, vec3TransformMat4, inverseTransposeMatrix);\n    }\n    if (this.boundingBox) {\n      this.updateBoundingBox();\n    }\n  },\n  /**\n   * Dispose geometry data in GL context.\n   * @param {clay.Renderer} renderer\n   */\n  dispose: function (renderer) {\n    var cache = this._cache;\n    cache.use(renderer.__uid__);\n    var chunks = cache.get('chunks');\n    if (chunks) {\n      for (var c = 0; c < chunks.length; c++) {\n        var chunk = chunks[c];\n        for (var k = 0; k < chunk.attributeBuffers.length; k++) {\n          var attribs = chunk.attributeBuffers[k];\n          renderer.gl.deleteBuffer(attribs.buffer);\n        }\n        if (chunk.indicesBuffer) {\n          renderer.gl.deleteBuffer(chunk.indicesBuffer.buffer);\n        }\n      }\n    }\n    if (this.__vaoCache) {\n      var vaoExt = renderer.getGLExtension('OES_vertex_array_object');\n      for (var id in this.__vaoCache) {\n        var vao = this.__vaoCache[id].vao;\n        if (vao) {\n          vaoExt.deleteVertexArrayOES(vao);\n        }\n      }\n    }\n    this.__vaoCache = {};\n    cache.deleteContext(renderer.__uid__);\n  }\n});\nGeometry.STATIC_DRAW = GeometryBase.STATIC_DRAW;\nGeometry.DYNAMIC_DRAW = GeometryBase.DYNAMIC_DRAW;\nGeometry.STREAM_DRAW = GeometryBase.STREAM_DRAW;\nGeometry.AttributeBuffer = GeometryBase.AttributeBuffer;\nGeometry.IndicesBuffer = GeometryBase.IndicesBuffer;\nGeometry.Attribute = Attribute;\nexport default Geometry;","map":{"version":3,"names":["vendor","vec3","mat4","BoundingBox","GeometryBase","vec3Create","create","vec3Add","add","vec3Set","set","Attribute","Geometry","extend","attributes","position","texcoord0","texcoord1","normal","tangent","color","weight","joint","barycentric","boundingBox","mainAttribute","updateBoundingBox","bbox","posArr","value","length","min","max","minArr","array","maxArr","i","x","y","z","_dirty","generateVertexNormals","vertexCount","indices","positions","normals","Float32Array","p1","p2","p3","v21","v32","n","len","i1","i2","i3","f","sub","cross","normalize","dirty","generateFaceNormals","isUniqueVertex","generateUniqueVertex","generateTangents","nVertex","texcoords","tangents","console","warn","tan1","tan2","sdir","tdir","st1s","st2s","st3s","st1t","st2t","st3t","p1x","p2x","p3x","p1y","p2y","p3y","p1z","p2z","p3z","x1","x2","y1","y2","z1","z2","s1","s2","t1","t2","r","tmp","nCrossT","t","scale","dot","isUseIndices","Uint32Array","attributeNameList","getEnabledAttributes","oldAttrValues","a","name","init","cursor","ii","size","k","generateBarycentric","j","applyTransform","matrix","inverseTransposeMatrix","invert","transpose","vec3TransformMat4","transformMat4","vec3ForEach","forEach","dispose","renderer","cache","_cache","use","__uid__","chunks","get","c","chunk","attributeBuffers","attribs","gl","deleteBuffer","buffer","indicesBuffer","__vaoCache","vaoExt","getGLExtension","id","vao","deleteVertexArrayOES","deleteContext","STATIC_DRAW","DYNAMIC_DRAW","STREAM_DRAW","AttributeBuffer","IndicesBuffer"],"sources":["E:/mytest/node_modules/claygl/src/Geometry.js"],"sourcesContent":["import vendor from './core/vendor';\nimport vec3 from './glmatrix/vec3';\nimport mat4 from './glmatrix/mat4';\nimport BoundingBox from './math/BoundingBox';\nimport GeometryBase from './GeometryBase';\n\nvar vec3Create = vec3.create;\nvar vec3Add = vec3.add;\nvar vec3Set = vec3.set;\n\nvar Attribute = GeometryBase.Attribute;\n\n/**\n * Geometry in ClayGL contains vertex attributes of mesh. These vertex attributes will be finally provided to the {@link clay.Shader}.\n * Different {@link clay.Shader} needs different attributes. Here is a list of attributes used in the builtin shaders.\n *\n * + position: `clay.basic`, `clay.lambert`, `clay.standard`\n * + texcoord0: `clay.basic`, `clay.lambert`, `clay.standard`\n * + color: `clay.basic`, `clay.lambert`, `clay.standard`\n * + weight: `clay.basic`, `clay.lambert`, `clay.standard`\n * + joint: `clay.basic`, `clay.lambert`, `clay.standard`\n * + normal: `clay.lambert`, `clay.standard`\n * + tangent: `clay.standard`\n *\n * #### Create a procedural geometry\n *\n * ClayGL provides a couple of builtin procedural geometries. Inlcuding:\n *\n *  + {@link clay.geometry.Cube}\n *  + {@link clay.geometry.Sphere}\n *  + {@link clay.geometry.Plane}\n *  + {@link clay.geometry.Cylinder}\n *  + {@link clay.geometry.Cone}\n *  + {@link clay.geometry.ParametricSurface}\n *\n * It's simple to create a basic geometry with these classes.\n *\n```js\nvar sphere = new clay.geometry.Sphere({\n    radius: 2\n});\n```\n *\n * #### Create the geometry data by yourself\n *\n * Usually the vertex attributes data are created by the {@link clay.loader.GLTF} or procedural geometries like {@link clay.geometry.Sphere}.\n * Besides these, you can create the data manually. Here is a simple example to create a triangle.\n```js\nvar TRIANGLE_POSITIONS = [\n    [-0.5, -0.5, 0],\n    [0.5, -0.5, 0],\n    [0, 0.5, 0]\n];\nvar geometry = new clay.StaticGeometryBase();\n// Add triangle vertices to position attribute.\ngeometry.attributes.position.fromArray(TRIANGLE_POSITIONS);\n```\n * Then you can use the utility methods like `generateVertexNormals`, `generateTangents` to create the remaining necessary attributes.\n *\n *\n * #### Use with custom shaders\n *\n * If you wan't to write custom shaders. Don't forget to add SEMANTICS to these attributes. For example\n *\n ```glsl\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform mat4 worldInverseTranspose : WORLDINVERSETRANSPOSE;\nuniform mat4 world : WORLD;\n\nattribute vec3 position : POSITION;\nattribute vec2 texcoord : TEXCOORD_0;\nattribute vec3 normal : NORMAL;\n```\n * These `POSITION`, `TEXCOORD_0`, `NORMAL` are SEMANTICS which will map the attributes in shader to the attributes in the GeometryBase\n *\n * Available attributes SEMANTICS includes `POSITION`, `TEXCOORD_0`, `TEXCOORD_1` `NORMAL`, `TANGENT`, `COLOR`, `WEIGHT`, `JOINT`.\n *\n *\n * @constructor clay.Geometry\n * @extends clay.GeometryBase\n */\nvar Geometry = GeometryBase.extend(function () {\n    return /** @lends clay.Geometry# */ {\n        /**\n         * Attributes of geometry. Including:\n         *  + `position`\n         *  + `texcoord0`\n         *  + `texcoord1`\n         *  + `normal`\n         *  + `tangent`\n         *  + `color`\n         *  + `weight`\n         *  + `joint`\n         *  + `barycentric`\n         *\n         * @type {Object.<string, clay.Geometry.Attribute>}\n         */\n        attributes: {\n            position: new Attribute('position', 'float', 3, 'POSITION'),\n            texcoord0: new Attribute('texcoord0', 'float', 2, 'TEXCOORD_0'),\n            texcoord1: new Attribute('texcoord1', 'float', 2, 'TEXCOORD_1'),\n            normal: new Attribute('normal', 'float', 3, 'NORMAL'),\n            tangent: new Attribute('tangent', 'float', 4, 'TANGENT'),\n            color: new Attribute('color', 'float', 4, 'COLOR'),\n            // Skinning attributes\n            // Each vertex can be bind to 4 bones, because the\n            // sum of weights is 1, so the weights is stored in vec3 and the last\n            // can be calculated by 1-w.x-w.y-w.z\n            weight: new Attribute('weight', 'float', 3, 'WEIGHT'),\n            joint: new Attribute('joint', 'float', 4, 'JOINT'),\n            // For wireframe display\n            // http://codeflow.org/entries/2012/aug/02/easy-wireframe-display-with-barycentric-coordinates/\n            barycentric: new Attribute('barycentric', 'float', 3, null),\n        },\n        /**\n         * Calculated bounding box of geometry.\n         * @type {clay.BoundingBox}\n         */\n        boundingBox: null\n    };\n},\n/** @lends clay.Geometry.prototype */\n{\n\n    mainAttribute: 'position',\n\n    /**\n     * Update boundingBox of Geometry\n     */\n    updateBoundingBox: function () {\n        var bbox = this.boundingBox;\n        if (!bbox) {\n            bbox = this.boundingBox = new BoundingBox();\n        }\n        var posArr = this.attributes.position.value;\n        if (posArr && posArr.length) {\n            var min = bbox.min;\n            var max = bbox.max;\n            var minArr = min.array;\n            var maxArr = max.array;\n            vec3.set(minArr, posArr[0], posArr[1], posArr[2]);\n            vec3.set(maxArr, posArr[0], posArr[1], posArr[2]);\n            for (var i = 3; i < posArr.length;) {\n                var x = posArr[i++];\n                var y = posArr[i++];\n                var z = posArr[i++];\n                if (x < minArr[0]) { minArr[0] = x; }\n                if (y < minArr[1]) { minArr[1] = y; }\n                if (z < minArr[2]) { minArr[2] = z; }\n\n                if (x > maxArr[0]) { maxArr[0] = x; }\n                if (y > maxArr[1]) { maxArr[1] = y; }\n                if (z > maxArr[2]) { maxArr[2] = z; }\n            }\n            min._dirty = true;\n            max._dirty = true;\n        }\n    },\n\n    /**\n     * Generate normals per vertex.\n     */\n    generateVertexNormals: function () {\n        if (!this.vertexCount) {\n            return;\n        }\n\n        var indices = this.indices;\n        var attributes = this.attributes;\n        var positions = attributes.position.value;\n        var normals = attributes.normal.value;\n\n        if (!normals || normals.length !== positions.length) {\n            normals = attributes.normal.value = new vendor.Float32Array(positions.length);\n        }\n        else {\n            // Reset\n            for (var i = 0; i < normals.length; i++) {\n                normals[i] = 0;\n            }\n        }\n\n        var p1 = vec3Create();\n        var p2 = vec3Create();\n        var p3 = vec3Create();\n\n        var v21 = vec3Create();\n        var v32 = vec3Create();\n\n        var n = vec3Create();\n\n        var len = indices ? indices.length : this.vertexCount;\n        var i1, i2, i3;\n        for (var f = 0; f < len;) {\n            if (indices) {\n                i1 = indices[f++];\n                i2 = indices[f++];\n                i3 = indices[f++];\n            }\n            else {\n                i1 = f++;\n                i2 = f++;\n                i3 = f++;\n            }\n\n            vec3Set(p1, positions[i1*3], positions[i1*3+1], positions[i1*3+2]);\n            vec3Set(p2, positions[i2*3], positions[i2*3+1], positions[i2*3+2]);\n            vec3Set(p3, positions[i3*3], positions[i3*3+1], positions[i3*3+2]);\n\n            vec3.sub(v21, p1, p2);\n            vec3.sub(v32, p2, p3);\n            vec3.cross(n, v21, v32);\n            // Already be weighted by the triangle area\n            for (var i = 0; i < 3; i++) {\n                normals[i1*3+i] = normals[i1*3+i] + n[i];\n                normals[i2*3+i] = normals[i2*3+i] + n[i];\n                normals[i3*3+i] = normals[i3*3+i] + n[i];\n            }\n        }\n\n        for (var i = 0; i < normals.length;) {\n            vec3Set(n, normals[i], normals[i+1], normals[i+2]);\n            vec3.normalize(n, n);\n            normals[i++] = n[0];\n            normals[i++] = n[1];\n            normals[i++] = n[2];\n        }\n        this.dirty();\n    },\n\n    /**\n     * Generate normals per face.\n     */\n    generateFaceNormals: function () {\n        if (!this.vertexCount) {\n            return;\n        }\n\n        if (!this.isUniqueVertex()) {\n            this.generateUniqueVertex();\n        }\n\n        var indices = this.indices;\n        var attributes = this.attributes;\n        var positions = attributes.position.value;\n        var normals = attributes.normal.value;\n\n        var p1 = vec3Create();\n        var p2 = vec3Create();\n        var p3 = vec3Create();\n\n        var v21 = vec3Create();\n        var v32 = vec3Create();\n        var n = vec3Create();\n\n        if (!normals) {\n            normals = attributes.normal.value = new Float32Array(positions.length);\n        }\n        var len = indices ? indices.length : this.vertexCount;\n        var i1, i2, i3;\n        for (var f = 0; f < len;) {\n            if (indices) {\n                i1 = indices[f++];\n                i2 = indices[f++];\n                i3 = indices[f++];\n            }\n            else {\n                i1 = f++;\n                i2 = f++;\n                i3 = f++;\n            }\n\n            vec3Set(p1, positions[i1*3], positions[i1*3+1], positions[i1*3+2]);\n            vec3Set(p2, positions[i2*3], positions[i2*3+1], positions[i2*3+2]);\n            vec3Set(p3, positions[i3*3], positions[i3*3+1], positions[i3*3+2]);\n\n            vec3.sub(v21, p1, p2);\n            vec3.sub(v32, p2, p3);\n            vec3.cross(n, v21, v32);\n\n            vec3.normalize(n, n);\n\n            for (var i = 0; i < 3; i++) {\n                normals[i1*3 + i] = n[i];\n                normals[i2*3 + i] = n[i];\n                normals[i3*3 + i] = n[i];\n            }\n        }\n        this.dirty();\n    },\n\n    /**\n     * Generate tangents attributes.\n     */\n    generateTangents: function () {\n        if (!this.vertexCount) {\n            return;\n        }\n\n        var nVertex = this.vertexCount;\n        var attributes = this.attributes;\n        if (!attributes.tangent.value) {\n            attributes.tangent.value = new Float32Array(nVertex * 4);\n        }\n        var texcoords = attributes.texcoord0.value;\n        var positions = attributes.position.value;\n        var tangents = attributes.tangent.value;\n        var normals = attributes.normal.value;\n\n        if (!texcoords) {\n            console.warn('Geometry without texcoords can\\'t generate tangents.');\n            return;\n        }\n\n        var tan1 = [];\n        var tan2 = [];\n        for (var i = 0; i < nVertex; i++) {\n            tan1[i] = [0.0, 0.0, 0.0];\n            tan2[i] = [0.0, 0.0, 0.0];\n        }\n\n        var sdir = [0.0, 0.0, 0.0];\n        var tdir = [0.0, 0.0, 0.0];\n        var indices = this.indices;\n\n        var len = indices ? indices.length : this.vertexCount;\n        var i1, i2, i3;\n        for (var i = 0; i < len;) {\n            if (indices) {\n                i1 = indices[i++];\n                i2 = indices[i++];\n                i3 = indices[i++];\n            }\n            else {\n                i1 = i++;\n                i2 = i++;\n                i3 = i++;\n            }\n\n            var st1s = texcoords[i1 * 2],\n                st2s = texcoords[i2 * 2],\n                st3s = texcoords[i3 * 2],\n                st1t = texcoords[i1 * 2 + 1],\n                st2t = texcoords[i2 * 2 + 1],\n                st3t = texcoords[i3 * 2 + 1],\n\n                p1x = positions[i1 * 3],\n                p2x = positions[i2 * 3],\n                p3x = positions[i3 * 3],\n                p1y = positions[i1 * 3 + 1],\n                p2y = positions[i2 * 3 + 1],\n                p3y = positions[i3 * 3 + 1],\n                p1z = positions[i1 * 3 + 2],\n                p2z = positions[i2 * 3 + 2],\n                p3z = positions[i3 * 3 + 2];\n\n            var x1 = p2x - p1x,\n                x2 = p3x - p1x,\n                y1 = p2y - p1y,\n                y2 = p3y - p1y,\n                z1 = p2z - p1z,\n                z2 = p3z - p1z;\n\n            var s1 = st2s - st1s,\n                s2 = st3s - st1s,\n                t1 = st2t - st1t,\n                t2 = st3t - st1t;\n\n            var r = 1.0 / (s1 * t2 - t1 * s2);\n            sdir[0] = (t2 * x1 - t1 * x2) * r;\n            sdir[1] = (t2 * y1 - t1 * y2) * r;\n            sdir[2] = (t2 * z1 - t1 * z2) * r;\n\n            tdir[0] = (s1 * x2 - s2 * x1) * r;\n            tdir[1] = (s1 * y2 - s2 * y1) * r;\n            tdir[2] = (s1 * z2 - s2 * z1) * r;\n\n            vec3Add(tan1[i1], tan1[i1], sdir);\n            vec3Add(tan1[i2], tan1[i2], sdir);\n            vec3Add(tan1[i3], tan1[i3], sdir);\n            vec3Add(tan2[i1], tan2[i1], tdir);\n            vec3Add(tan2[i2], tan2[i2], tdir);\n            vec3Add(tan2[i3], tan2[i3], tdir);\n        }\n        var tmp = vec3Create();\n        var nCrossT = vec3Create();\n        var n = vec3Create();\n        for (var i = 0; i < nVertex; i++) {\n            n[0] = normals[i * 3];\n            n[1] = normals[i * 3 + 1];\n            n[2] = normals[i * 3 + 2];\n            var t = tan1[i];\n\n            // Gram-Schmidt orthogonalize\n            vec3.scale(tmp, n, vec3.dot(n, t));\n            vec3.sub(tmp, t, tmp);\n            vec3.normalize(tmp, tmp);\n            // Calculate handedness.\n            vec3.cross(nCrossT, n, t);\n            tangents[i * 4] = tmp[0];\n            tangents[i * 4 + 1] = tmp[1];\n            tangents[i * 4 + 2] = tmp[2];\n            // PENDING can config ?\n            tangents[i * 4 + 3] = vec3.dot(nCrossT, tan2[i]) < 0.0 ? -1.0 : 1.0;\n        }\n        this.dirty();\n    },\n\n    /**\n     * If vertices are not shared by different indices.\n     */\n    isUniqueVertex: function () {\n        if (this.isUseIndices()) {\n            return this.vertexCount === this.indices.length;\n        }\n        else {\n            return true;\n        }\n    },\n    /**\n     * Create a unique vertex for each index.\n     */\n    generateUniqueVertex: function () {\n        if (!this.vertexCount || !this.indices) {\n            return;\n        }\n\n        if (this.indices.length > 0xffff) {\n            this.indices = new vendor.Uint32Array(this.indices);\n        }\n\n        var attributes = this.attributes;\n        var indices = this.indices;\n\n        var attributeNameList = this.getEnabledAttributes();\n\n        var oldAttrValues = {};\n        for (var a = 0; a < attributeNameList.length; a++) {\n            var name = attributeNameList[a];\n            oldAttrValues[name] = attributes[name].value;\n            attributes[name].init(this.indices.length);\n        }\n\n        var cursor = 0;\n        for (var i = 0; i < indices.length; i++) {\n            var ii = indices[i];\n            for (var a = 0; a < attributeNameList.length; a++) {\n                var name = attributeNameList[a];\n                var array = attributes[name].value;\n                var size = attributes[name].size;\n\n                for (var k = 0; k < size; k++) {\n                    array[cursor * size + k] = oldAttrValues[name][ii * size + k];\n                }\n            }\n            indices[i] = cursor;\n            cursor++;\n        }\n\n        this.dirty();\n    },\n\n    /**\n     * Generate barycentric coordinates for wireframe draw.\n     */\n    generateBarycentric: function () {\n        if (!this.vertexCount) {\n            return;\n        }\n\n        if (!this.isUniqueVertex()) {\n            this.generateUniqueVertex();\n        }\n\n        var attributes = this.attributes;\n        var array = attributes.barycentric.value;\n        var indices = this.indices;\n        // Already existed;\n        if (array && array.length === indices.length * 3) {\n            return;\n        }\n        array = attributes.barycentric.value = new Float32Array(indices.length * 3);\n\n        for (var i = 0; i < (indices ? indices.length : this.vertexCount / 3);) {\n            for (var j = 0; j < 3; j++) {\n                var ii = indices ? indices[i++] : (i * 3 + j);\n                array[ii * 3 + j] = 1;\n            }\n        }\n        this.dirty();\n    },\n\n    /**\n     * Apply transform to geometry attributes.\n     * @param {clay.Matrix4} matrix\n     */\n    applyTransform: function (matrix) {\n\n        var attributes = this.attributes;\n        var positions = attributes.position.value;\n        var normals = attributes.normal.value;\n        var tangents = attributes.tangent.value;\n\n        matrix = matrix.array;\n        // Normal Matrix\n        var inverseTransposeMatrix = mat4.create();\n        mat4.invert(inverseTransposeMatrix, matrix);\n        mat4.transpose(inverseTransposeMatrix, inverseTransposeMatrix);\n\n        var vec3TransformMat4 = vec3.transformMat4;\n        var vec3ForEach = vec3.forEach;\n        vec3ForEach(positions, 3, 0, null, vec3TransformMat4, matrix);\n        if (normals) {\n            vec3ForEach(normals, 3, 0, null, vec3TransformMat4, inverseTransposeMatrix);\n        }\n        if (tangents) {\n            vec3ForEach(tangents, 4, 0, null, vec3TransformMat4, inverseTransposeMatrix);\n        }\n\n        if (this.boundingBox) {\n            this.updateBoundingBox();\n        }\n    },\n    /**\n     * Dispose geometry data in GL context.\n     * @param {clay.Renderer} renderer\n     */\n    dispose: function (renderer) {\n\n        var cache = this._cache;\n\n        cache.use(renderer.__uid__);\n        var chunks = cache.get('chunks');\n        if (chunks) {\n            for (var c = 0; c < chunks.length; c++) {\n                var chunk = chunks[c];\n\n                for (var k = 0; k < chunk.attributeBuffers.length; k++) {\n                    var attribs = chunk.attributeBuffers[k];\n                    renderer.gl.deleteBuffer(attribs.buffer);\n                }\n\n                if (chunk.indicesBuffer) {\n                    renderer.gl.deleteBuffer(chunk.indicesBuffer.buffer);\n                }\n            }\n        }\n        if (this.__vaoCache) {\n            var vaoExt = renderer.getGLExtension('OES_vertex_array_object');\n            for (var id in this.__vaoCache) {\n                var vao = this.__vaoCache[id].vao;\n                if (vao) {\n                    vaoExt.deleteVertexArrayOES(vao);\n                }\n            }\n        }\n        this.__vaoCache = {};\n        cache.deleteContext(renderer.__uid__);\n    }\n\n});\n\nGeometry.STATIC_DRAW = GeometryBase.STATIC_DRAW;\nGeometry.DYNAMIC_DRAW = GeometryBase.DYNAMIC_DRAW;\nGeometry.STREAM_DRAW = GeometryBase.STREAM_DRAW;\n\nGeometry.AttributeBuffer = GeometryBase.AttributeBuffer;\nGeometry.IndicesBuffer = GeometryBase.IndicesBuffer;\n\nGeometry.Attribute = Attribute;\n\nexport default Geometry;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}