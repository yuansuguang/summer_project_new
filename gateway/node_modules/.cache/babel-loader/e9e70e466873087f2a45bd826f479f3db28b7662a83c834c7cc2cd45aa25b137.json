{"ast":null,"code":"import \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport * as echarts from 'echarts/lib/echarts';\nimport graphicGL from '../../util/graphicGL';\nimport retrieve from '../../util/retrieve';\nimport ViewGL from '../../core/ViewGL';\nimport VectorFieldParticleSurface from './VectorFieldParticleSurface'; // TODO 百度地图不是 linear 的\n\nexport default echarts.ChartView.extend({\n  type: 'flowGL',\n  __ecgl__: true,\n  init: function (ecModel, api) {\n    this.viewGL = new ViewGL('orthographic');\n    this.groupGL = new graphicGL.Node();\n    this.viewGL.add(this.groupGL);\n    this._particleSurface = new VectorFieldParticleSurface();\n    var planeMesh = new graphicGL.Mesh({\n      geometry: new graphicGL.PlaneGeometry(),\n      material: new graphicGL.Material({\n        shader: new graphicGL.Shader({\n          vertex: graphicGL.Shader.source('ecgl.color.vertex'),\n          fragment: graphicGL.Shader.source('ecgl.color.fragment')\n        }),\n        // Must enable blending and multiply alpha.\n        // Or premultipliedAlpha will let the alpha useless.\n        transparent: true\n      })\n    });\n    planeMesh.material.enableTexture('diffuseMap');\n    this.groupGL.add(planeMesh);\n    this._planeMesh = planeMesh;\n  },\n  render: function (seriesModel, ecModel, api) {\n    var particleSurface = this._particleSurface; // Set particleType before set others.\n\n    particleSurface.setParticleType(seriesModel.get('particleType'));\n    particleSurface.setSupersampling(seriesModel.get('supersampling'));\n    this._updateData(seriesModel, api);\n    this._updateCamera(api.getWidth(), api.getHeight(), api.getDevicePixelRatio());\n    var particleDensity = retrieve.firstNotNull(seriesModel.get('particleDensity'), 128);\n    particleSurface.setParticleDensity(particleDensity, particleDensity);\n    var planeMesh = this._planeMesh;\n    var time = +new Date();\n    var self = this;\n    var firstFrame = true;\n    planeMesh.__percent = 0;\n    planeMesh.stopAnimation();\n    planeMesh.animate('', {\n      loop: true\n    }).when(100000, {\n      __percent: 1\n    }).during(function () {\n      var timeNow = +new Date();\n      var dTime = Math.min(timeNow - time, 20);\n      time = time + dTime;\n      if (self._renderer) {\n        particleSurface.update(self._renderer, api, dTime / 1000, firstFrame);\n        planeMesh.material.set('diffuseMap', particleSurface.getSurfaceTexture()); // planeMesh.material.set('diffuseMap', self._particleSurface.vectorFieldTexture);\n      }\n      firstFrame = false;\n    }).start();\n    var itemStyleModel = seriesModel.getModel('itemStyle');\n    var color = graphicGL.parseColor(itemStyleModel.get('color'));\n    color[3] *= retrieve.firstNotNull(itemStyleModel.get('opacity'), 1);\n    planeMesh.material.set('color', color);\n    particleSurface.setColorTextureImage(seriesModel.get('colorTexture'), api);\n    particleSurface.setParticleSize(seriesModel.get('particleSize'));\n    particleSurface.particleSpeedScaling = seriesModel.get('particleSpeed');\n    particleSurface.motionBlurFactor = 1.0 - Math.pow(0.1, seriesModel.get('particleTrail'));\n  },\n  updateTransform: function (seriesModel, ecModel, api) {\n    this._updateData(seriesModel, api);\n  },\n  afterRender: function (globeModel, ecModel, api, layerGL) {\n    var renderer = layerGL.renderer;\n    this._renderer = renderer;\n  },\n  _updateData: function (seriesModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var dims = coordSys.dimensions.map(function (coordDim) {\n      return seriesModel.coordDimToDataDim(coordDim)[0];\n    });\n    var data = seriesModel.getData();\n    var xExtent = data.getDataExtent(dims[0]);\n    var yExtent = data.getDataExtent(dims[1]);\n    var gridWidth = seriesModel.get('gridWidth');\n    var gridHeight = seriesModel.get('gridHeight');\n    if (gridWidth == null || gridWidth === 'auto') {\n      // TODO not accurate.\n      var aspect = (xExtent[1] - xExtent[0]) / (yExtent[1] - yExtent[0]);\n      gridWidth = Math.round(Math.sqrt(aspect * data.count()));\n    }\n    if (gridHeight == null || gridHeight === 'auto') {\n      gridHeight = Math.ceil(data.count() / gridWidth);\n    }\n    var vectorFieldTexture = this._particleSurface.vectorFieldTexture; // Half Float needs Uint16Array\n\n    var pixels = vectorFieldTexture.pixels;\n    if (!pixels || pixels.length !== gridHeight * gridWidth * 4) {\n      pixels = vectorFieldTexture.pixels = new Float32Array(gridWidth * gridHeight * 4);\n    } else {\n      for (var i = 0; i < pixels.length; i++) {\n        pixels[i] = 0;\n      }\n    }\n    var maxMag = 0;\n    var minMag = Infinity;\n    var points = new Float32Array(data.count() * 2);\n    var offset = 0;\n    var bbox = [[Infinity, Infinity], [-Infinity, -Infinity]];\n    data.each([dims[0], dims[1], 'vx', 'vy'], function (x, y, vx, vy) {\n      var pt = coordSys.dataToPoint([x, y]);\n      points[offset++] = pt[0];\n      points[offset++] = pt[1];\n      bbox[0][0] = Math.min(pt[0], bbox[0][0]);\n      bbox[0][1] = Math.min(pt[1], bbox[0][1]);\n      bbox[1][0] = Math.max(pt[0], bbox[1][0]);\n      bbox[1][1] = Math.max(pt[1], bbox[1][1]);\n      var mag = Math.sqrt(vx * vx + vy * vy);\n      maxMag = Math.max(maxMag, mag);\n      minMag = Math.min(minMag, mag);\n    });\n    data.each(['vx', 'vy'], function (vx, vy, i) {\n      var xPix = Math.round((points[i * 2] - bbox[0][0]) / (bbox[1][0] - bbox[0][0]) * (gridWidth - 1));\n      var yPix = gridHeight - 1 - Math.round((points[i * 2 + 1] - bbox[0][1]) / (bbox[1][1] - bbox[0][1]) * (gridHeight - 1));\n      var idx = (yPix * gridWidth + xPix) * 4;\n      pixels[idx] = vx / maxMag * 0.5 + 0.5;\n      pixels[idx + 1] = vy / maxMag * 0.5 + 0.5;\n      pixels[idx + 3] = 1;\n    });\n    vectorFieldTexture.width = gridWidth;\n    vectorFieldTexture.height = gridHeight;\n    if (seriesModel.get('coordinateSystem') === 'bmap') {\n      this._fillEmptyPixels(vectorFieldTexture);\n    }\n    vectorFieldTexture.dirty();\n    this._updatePlanePosition(bbox[0], bbox[1], seriesModel, api);\n    this._updateGradientTexture(data.getVisual('visualMeta'), [minMag, maxMag]);\n  },\n  // PENDING Use grid mesh ? or delaunay triangulation?\n  _fillEmptyPixels: function (texture) {\n    var pixels = texture.pixels;\n    var width = texture.width;\n    var height = texture.height;\n    function fetchPixel(x, y, rg) {\n      x = Math.max(Math.min(x, width - 1), 0);\n      y = Math.max(Math.min(y, height - 1), 0);\n      var idx = (y * (width - 1) + x) * 4;\n      if (pixels[idx + 3] === 0) {\n        return false;\n      }\n      rg[0] = pixels[idx];\n      rg[1] = pixels[idx + 1];\n      return true;\n    }\n    function addPixel(a, b, out) {\n      out[0] = a[0] + b[0];\n      out[1] = a[1] + b[1];\n    }\n    var center = [],\n      left = [],\n      right = [],\n      top = [],\n      bottom = [];\n    var weight = 0;\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var idx = (y * (width - 1) + x) * 4;\n        if (pixels[idx + 3] === 0) {\n          weight = center[0] = center[1] = 0;\n          if (fetchPixel(x - 1, y, left)) {\n            weight++;\n            addPixel(left, center, center);\n          }\n          if (fetchPixel(x + 1, y, right)) {\n            weight++;\n            addPixel(right, center, center);\n          }\n          if (fetchPixel(x, y - 1, top)) {\n            weight++;\n            addPixel(top, center, center);\n          }\n          if (fetchPixel(x, y + 1, bottom)) {\n            weight++;\n            addPixel(bottom, center, center);\n          }\n          center[0] /= weight;\n          center[1] /= weight; // PENDING If overwrite. bilinear interpolation.\n\n          pixels[idx] = center[0];\n          pixels[idx + 1] = center[1];\n        }\n        pixels[idx + 3] = 1;\n      }\n    }\n  },\n  _updateGradientTexture: function (visualMeta, magExtent) {\n    if (!visualMeta || !visualMeta.length) {\n      this._particleSurface.setGradientTexture(null);\n      return;\n    } // TODO Different dimensions\n\n    this._gradientTexture = this._gradientTexture || new graphicGL.Texture2D({\n      image: document.createElement('canvas')\n    });\n    var gradientTexture = this._gradientTexture;\n    var canvas = gradientTexture.image;\n    canvas.width = 200;\n    canvas.height = 1;\n    var ctx = canvas.getContext('2d');\n    var gradient = ctx.createLinearGradient(0, 0.5, canvas.width, 0.5);\n    visualMeta[0].stops.forEach(function (stop) {\n      var offset;\n      if (magExtent[1] === magExtent[0]) {\n        offset = 0;\n      } else {\n        offset = stop.value / magExtent[1];\n        offset = Math.min(Math.max(offset, 0), 1);\n      }\n      gradient.addColorStop(offset, stop.color);\n    });\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    gradientTexture.dirty();\n    this._particleSurface.setGradientTexture(this._gradientTexture);\n  },\n  _updatePlanePosition: function (leftTop, rightBottom, seriesModel, api) {\n    var limitedResult = this._limitInViewportAndFullFill(leftTop, rightBottom, seriesModel, api);\n    leftTop = limitedResult.leftTop;\n    rightBottom = limitedResult.rightBottom;\n    this._particleSurface.setRegion(limitedResult.region);\n    this._planeMesh.position.set((leftTop[0] + rightBottom[0]) / 2, api.getHeight() - (leftTop[1] + rightBottom[1]) / 2, 0);\n    var width = rightBottom[0] - leftTop[0];\n    var height = rightBottom[1] - leftTop[1];\n    this._planeMesh.scale.set(width / 2, height / 2, 1);\n    this._particleSurface.resize(Math.max(Math.min(width, 2048), 1), Math.max(Math.min(height, 2048), 1));\n    if (this._renderer) {\n      this._particleSurface.clearFrame(this._renderer);\n    }\n  },\n  _limitInViewportAndFullFill: function (leftTop, rightBottom, seriesModel, api) {\n    var newLeftTop = [Math.max(leftTop[0], 0), Math.max(leftTop[1], 0)];\n    var newRightBottom = [Math.min(rightBottom[0], api.getWidth()), Math.min(rightBottom[1], api.getHeight())]; // Tiliing in lng orientation.\n\n    if (seriesModel.get('coordinateSystem') === 'bmap') {\n      var lngRange = seriesModel.getData().getDataExtent(seriesModel.coordDimToDataDim('lng')[0]); // PENDING, consider grid density\n\n      var isContinuous = Math.floor(lngRange[1] - lngRange[0]) >= 359;\n      if (isContinuous) {\n        if (newLeftTop[0] > 0) {\n          newLeftTop[0] = 0;\n        }\n        if (newRightBottom[0] < api.getWidth()) {\n          newRightBottom[0] = api.getWidth();\n        }\n      }\n    }\n    var width = rightBottom[0] - leftTop[0];\n    var height = rightBottom[1] - leftTop[1];\n    var newWidth = newRightBottom[0] - newLeftTop[0];\n    var newHeight = newRightBottom[1] - newLeftTop[1];\n    var region = [(newLeftTop[0] - leftTop[0]) / width, 1.0 - newHeight / height - (newLeftTop[1] - leftTop[1]) / height, newWidth / width, newHeight / height];\n    return {\n      leftTop: newLeftTop,\n      rightBottom: newRightBottom,\n      region: region\n    };\n  },\n  _updateCamera: function (width, height, dpr) {\n    this.viewGL.setViewport(0, 0, width, height, dpr);\n    var camera = this.viewGL.camera; // FIXME  bottom can't be larger than top\n\n    camera.left = camera.bottom = 0;\n    camera.top = height;\n    camera.right = width;\n    camera.near = 0;\n    camera.far = 100;\n    camera.position.z = 10;\n  },\n  remove: function () {\n    this._planeMesh.stopAnimation();\n    this.groupGL.removeAll();\n  },\n  dispose: function () {\n    if (this._renderer) {\n      this._particleSurface.dispose(this._renderer);\n    }\n    this.groupGL.removeAll();\n  }\n});","map":{"version":3,"names":["echarts","graphicGL","retrieve","ViewGL","VectorFieldParticleSurface","ChartView","extend","type","__ecgl__","init","ecModel","api","viewGL","groupGL","Node","add","_particleSurface","planeMesh","Mesh","geometry","PlaneGeometry","material","Material","shader","Shader","vertex","source","fragment","transparent","enableTexture","_planeMesh","render","seriesModel","particleSurface","setParticleType","get","setSupersampling","_updateData","_updateCamera","getWidth","getHeight","getDevicePixelRatio","particleDensity","firstNotNull","setParticleDensity","time","Date","self","firstFrame","__percent","stopAnimation","animate","loop","when","during","timeNow","dTime","Math","min","_renderer","update","set","getSurfaceTexture","start","itemStyleModel","getModel","color","parseColor","setColorTextureImage","setParticleSize","particleSpeedScaling","motionBlurFactor","pow","updateTransform","afterRender","globeModel","layerGL","renderer","coordSys","coordinateSystem","dims","dimensions","map","coordDim","coordDimToDataDim","data","getData","xExtent","getDataExtent","yExtent","gridWidth","gridHeight","aspect","round","sqrt","count","ceil","vectorFieldTexture","pixels","length","Float32Array","i","maxMag","minMag","Infinity","points","offset","bbox","each","x","y","vx","vy","pt","dataToPoint","max","mag","xPix","yPix","idx","width","height","_fillEmptyPixels","dirty","_updatePlanePosition","_updateGradientTexture","getVisual","texture","fetchPixel","rg","addPixel","a","b","out","center","left","right","top","bottom","weight","visualMeta","magExtent","setGradientTexture","_gradientTexture","Texture2D","image","document","createElement","gradientTexture","canvas","ctx","getContext","gradient","createLinearGradient","stops","forEach","stop","value","addColorStop","fillStyle","fillRect","leftTop","rightBottom","limitedResult","_limitInViewportAndFullFill","setRegion","region","position","scale","resize","clearFrame","newLeftTop","newRightBottom","lngRange","isContinuous","floor","newWidth","newHeight","dpr","setViewport","camera","near","far","z","remove","removeAll","dispose"],"sources":["E:/QuestionairePlanet_Fronted/mytest/node_modules/echarts-gl/lib/chart/flowGL/FlowGLView.js"],"sourcesContent":["import * as echarts from 'echarts/lib/echarts';\nimport graphicGL from '../../util/graphicGL';\nimport retrieve from '../../util/retrieve';\nimport ViewGL from '../../core/ViewGL';\nimport VectorFieldParticleSurface from './VectorFieldParticleSurface'; // TODO 百度地图不是 linear 的\n\nexport default echarts.ChartView.extend({\n  type: 'flowGL',\n  __ecgl__: true,\n  init: function (ecModel, api) {\n    this.viewGL = new ViewGL('orthographic');\n    this.groupGL = new graphicGL.Node();\n    this.viewGL.add(this.groupGL);\n    this._particleSurface = new VectorFieldParticleSurface();\n    var planeMesh = new graphicGL.Mesh({\n      geometry: new graphicGL.PlaneGeometry(),\n      material: new graphicGL.Material({\n        shader: new graphicGL.Shader({\n          vertex: graphicGL.Shader.source('ecgl.color.vertex'),\n          fragment: graphicGL.Shader.source('ecgl.color.fragment')\n        }),\n        // Must enable blending and multiply alpha.\n        // Or premultipliedAlpha will let the alpha useless.\n        transparent: true\n      })\n    });\n    planeMesh.material.enableTexture('diffuseMap');\n    this.groupGL.add(planeMesh);\n    this._planeMesh = planeMesh;\n  },\n  render: function (seriesModel, ecModel, api) {\n    var particleSurface = this._particleSurface; // Set particleType before set others.\n\n    particleSurface.setParticleType(seriesModel.get('particleType'));\n    particleSurface.setSupersampling(seriesModel.get('supersampling'));\n\n    this._updateData(seriesModel, api);\n\n    this._updateCamera(api.getWidth(), api.getHeight(), api.getDevicePixelRatio());\n\n    var particleDensity = retrieve.firstNotNull(seriesModel.get('particleDensity'), 128);\n    particleSurface.setParticleDensity(particleDensity, particleDensity);\n    var planeMesh = this._planeMesh;\n    var time = +new Date();\n    var self = this;\n    var firstFrame = true;\n    planeMesh.__percent = 0;\n    planeMesh.stopAnimation();\n    planeMesh.animate('', {\n      loop: true\n    }).when(100000, {\n      __percent: 1\n    }).during(function () {\n      var timeNow = +new Date();\n      var dTime = Math.min(timeNow - time, 20);\n      time = time + dTime;\n\n      if (self._renderer) {\n        particleSurface.update(self._renderer, api, dTime / 1000, firstFrame);\n        planeMesh.material.set('diffuseMap', particleSurface.getSurfaceTexture()); // planeMesh.material.set('diffuseMap', self._particleSurface.vectorFieldTexture);\n      }\n\n      firstFrame = false;\n    }).start();\n    var itemStyleModel = seriesModel.getModel('itemStyle');\n    var color = graphicGL.parseColor(itemStyleModel.get('color'));\n    color[3] *= retrieve.firstNotNull(itemStyleModel.get('opacity'), 1);\n    planeMesh.material.set('color', color);\n    particleSurface.setColorTextureImage(seriesModel.get('colorTexture'), api);\n    particleSurface.setParticleSize(seriesModel.get('particleSize'));\n    particleSurface.particleSpeedScaling = seriesModel.get('particleSpeed');\n    particleSurface.motionBlurFactor = 1.0 - Math.pow(0.1, seriesModel.get('particleTrail'));\n  },\n  updateTransform: function (seriesModel, ecModel, api) {\n    this._updateData(seriesModel, api);\n  },\n  afterRender: function (globeModel, ecModel, api, layerGL) {\n    var renderer = layerGL.renderer;\n    this._renderer = renderer;\n  },\n  _updateData: function (seriesModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var dims = coordSys.dimensions.map(function (coordDim) {\n      return seriesModel.coordDimToDataDim(coordDim)[0];\n    });\n    var data = seriesModel.getData();\n    var xExtent = data.getDataExtent(dims[0]);\n    var yExtent = data.getDataExtent(dims[1]);\n    var gridWidth = seriesModel.get('gridWidth');\n    var gridHeight = seriesModel.get('gridHeight');\n\n    if (gridWidth == null || gridWidth === 'auto') {\n      // TODO not accurate.\n      var aspect = (xExtent[1] - xExtent[0]) / (yExtent[1] - yExtent[0]);\n      gridWidth = Math.round(Math.sqrt(aspect * data.count()));\n    }\n\n    if (gridHeight == null || gridHeight === 'auto') {\n      gridHeight = Math.ceil(data.count() / gridWidth);\n    }\n\n    var vectorFieldTexture = this._particleSurface.vectorFieldTexture; // Half Float needs Uint16Array\n\n    var pixels = vectorFieldTexture.pixels;\n\n    if (!pixels || pixels.length !== gridHeight * gridWidth * 4) {\n      pixels = vectorFieldTexture.pixels = new Float32Array(gridWidth * gridHeight * 4);\n    } else {\n      for (var i = 0; i < pixels.length; i++) {\n        pixels[i] = 0;\n      }\n    }\n\n    var maxMag = 0;\n    var minMag = Infinity;\n    var points = new Float32Array(data.count() * 2);\n    var offset = 0;\n    var bbox = [[Infinity, Infinity], [-Infinity, -Infinity]];\n    data.each([dims[0], dims[1], 'vx', 'vy'], function (x, y, vx, vy) {\n      var pt = coordSys.dataToPoint([x, y]);\n      points[offset++] = pt[0];\n      points[offset++] = pt[1];\n      bbox[0][0] = Math.min(pt[0], bbox[0][0]);\n      bbox[0][1] = Math.min(pt[1], bbox[0][1]);\n      bbox[1][0] = Math.max(pt[0], bbox[1][0]);\n      bbox[1][1] = Math.max(pt[1], bbox[1][1]);\n      var mag = Math.sqrt(vx * vx + vy * vy);\n      maxMag = Math.max(maxMag, mag);\n      minMag = Math.min(minMag, mag);\n    });\n    data.each(['vx', 'vy'], function (vx, vy, i) {\n      var xPix = Math.round((points[i * 2] - bbox[0][0]) / (bbox[1][0] - bbox[0][0]) * (gridWidth - 1));\n      var yPix = gridHeight - 1 - Math.round((points[i * 2 + 1] - bbox[0][1]) / (bbox[1][1] - bbox[0][1]) * (gridHeight - 1));\n      var idx = (yPix * gridWidth + xPix) * 4;\n      pixels[idx] = vx / maxMag * 0.5 + 0.5;\n      pixels[idx + 1] = vy / maxMag * 0.5 + 0.5;\n      pixels[idx + 3] = 1;\n    });\n    vectorFieldTexture.width = gridWidth;\n    vectorFieldTexture.height = gridHeight;\n\n    if (seriesModel.get('coordinateSystem') === 'bmap') {\n      this._fillEmptyPixels(vectorFieldTexture);\n    }\n\n    vectorFieldTexture.dirty();\n\n    this._updatePlanePosition(bbox[0], bbox[1], seriesModel, api);\n\n    this._updateGradientTexture(data.getVisual('visualMeta'), [minMag, maxMag]);\n  },\n  // PENDING Use grid mesh ? or delaunay triangulation?\n  _fillEmptyPixels: function (texture) {\n    var pixels = texture.pixels;\n    var width = texture.width;\n    var height = texture.height;\n\n    function fetchPixel(x, y, rg) {\n      x = Math.max(Math.min(x, width - 1), 0);\n      y = Math.max(Math.min(y, height - 1), 0);\n      var idx = (y * (width - 1) + x) * 4;\n\n      if (pixels[idx + 3] === 0) {\n        return false;\n      }\n\n      rg[0] = pixels[idx];\n      rg[1] = pixels[idx + 1];\n      return true;\n    }\n\n    function addPixel(a, b, out) {\n      out[0] = a[0] + b[0];\n      out[1] = a[1] + b[1];\n    }\n\n    var center = [],\n        left = [],\n        right = [],\n        top = [],\n        bottom = [];\n    var weight = 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var idx = (y * (width - 1) + x) * 4;\n\n        if (pixels[idx + 3] === 0) {\n          weight = center[0] = center[1] = 0;\n\n          if (fetchPixel(x - 1, y, left)) {\n            weight++;\n            addPixel(left, center, center);\n          }\n\n          if (fetchPixel(x + 1, y, right)) {\n            weight++;\n            addPixel(right, center, center);\n          }\n\n          if (fetchPixel(x, y - 1, top)) {\n            weight++;\n            addPixel(top, center, center);\n          }\n\n          if (fetchPixel(x, y + 1, bottom)) {\n            weight++;\n            addPixel(bottom, center, center);\n          }\n\n          center[0] /= weight;\n          center[1] /= weight; // PENDING If overwrite. bilinear interpolation.\n\n          pixels[idx] = center[0];\n          pixels[idx + 1] = center[1];\n        }\n\n        pixels[idx + 3] = 1;\n      }\n    }\n  },\n  _updateGradientTexture: function (visualMeta, magExtent) {\n    if (!visualMeta || !visualMeta.length) {\n      this._particleSurface.setGradientTexture(null);\n\n      return;\n    } // TODO Different dimensions\n\n\n    this._gradientTexture = this._gradientTexture || new graphicGL.Texture2D({\n      image: document.createElement('canvas')\n    });\n    var gradientTexture = this._gradientTexture;\n    var canvas = gradientTexture.image;\n    canvas.width = 200;\n    canvas.height = 1;\n    var ctx = canvas.getContext('2d');\n    var gradient = ctx.createLinearGradient(0, 0.5, canvas.width, 0.5);\n    visualMeta[0].stops.forEach(function (stop) {\n      var offset;\n\n      if (magExtent[1] === magExtent[0]) {\n        offset = 0;\n      } else {\n        offset = stop.value / magExtent[1];\n        offset = Math.min(Math.max(offset, 0), 1);\n      }\n\n      gradient.addColorStop(offset, stop.color);\n    });\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    gradientTexture.dirty();\n\n    this._particleSurface.setGradientTexture(this._gradientTexture);\n  },\n  _updatePlanePosition: function (leftTop, rightBottom, seriesModel, api) {\n    var limitedResult = this._limitInViewportAndFullFill(leftTop, rightBottom, seriesModel, api);\n\n    leftTop = limitedResult.leftTop;\n    rightBottom = limitedResult.rightBottom;\n\n    this._particleSurface.setRegion(limitedResult.region);\n\n    this._planeMesh.position.set((leftTop[0] + rightBottom[0]) / 2, api.getHeight() - (leftTop[1] + rightBottom[1]) / 2, 0);\n\n    var width = rightBottom[0] - leftTop[0];\n    var height = rightBottom[1] - leftTop[1];\n\n    this._planeMesh.scale.set(width / 2, height / 2, 1);\n\n    this._particleSurface.resize(Math.max(Math.min(width, 2048), 1), Math.max(Math.min(height, 2048), 1));\n\n    if (this._renderer) {\n      this._particleSurface.clearFrame(this._renderer);\n    }\n  },\n  _limitInViewportAndFullFill: function (leftTop, rightBottom, seriesModel, api) {\n    var newLeftTop = [Math.max(leftTop[0], 0), Math.max(leftTop[1], 0)];\n    var newRightBottom = [Math.min(rightBottom[0], api.getWidth()), Math.min(rightBottom[1], api.getHeight())]; // Tiliing in lng orientation.\n\n    if (seriesModel.get('coordinateSystem') === 'bmap') {\n      var lngRange = seriesModel.getData().getDataExtent(seriesModel.coordDimToDataDim('lng')[0]); // PENDING, consider grid density\n\n      var isContinuous = Math.floor(lngRange[1] - lngRange[0]) >= 359;\n\n      if (isContinuous) {\n        if (newLeftTop[0] > 0) {\n          newLeftTop[0] = 0;\n        }\n\n        if (newRightBottom[0] < api.getWidth()) {\n          newRightBottom[0] = api.getWidth();\n        }\n      }\n    }\n\n    var width = rightBottom[0] - leftTop[0];\n    var height = rightBottom[1] - leftTop[1];\n    var newWidth = newRightBottom[0] - newLeftTop[0];\n    var newHeight = newRightBottom[1] - newLeftTop[1];\n    var region = [(newLeftTop[0] - leftTop[0]) / width, 1.0 - newHeight / height - (newLeftTop[1] - leftTop[1]) / height, newWidth / width, newHeight / height];\n    return {\n      leftTop: newLeftTop,\n      rightBottom: newRightBottom,\n      region: region\n    };\n  },\n  _updateCamera: function (width, height, dpr) {\n    this.viewGL.setViewport(0, 0, width, height, dpr);\n    var camera = this.viewGL.camera; // FIXME  bottom can't be larger than top\n\n    camera.left = camera.bottom = 0;\n    camera.top = height;\n    camera.right = width;\n    camera.near = 0;\n    camera.far = 100;\n    camera.position.z = 10;\n  },\n  remove: function () {\n    this._planeMesh.stopAnimation();\n\n    this.groupGL.removeAll();\n  },\n  dispose: function () {\n    if (this._renderer) {\n      this._particleSurface.dispose(this._renderer);\n    }\n\n    this.groupGL.removeAll();\n  }\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}