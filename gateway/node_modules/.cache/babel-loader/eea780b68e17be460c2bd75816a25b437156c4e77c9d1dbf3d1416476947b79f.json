{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/**\n * Lines geometry\n * Use screen space projected lines lineWidth > MAX_LINE_WIDTH\n * https://mattdesl.svbtle.com/drawing-lines-is-hard\n * @module echarts-gl/util/geometry/LinesGeometry\n * @author Yi Shen(http://github.com/pissang)\n */\nimport Geometry from 'claygl/src/Geometry';\nimport * as echarts from 'echarts/lib/echarts';\nimport dynamicConvertMixin from './dynamicConvertMixin';\nimport glmatrix from 'claygl/src/dep/glmatrix';\nvar vec3 = glmatrix.vec3; // var CURVE_RECURSION_LIMIT = 8;\n// var CURVE_COLLINEAR_EPSILON = 40;\n\nvar sampleLinePoints = [[0, 0], [1, 1]];\n/**\n * @constructor\n * @alias module:echarts-gl/util/geometry/LinesGeometry\n * @extends clay.Geometry\n */\n\nvar LinesGeometry = Geometry.extend(function () {\n  return {\n    segmentScale: 1,\n    dynamic: true,\n    /**\n     * Need to use mesh to expand lines if lineWidth > MAX_LINE_WIDTH\n     */\n    useNativeLine: true,\n    attributes: {\n      position: new Geometry.Attribute('position', 'float', 3, 'POSITION'),\n      positionPrev: new Geometry.Attribute('positionPrev', 'float', 3),\n      positionNext: new Geometry.Attribute('positionNext', 'float', 3),\n      prevPositionPrev: new Geometry.Attribute('prevPositionPrev', 'float', 3),\n      prevPosition: new Geometry.Attribute('prevPosition', 'float', 3),\n      prevPositionNext: new Geometry.Attribute('prevPositionNext', 'float', 3),\n      offset: new Geometry.Attribute('offset', 'float', 1),\n      color: new Geometry.Attribute('color', 'float', 4, 'COLOR')\n    }\n  };\n}, /** @lends module: echarts-gl/util/geometry/LinesGeometry.prototype */\n{\n  /**\n   * Reset offset\n   */\n  resetOffset: function () {\n    this._vertexOffset = 0;\n    this._triangleOffset = 0;\n    this._itemVertexOffsets = [];\n  },\n  /**\n   * @param {number} nVertex\n   */\n  setVertexCount: function (nVertex) {\n    var attributes = this.attributes;\n    if (this.vertexCount !== nVertex) {\n      attributes.position.init(nVertex);\n      attributes.color.init(nVertex);\n      if (!this.useNativeLine) {\n        attributes.positionPrev.init(nVertex);\n        attributes.positionNext.init(nVertex);\n        attributes.offset.init(nVertex);\n      }\n      if (nVertex > 0xffff) {\n        if (this.indices instanceof Uint16Array) {\n          this.indices = new Uint32Array(this.indices);\n        }\n      } else {\n        if (this.indices instanceof Uint32Array) {\n          this.indices = new Uint16Array(this.indices);\n        }\n      }\n    }\n  },\n  /**\n   * @param {number} nTriangle\n   */\n  setTriangleCount: function (nTriangle) {\n    if (this.triangleCount !== nTriangle) {\n      if (nTriangle === 0) {\n        this.indices = null;\n      } else {\n        this.indices = this.vertexCount > 0xffff ? new Uint32Array(nTriangle * 3) : new Uint16Array(nTriangle * 3);\n      }\n    }\n  },\n  _getCubicCurveApproxStep: function (p0, p1, p2, p3) {\n    var len = vec3.dist(p0, p1) + vec3.dist(p2, p1) + vec3.dist(p3, p2);\n    var step = 1 / (len + 1) * this.segmentScale;\n    return step;\n  },\n  /**\n   * Get vertex count of cubic curve\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} p2\n   * @param {Array.<number>} p3\n   * @return number\n   */\n  getCubicCurveVertexCount: function (p0, p1, p2, p3) {\n    var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);\n    var segCount = Math.ceil(1 / step);\n    if (!this.useNativeLine) {\n      return segCount * 2 + 2;\n    } else {\n      return segCount * 2;\n    }\n  },\n  /**\n   * Get face count of cubic curve\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} p2\n   * @param {Array.<number>} p3\n   * @return number\n   */\n  getCubicCurveTriangleCount: function (p0, p1, p2, p3) {\n    var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);\n    var segCount = Math.ceil(1 / step);\n    if (!this.useNativeLine) {\n      return segCount * 2;\n    } else {\n      return 0;\n    }\n  },\n  /**\n   * Get vertex count of line\n   * @return {number}\n   */\n  getLineVertexCount: function () {\n    return this.getPolylineVertexCount(sampleLinePoints);\n  },\n  /**\n   * Get face count of line\n   * @return {number}\n   */\n  getLineTriangleCount: function () {\n    return this.getPolylineTriangleCount(sampleLinePoints);\n  },\n  /**\n   * Get how many vertices will polyline take.\n   * @type {number|Array} points Can be a 1d/2d list of points, or a number of points amount.\n   * @return {number}\n   */\n  getPolylineVertexCount: function (points) {\n    var pointsLen;\n    if (typeof points === 'number') {\n      pointsLen = points;\n    } else {\n      var is2DArray = typeof points[0] !== 'number';\n      pointsLen = is2DArray ? points.length : points.length / 3;\n    }\n    return !this.useNativeLine ? (pointsLen - 1) * 2 + 2 : (pointsLen - 1) * 2;\n  },\n  /**\n   * Get how many triangles will polyline take.\n   * @type {number|Array} points Can be a 1d/2d list of points, or a number of points amount.\n   * @return {number}\n   */\n  getPolylineTriangleCount: function (points) {\n    var pointsLen;\n    if (typeof points === 'number') {\n      pointsLen = points;\n    } else {\n      var is2DArray = typeof points[0] !== 'number';\n      pointsLen = is2DArray ? points.length : points.length / 3;\n    }\n    return !this.useNativeLine ? Math.max(pointsLen - 1, 0) * 2 : 0;\n  },\n  /**\n   * Add a cubic curve\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} p2\n   * @param {Array.<number>} p3\n   * @param {Array.<number>} color\n   * @param {number} [lineWidth=1]\n   */\n  addCubicCurve: function (p0, p1, p2, p3, color, lineWidth) {\n    if (lineWidth == null) {\n      lineWidth = 1;\n    } // incremental interpolation\n    // http://antigrain.com/research/bezier_interpolation/index.html#PAGE_BEZIER_INTERPOLATION\n\n    var x0 = p0[0],\n      y0 = p0[1],\n      z0 = p0[2];\n    var x1 = p1[0],\n      y1 = p1[1],\n      z1 = p1[2];\n    var x2 = p2[0],\n      y2 = p2[1],\n      z2 = p2[2];\n    var x3 = p3[0],\n      y3 = p3[1],\n      z3 = p3[2];\n    var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);\n    var step2 = step * step;\n    var step3 = step2 * step;\n    var pre1 = 3.0 * step;\n    var pre2 = 3.0 * step2;\n    var pre4 = 6.0 * step2;\n    var pre5 = 6.0 * step3;\n    var tmp1x = x0 - x1 * 2.0 + x2;\n    var tmp1y = y0 - y1 * 2.0 + y2;\n    var tmp1z = z0 - z1 * 2.0 + z2;\n    var tmp2x = (x1 - x2) * 3.0 - x0 + x3;\n    var tmp2y = (y1 - y2) * 3.0 - y0 + y3;\n    var tmp2z = (z1 - z2) * 3.0 - z0 + z3;\n    var fx = x0;\n    var fy = y0;\n    var fz = z0;\n    var dfx = (x1 - x0) * pre1 + tmp1x * pre2 + tmp2x * step3;\n    var dfy = (y1 - y0) * pre1 + tmp1y * pre2 + tmp2y * step3;\n    var dfz = (z1 - z0) * pre1 + tmp1z * pre2 + tmp2z * step3;\n    var ddfx = tmp1x * pre4 + tmp2x * pre5;\n    var ddfy = tmp1y * pre4 + tmp2y * pre5;\n    var ddfz = tmp1z * pre4 + tmp2z * pre5;\n    var dddfx = tmp2x * pre5;\n    var dddfy = tmp2y * pre5;\n    var dddfz = tmp2z * pre5;\n    var t = 0;\n    var k = 0;\n    var segCount = Math.ceil(1 / step);\n    var points = new Float32Array((segCount + 1) * 3);\n    var points = [];\n    var offset = 0;\n    for (var k = 0; k < segCount + 1; k++) {\n      points[offset++] = fx;\n      points[offset++] = fy;\n      points[offset++] = fz;\n      fx += dfx;\n      fy += dfy;\n      fz += dfz;\n      dfx += ddfx;\n      dfy += ddfy;\n      dfz += ddfz;\n      ddfx += dddfx;\n      ddfy += dddfy;\n      ddfz += dddfz;\n      t += step;\n      if (t > 1) {\n        fx = dfx > 0 ? Math.min(fx, x3) : Math.max(fx, x3);\n        fy = dfy > 0 ? Math.min(fy, y3) : Math.max(fy, y3);\n        fz = dfz > 0 ? Math.min(fz, z3) : Math.max(fz, z3);\n      }\n    }\n    return this.addPolyline(points, color, lineWidth);\n  },\n  /**\n   * Add a straight line\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} color\n   * @param {number} [lineWidth=1]\n   */\n  addLine: function (p0, p1, color, lineWidth) {\n    return this.addPolyline([p0, p1], color, lineWidth);\n  },\n  /**\n   * Add a straight line\n   * @param {Array.<Array> | Array.<number>} points\n   * @param {Array.<number> | Array.<Array>} color\n   * @param {number} [lineWidth=1]\n   * @param {number} [startOffset=0]\n   * @param {number} [pointsCount] Default to be amount of points in the first argument\n   */\n  addPolyline: function (points, color, lineWidth, startOffset, pointsCount) {\n    if (!points.length) {\n      return;\n    }\n    var is2DArray = typeof points[0] !== 'number';\n    if (pointsCount == null) {\n      pointsCount = is2DArray ? points.length : points.length / 3;\n    }\n    if (pointsCount < 2) {\n      return;\n    }\n    if (startOffset == null) {\n      startOffset = 0;\n    }\n    if (lineWidth == null) {\n      lineWidth = 1;\n    }\n    this._itemVertexOffsets.push(this._vertexOffset);\n    var is2DArray = typeof points[0] !== 'number';\n    var notSharingColor = is2DArray ? typeof color[0] !== 'number' : color.length / 4 === pointsCount;\n    var positionAttr = this.attributes.position;\n    var positionPrevAttr = this.attributes.positionPrev;\n    var positionNextAttr = this.attributes.positionNext;\n    var colorAttr = this.attributes.color;\n    var offsetAttr = this.attributes.offset;\n    var indices = this.indices;\n    var vertexOffset = this._vertexOffset;\n    var point;\n    var pointColor;\n    lineWidth = Math.max(lineWidth, 0.01);\n    for (var k = startOffset; k < pointsCount; k++) {\n      if (is2DArray) {\n        point = points[k];\n        if (notSharingColor) {\n          pointColor = color[k];\n        } else {\n          pointColor = color;\n        }\n      } else {\n        var k3 = k * 3;\n        point = point || [];\n        point[0] = points[k3];\n        point[1] = points[k3 + 1];\n        point[2] = points[k3 + 2];\n        if (notSharingColor) {\n          var k4 = k * 4;\n          pointColor = pointColor || [];\n          pointColor[0] = color[k4];\n          pointColor[1] = color[k4 + 1];\n          pointColor[2] = color[k4 + 2];\n          pointColor[3] = color[k4 + 3];\n        } else {\n          pointColor = color;\n        }\n      }\n      if (!this.useNativeLine) {\n        if (k < pointsCount - 1) {\n          // Set to next two points\n          positionPrevAttr.set(vertexOffset + 2, point);\n          positionPrevAttr.set(vertexOffset + 3, point);\n        }\n        if (k > 0) {\n          // Set to previous two points\n          positionNextAttr.set(vertexOffset - 2, point);\n          positionNextAttr.set(vertexOffset - 1, point);\n        }\n        positionAttr.set(vertexOffset, point);\n        positionAttr.set(vertexOffset + 1, point);\n        colorAttr.set(vertexOffset, pointColor);\n        colorAttr.set(vertexOffset + 1, pointColor);\n        offsetAttr.set(vertexOffset, lineWidth / 2);\n        offsetAttr.set(vertexOffset + 1, -lineWidth / 2);\n        vertexOffset += 2;\n      } else {\n        if (k > 1) {\n          positionAttr.copy(vertexOffset, vertexOffset - 1);\n          colorAttr.copy(vertexOffset, vertexOffset - 1);\n          vertexOffset++;\n        }\n      }\n      if (!this.useNativeLine) {\n        if (k > 0) {\n          var idx3 = this._triangleOffset * 3;\n          var indices = this.indices; // 0-----2\n          // 1-----3\n          // 0->1->2, 1->3->2\n\n          indices[idx3] = vertexOffset - 4;\n          indices[idx3 + 1] = vertexOffset - 3;\n          indices[idx3 + 2] = vertexOffset - 2;\n          indices[idx3 + 3] = vertexOffset - 3;\n          indices[idx3 + 4] = vertexOffset - 1;\n          indices[idx3 + 5] = vertexOffset - 2;\n          this._triangleOffset += 2;\n        }\n      } else {\n        colorAttr.set(vertexOffset, pointColor);\n        positionAttr.set(vertexOffset, point);\n        vertexOffset++;\n      }\n    }\n    if (!this.useNativeLine) {\n      var start = this._vertexOffset;\n      var end = this._vertexOffset + pointsCount * 2;\n      positionPrevAttr.copy(start, start + 2);\n      positionPrevAttr.copy(start + 1, start + 3);\n      positionNextAttr.copy(end - 1, end - 3);\n      positionNextAttr.copy(end - 2, end - 4);\n    }\n    this._vertexOffset = vertexOffset;\n    return this._vertexOffset;\n  },\n  /**\n   * Set color of single line.\n   */\n  setItemColor: function (idx, color) {\n    var startOffset = this._itemVertexOffsets[idx];\n    var endOffset = idx < this._itemVertexOffsets.length - 1 ? this._itemVertexOffsets[idx + 1] : this._vertexOffset;\n    for (var i = startOffset; i < endOffset; i++) {\n      this.attributes.color.set(i, color);\n    }\n    this.dirty('color');\n  },\n  /**\n   * @return {number}\n   */\n  currentTriangleOffset: function () {\n    return this._triangleOffset;\n  },\n  /**\n   * @return {number}\n   */\n  currentVertexOffset: function () {\n    return this._vertexOffset;\n  }\n});\necharts.util.defaults(LinesGeometry.prototype, dynamicConvertMixin);\nexport default LinesGeometry;","map":{"version":3,"names":["Geometry","echarts","dynamicConvertMixin","glmatrix","vec3","sampleLinePoints","LinesGeometry","extend","segmentScale","dynamic","useNativeLine","attributes","position","Attribute","positionPrev","positionNext","prevPositionPrev","prevPosition","prevPositionNext","offset","color","resetOffset","_vertexOffset","_triangleOffset","_itemVertexOffsets","setVertexCount","nVertex","vertexCount","init","indices","Uint16Array","Uint32Array","setTriangleCount","nTriangle","triangleCount","_getCubicCurveApproxStep","p0","p1","p2","p3","len","dist","step","getCubicCurveVertexCount","segCount","Math","ceil","getCubicCurveTriangleCount","getLineVertexCount","getPolylineVertexCount","getLineTriangleCount","getPolylineTriangleCount","points","pointsLen","is2DArray","length","max","addCubicCurve","lineWidth","x0","y0","z0","x1","y1","z1","x2","y2","z2","x3","y3","z3","step2","step3","pre1","pre2","pre4","pre5","tmp1x","tmp1y","tmp1z","tmp2x","tmp2y","tmp2z","fx","fy","fz","dfx","dfy","dfz","ddfx","ddfy","ddfz","dddfx","dddfy","dddfz","t","k","Float32Array","min","addPolyline","addLine","startOffset","pointsCount","push","notSharingColor","positionAttr","positionPrevAttr","positionNextAttr","colorAttr","offsetAttr","vertexOffset","point","pointColor","k3","k4","set","copy","idx3","start","end","setItemColor","idx","endOffset","i","dirty","currentTriangleOffset","currentVertexOffset","util","defaults","prototype"],"sources":["E:/QuestionairePlanet_Fronted/mytest/node_modules/echarts-gl/lib/util/geometry/Lines3D.js"],"sourcesContent":["/**\n * Lines geometry\n * Use screen space projected lines lineWidth > MAX_LINE_WIDTH\n * https://mattdesl.svbtle.com/drawing-lines-is-hard\n * @module echarts-gl/util/geometry/LinesGeometry\n * @author Yi Shen(http://github.com/pissang)\n */\nimport Geometry from 'claygl/src/Geometry';\nimport * as echarts from 'echarts/lib/echarts';\nimport dynamicConvertMixin from './dynamicConvertMixin';\nimport glmatrix from 'claygl/src/dep/glmatrix';\nvar vec3 = glmatrix.vec3; // var CURVE_RECURSION_LIMIT = 8;\n// var CURVE_COLLINEAR_EPSILON = 40;\n\nvar sampleLinePoints = [[0, 0], [1, 1]];\n/**\n * @constructor\n * @alias module:echarts-gl/util/geometry/LinesGeometry\n * @extends clay.Geometry\n */\n\nvar LinesGeometry = Geometry.extend(function () {\n  return {\n    segmentScale: 1,\n    dynamic: true,\n\n    /**\n     * Need to use mesh to expand lines if lineWidth > MAX_LINE_WIDTH\n     */\n    useNativeLine: true,\n    attributes: {\n      position: new Geometry.Attribute('position', 'float', 3, 'POSITION'),\n      positionPrev: new Geometry.Attribute('positionPrev', 'float', 3),\n      positionNext: new Geometry.Attribute('positionNext', 'float', 3),\n      prevPositionPrev: new Geometry.Attribute('prevPositionPrev', 'float', 3),\n      prevPosition: new Geometry.Attribute('prevPosition', 'float', 3),\n      prevPositionNext: new Geometry.Attribute('prevPositionNext', 'float', 3),\n      offset: new Geometry.Attribute('offset', 'float', 1),\n      color: new Geometry.Attribute('color', 'float', 4, 'COLOR')\n    }\n  };\n},\n/** @lends module: echarts-gl/util/geometry/LinesGeometry.prototype */\n{\n  /**\n   * Reset offset\n   */\n  resetOffset: function () {\n    this._vertexOffset = 0;\n    this._triangleOffset = 0;\n    this._itemVertexOffsets = [];\n  },\n\n  /**\n   * @param {number} nVertex\n   */\n  setVertexCount: function (nVertex) {\n    var attributes = this.attributes;\n\n    if (this.vertexCount !== nVertex) {\n      attributes.position.init(nVertex);\n      attributes.color.init(nVertex);\n\n      if (!this.useNativeLine) {\n        attributes.positionPrev.init(nVertex);\n        attributes.positionNext.init(nVertex);\n        attributes.offset.init(nVertex);\n      }\n\n      if (nVertex > 0xffff) {\n        if (this.indices instanceof Uint16Array) {\n          this.indices = new Uint32Array(this.indices);\n        }\n      } else {\n        if (this.indices instanceof Uint32Array) {\n          this.indices = new Uint16Array(this.indices);\n        }\n      }\n    }\n  },\n\n  /**\n   * @param {number} nTriangle\n   */\n  setTriangleCount: function (nTriangle) {\n    if (this.triangleCount !== nTriangle) {\n      if (nTriangle === 0) {\n        this.indices = null;\n      } else {\n        this.indices = this.vertexCount > 0xffff ? new Uint32Array(nTriangle * 3) : new Uint16Array(nTriangle * 3);\n      }\n    }\n  },\n  _getCubicCurveApproxStep: function (p0, p1, p2, p3) {\n    var len = vec3.dist(p0, p1) + vec3.dist(p2, p1) + vec3.dist(p3, p2);\n    var step = 1 / (len + 1) * this.segmentScale;\n    return step;\n  },\n\n  /**\n   * Get vertex count of cubic curve\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} p2\n   * @param {Array.<number>} p3\n   * @return number\n   */\n  getCubicCurveVertexCount: function (p0, p1, p2, p3) {\n    var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);\n\n    var segCount = Math.ceil(1 / step);\n\n    if (!this.useNativeLine) {\n      return segCount * 2 + 2;\n    } else {\n      return segCount * 2;\n    }\n  },\n\n  /**\n   * Get face count of cubic curve\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} p2\n   * @param {Array.<number>} p3\n   * @return number\n   */\n  getCubicCurveTriangleCount: function (p0, p1, p2, p3) {\n    var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);\n\n    var segCount = Math.ceil(1 / step);\n\n    if (!this.useNativeLine) {\n      return segCount * 2;\n    } else {\n      return 0;\n    }\n  },\n\n  /**\n   * Get vertex count of line\n   * @return {number}\n   */\n  getLineVertexCount: function () {\n    return this.getPolylineVertexCount(sampleLinePoints);\n  },\n\n  /**\n   * Get face count of line\n   * @return {number}\n   */\n  getLineTriangleCount: function () {\n    return this.getPolylineTriangleCount(sampleLinePoints);\n  },\n\n  /**\n   * Get how many vertices will polyline take.\n   * @type {number|Array} points Can be a 1d/2d list of points, or a number of points amount.\n   * @return {number}\n   */\n  getPolylineVertexCount: function (points) {\n    var pointsLen;\n\n    if (typeof points === 'number') {\n      pointsLen = points;\n    } else {\n      var is2DArray = typeof points[0] !== 'number';\n      pointsLen = is2DArray ? points.length : points.length / 3;\n    }\n\n    return !this.useNativeLine ? (pointsLen - 1) * 2 + 2 : (pointsLen - 1) * 2;\n  },\n\n  /**\n   * Get how many triangles will polyline take.\n   * @type {number|Array} points Can be a 1d/2d list of points, or a number of points amount.\n   * @return {number}\n   */\n  getPolylineTriangleCount: function (points) {\n    var pointsLen;\n\n    if (typeof points === 'number') {\n      pointsLen = points;\n    } else {\n      var is2DArray = typeof points[0] !== 'number';\n      pointsLen = is2DArray ? points.length : points.length / 3;\n    }\n\n    return !this.useNativeLine ? Math.max(pointsLen - 1, 0) * 2 : 0;\n  },\n\n  /**\n   * Add a cubic curve\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} p2\n   * @param {Array.<number>} p3\n   * @param {Array.<number>} color\n   * @param {number} [lineWidth=1]\n   */\n  addCubicCurve: function (p0, p1, p2, p3, color, lineWidth) {\n    if (lineWidth == null) {\n      lineWidth = 1;\n    } // incremental interpolation\n    // http://antigrain.com/research/bezier_interpolation/index.html#PAGE_BEZIER_INTERPOLATION\n\n\n    var x0 = p0[0],\n        y0 = p0[1],\n        z0 = p0[2];\n    var x1 = p1[0],\n        y1 = p1[1],\n        z1 = p1[2];\n    var x2 = p2[0],\n        y2 = p2[1],\n        z2 = p2[2];\n    var x3 = p3[0],\n        y3 = p3[1],\n        z3 = p3[2];\n\n    var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);\n\n    var step2 = step * step;\n    var step3 = step2 * step;\n    var pre1 = 3.0 * step;\n    var pre2 = 3.0 * step2;\n    var pre4 = 6.0 * step2;\n    var pre5 = 6.0 * step3;\n    var tmp1x = x0 - x1 * 2.0 + x2;\n    var tmp1y = y0 - y1 * 2.0 + y2;\n    var tmp1z = z0 - z1 * 2.0 + z2;\n    var tmp2x = (x1 - x2) * 3.0 - x0 + x3;\n    var tmp2y = (y1 - y2) * 3.0 - y0 + y3;\n    var tmp2z = (z1 - z2) * 3.0 - z0 + z3;\n    var fx = x0;\n    var fy = y0;\n    var fz = z0;\n    var dfx = (x1 - x0) * pre1 + tmp1x * pre2 + tmp2x * step3;\n    var dfy = (y1 - y0) * pre1 + tmp1y * pre2 + tmp2y * step3;\n    var dfz = (z1 - z0) * pre1 + tmp1z * pre2 + tmp2z * step3;\n    var ddfx = tmp1x * pre4 + tmp2x * pre5;\n    var ddfy = tmp1y * pre4 + tmp2y * pre5;\n    var ddfz = tmp1z * pre4 + tmp2z * pre5;\n    var dddfx = tmp2x * pre5;\n    var dddfy = tmp2y * pre5;\n    var dddfz = tmp2z * pre5;\n    var t = 0;\n    var k = 0;\n    var segCount = Math.ceil(1 / step);\n    var points = new Float32Array((segCount + 1) * 3);\n    var points = [];\n    var offset = 0;\n\n    for (var k = 0; k < segCount + 1; k++) {\n      points[offset++] = fx;\n      points[offset++] = fy;\n      points[offset++] = fz;\n      fx += dfx;\n      fy += dfy;\n      fz += dfz;\n      dfx += ddfx;\n      dfy += ddfy;\n      dfz += ddfz;\n      ddfx += dddfx;\n      ddfy += dddfy;\n      ddfz += dddfz;\n      t += step;\n\n      if (t > 1) {\n        fx = dfx > 0 ? Math.min(fx, x3) : Math.max(fx, x3);\n        fy = dfy > 0 ? Math.min(fy, y3) : Math.max(fy, y3);\n        fz = dfz > 0 ? Math.min(fz, z3) : Math.max(fz, z3);\n      }\n    }\n\n    return this.addPolyline(points, color, lineWidth);\n  },\n\n  /**\n   * Add a straight line\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} color\n   * @param {number} [lineWidth=1]\n   */\n  addLine: function (p0, p1, color, lineWidth) {\n    return this.addPolyline([p0, p1], color, lineWidth);\n  },\n\n  /**\n   * Add a straight line\n   * @param {Array.<Array> | Array.<number>} points\n   * @param {Array.<number> | Array.<Array>} color\n   * @param {number} [lineWidth=1]\n   * @param {number} [startOffset=0]\n   * @param {number} [pointsCount] Default to be amount of points in the first argument\n   */\n  addPolyline: function (points, color, lineWidth, startOffset, pointsCount) {\n    if (!points.length) {\n      return;\n    }\n\n    var is2DArray = typeof points[0] !== 'number';\n\n    if (pointsCount == null) {\n      pointsCount = is2DArray ? points.length : points.length / 3;\n    }\n\n    if (pointsCount < 2) {\n      return;\n    }\n\n    if (startOffset == null) {\n      startOffset = 0;\n    }\n\n    if (lineWidth == null) {\n      lineWidth = 1;\n    }\n\n    this._itemVertexOffsets.push(this._vertexOffset);\n\n    var is2DArray = typeof points[0] !== 'number';\n    var notSharingColor = is2DArray ? typeof color[0] !== 'number' : color.length / 4 === pointsCount;\n    var positionAttr = this.attributes.position;\n    var positionPrevAttr = this.attributes.positionPrev;\n    var positionNextAttr = this.attributes.positionNext;\n    var colorAttr = this.attributes.color;\n    var offsetAttr = this.attributes.offset;\n    var indices = this.indices;\n    var vertexOffset = this._vertexOffset;\n    var point;\n    var pointColor;\n    lineWidth = Math.max(lineWidth, 0.01);\n\n    for (var k = startOffset; k < pointsCount; k++) {\n      if (is2DArray) {\n        point = points[k];\n\n        if (notSharingColor) {\n          pointColor = color[k];\n        } else {\n          pointColor = color;\n        }\n      } else {\n        var k3 = k * 3;\n        point = point || [];\n        point[0] = points[k3];\n        point[1] = points[k3 + 1];\n        point[2] = points[k3 + 2];\n\n        if (notSharingColor) {\n          var k4 = k * 4;\n          pointColor = pointColor || [];\n          pointColor[0] = color[k4];\n          pointColor[1] = color[k4 + 1];\n          pointColor[2] = color[k4 + 2];\n          pointColor[3] = color[k4 + 3];\n        } else {\n          pointColor = color;\n        }\n      }\n\n      if (!this.useNativeLine) {\n        if (k < pointsCount - 1) {\n          // Set to next two points\n          positionPrevAttr.set(vertexOffset + 2, point);\n          positionPrevAttr.set(vertexOffset + 3, point);\n        }\n\n        if (k > 0) {\n          // Set to previous two points\n          positionNextAttr.set(vertexOffset - 2, point);\n          positionNextAttr.set(vertexOffset - 1, point);\n        }\n\n        positionAttr.set(vertexOffset, point);\n        positionAttr.set(vertexOffset + 1, point);\n        colorAttr.set(vertexOffset, pointColor);\n        colorAttr.set(vertexOffset + 1, pointColor);\n        offsetAttr.set(vertexOffset, lineWidth / 2);\n        offsetAttr.set(vertexOffset + 1, -lineWidth / 2);\n        vertexOffset += 2;\n      } else {\n        if (k > 1) {\n          positionAttr.copy(vertexOffset, vertexOffset - 1);\n          colorAttr.copy(vertexOffset, vertexOffset - 1);\n          vertexOffset++;\n        }\n      }\n\n      if (!this.useNativeLine) {\n        if (k > 0) {\n          var idx3 = this._triangleOffset * 3;\n          var indices = this.indices; // 0-----2\n          // 1-----3\n          // 0->1->2, 1->3->2\n\n          indices[idx3] = vertexOffset - 4;\n          indices[idx3 + 1] = vertexOffset - 3;\n          indices[idx3 + 2] = vertexOffset - 2;\n          indices[idx3 + 3] = vertexOffset - 3;\n          indices[idx3 + 4] = vertexOffset - 1;\n          indices[idx3 + 5] = vertexOffset - 2;\n          this._triangleOffset += 2;\n        }\n      } else {\n        colorAttr.set(vertexOffset, pointColor);\n        positionAttr.set(vertexOffset, point);\n        vertexOffset++;\n      }\n    }\n\n    if (!this.useNativeLine) {\n      var start = this._vertexOffset;\n      var end = this._vertexOffset + pointsCount * 2;\n      positionPrevAttr.copy(start, start + 2);\n      positionPrevAttr.copy(start + 1, start + 3);\n      positionNextAttr.copy(end - 1, end - 3);\n      positionNextAttr.copy(end - 2, end - 4);\n    }\n\n    this._vertexOffset = vertexOffset;\n    return this._vertexOffset;\n  },\n\n  /**\n   * Set color of single line.\n   */\n  setItemColor: function (idx, color) {\n    var startOffset = this._itemVertexOffsets[idx];\n    var endOffset = idx < this._itemVertexOffsets.length - 1 ? this._itemVertexOffsets[idx + 1] : this._vertexOffset;\n\n    for (var i = startOffset; i < endOffset; i++) {\n      this.attributes.color.set(i, color);\n    }\n\n    this.dirty('color');\n  },\n\n  /**\n   * @return {number}\n   */\n  currentTriangleOffset: function () {\n    return this._triangleOffset;\n  },\n\n  /**\n   * @return {number}\n   */\n  currentVertexOffset: function () {\n    return this._vertexOffset;\n  }\n});\necharts.util.defaults(LinesGeometry.prototype, dynamicConvertMixin);\nexport default LinesGeometry;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}