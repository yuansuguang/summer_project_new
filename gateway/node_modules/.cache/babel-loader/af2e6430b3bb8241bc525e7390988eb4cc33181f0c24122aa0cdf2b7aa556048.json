{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Base from '../core/Base';\nimport Ray from '../math/Ray';\nimport Vector2 from '../math/Vector2';\nimport Vector3 from '../math/Vector3';\nimport Matrix4 from '../math/Matrix4';\nimport Renderable from '../Renderable';\nimport glenum from '../core/glenum';\nimport vec3 from '../glmatrix/vec3';\n\n/**\n * @constructor clay.picking.RayPicking\n * @extends clay.core.Base\n */\nvar RayPicking = Base.extend( /** @lends clay.picking.RayPicking# */{\n  /**\n   * Target scene\n   * @type {clay.Scene}\n   */\n  scene: null,\n  /**\n   * Target camera\n   * @type {clay.Camera}\n   */\n  camera: null,\n  /**\n   * Target renderer\n   * @type {clay.Renderer}\n   */\n  renderer: null\n}, function () {\n  this._ray = new Ray();\n  this._ndc = new Vector2();\n}, /** @lends clay.picking.RayPicking.prototype */\n{\n  /**\n   * Pick the nearest intersection object in the scene\n   * @param  {number} x Mouse position x\n   * @param  {number} y Mouse position y\n   * @param  {boolean} [forcePickAll=false] ignore ignorePicking\n   * @return {clay.picking.RayPicking~Intersection}\n   */\n  pick: function (x, y, forcePickAll) {\n    var out = this.pickAll(x, y, [], forcePickAll);\n    return out[0] || null;\n  },\n  /**\n   * Pick all intersection objects, wich will be sorted from near to far\n   * @param  {number} x Mouse position x\n   * @param  {number} y Mouse position y\n   * @param  {Array} [output]\n   * @param  {boolean} [forcePickAll=false] ignore ignorePicking\n   * @return {Array.<clay.picking.RayPicking~Intersection>}\n   */\n  pickAll: function (x, y, output, forcePickAll) {\n    this.renderer.screenToNDC(x, y, this._ndc);\n    this.camera.castRay(this._ndc, this._ray);\n    output = output || [];\n    this._intersectNode(this.scene, output, forcePickAll || false);\n    output.sort(this._intersectionCompareFunc);\n    return output;\n  },\n  _intersectNode: function (node, out, forcePickAll) {\n    if (node instanceof Renderable && node.isRenderable()) {\n      if ((!node.ignorePicking || forcePickAll) && (\n      // Only triangle mesh support ray picking\n      node.mode === glenum.TRIANGLES && node.geometry.isUseIndices()\n      // Or if geometry has it's own pickByRay, pick, implementation\n      || node.geometry.pickByRay || node.geometry.pick)) {\n        this._intersectRenderable(node, out);\n      }\n    }\n    for (var i = 0; i < node._children.length; i++) {\n      this._intersectNode(node._children[i], out, forcePickAll);\n    }\n  },\n  _intersectRenderable: function () {\n    var v1 = new Vector3();\n    var v2 = new Vector3();\n    var v3 = new Vector3();\n    var ray = new Ray();\n    var worldInverse = new Matrix4();\n    return function (renderable, out) {\n      var isSkinnedMesh = renderable.isSkinnedMesh();\n      ray.copy(this._ray);\n      Matrix4.invert(worldInverse, renderable.worldTransform);\n\n      // Skinned mesh will ignore the world transform.\n      if (!isSkinnedMesh) {\n        ray.applyTransform(worldInverse);\n      }\n      var geometry = renderable.geometry;\n      var bbox = isSkinnedMesh ? renderable.skeleton.boundingBox : geometry.boundingBox;\n      if (bbox && !ray.intersectBoundingBox(bbox)) {\n        return;\n      }\n      // Use user defined picking algorithm\n      if (geometry.pick) {\n        geometry.pick(this._ndc.x, this._ndc.y, this.renderer, this.camera, renderable, out);\n        return;\n      }\n      // Use user defined ray picking algorithm\n      else if (geometry.pickByRay) {\n        geometry.pickByRay(ray, renderable, out);\n        return;\n      }\n      var cullBack = renderable.cullFace === glenum.BACK && renderable.frontFace === glenum.CCW || renderable.cullFace === glenum.FRONT && renderable.frontFace === glenum.CW;\n      var point;\n      var indices = geometry.indices;\n      var positionAttr = geometry.attributes.position;\n      var weightAttr = geometry.attributes.weight;\n      var jointAttr = geometry.attributes.joint;\n      var skinMatricesArray;\n      var skinMatrices = [];\n      // Check if valid.\n      if (!positionAttr || !positionAttr.value || !indices) {\n        return;\n      }\n      if (isSkinnedMesh) {\n        skinMatricesArray = renderable.skeleton.getSubSkinMatrices(renderable.__uid__, renderable.joints);\n        for (var i = 0; i < renderable.joints.length; i++) {\n          skinMatrices[i] = skinMatrices[i] || [];\n          for (var k = 0; k < 16; k++) {\n            skinMatrices[i][k] = skinMatricesArray[i * 16 + k];\n          }\n        }\n        var pos = [];\n        var weight = [];\n        var joint = [];\n        var skinnedPos = [];\n        var tmp = [];\n        var skinnedPositionAttr = geometry.attributes.skinnedPosition;\n        if (!skinnedPositionAttr || !skinnedPositionAttr.value) {\n          geometry.createAttribute('skinnedPosition', 'f', 3);\n          skinnedPositionAttr = geometry.attributes.skinnedPosition;\n          skinnedPositionAttr.init(geometry.vertexCount);\n        }\n        for (var i = 0; i < geometry.vertexCount; i++) {\n          positionAttr.get(i, pos);\n          weightAttr.get(i, weight);\n          jointAttr.get(i, joint);\n          weight[3] = 1 - weight[0] - weight[1] - weight[2];\n          vec3.set(skinnedPos, 0, 0, 0);\n          for (var k = 0; k < 4; k++) {\n            if (joint[k] >= 0 && weight[k] > 1e-4) {\n              vec3.transformMat4(tmp, pos, skinMatrices[joint[k]]);\n              vec3.scaleAndAdd(skinnedPos, skinnedPos, tmp, weight[k]);\n            }\n          }\n          skinnedPositionAttr.set(i, skinnedPos);\n        }\n      }\n      for (var i = 0; i < indices.length; i += 3) {\n        var i1 = indices[i];\n        var i2 = indices[i + 1];\n        var i3 = indices[i + 2];\n        var finalPosAttr = isSkinnedMesh ? geometry.attributes.skinnedPosition : positionAttr;\n        finalPosAttr.get(i1, v1.array);\n        finalPosAttr.get(i2, v2.array);\n        finalPosAttr.get(i3, v3.array);\n        if (cullBack) {\n          point = ray.intersectTriangle(v1, v2, v3, renderable.culling);\n        } else {\n          point = ray.intersectTriangle(v1, v3, v2, renderable.culling);\n        }\n        if (point) {\n          var pointW = new Vector3();\n          if (!isSkinnedMesh) {\n            Vector3.transformMat4(pointW, point, renderable.worldTransform);\n          } else {\n            // TODO point maybe not right.\n            Vector3.copy(pointW, point);\n          }\n          out.push(new RayPicking.Intersection(point, pointW, renderable, [i1, i2, i3], i / 3, Vector3.dist(pointW, this._ray.origin)));\n        }\n      }\n    };\n  }(),\n  _intersectionCompareFunc: function (a, b) {\n    return a.distance - b.distance;\n  }\n});\n\n/**\n * @constructor clay.picking.RayPicking~Intersection\n * @param {clay.Vector3} point\n * @param {clay.Vector3} pointWorld\n * @param {clay.Node} target\n * @param {Array.<number>} triangle\n * @param {number} triangleIndex\n * @param {number} distance\n */\nRayPicking.Intersection = function (point, pointWorld, target, triangle, triangleIndex, distance) {\n  /**\n   * Intersection point in local transform coordinates\n   * @type {clay.Vector3}\n   */\n  this.point = point;\n  /**\n   * Intersection point in world transform coordinates\n   * @type {clay.Vector3}\n   */\n  this.pointWorld = pointWorld;\n  /**\n   * Intersection scene node\n   * @type {clay.Node}\n   */\n  this.target = target;\n  /**\n   * Intersection triangle, which is an array of vertex index\n   * @type {Array.<number>}\n   */\n  this.triangle = triangle;\n  /**\n   * Index of intersection triangle.\n   */\n  this.triangleIndex = triangleIndex;\n  /**\n   * Distance from intersection point to ray origin\n   * @type {number}\n   */\n  this.distance = distance;\n};\nexport default RayPicking;","map":{"version":3,"names":["Base","Ray","Vector2","Vector3","Matrix4","Renderable","glenum","vec3","RayPicking","extend","scene","camera","renderer","_ray","_ndc","pick","x","y","forcePickAll","out","pickAll","output","screenToNDC","castRay","_intersectNode","sort","_intersectionCompareFunc","node","isRenderable","ignorePicking","mode","TRIANGLES","geometry","isUseIndices","pickByRay","_intersectRenderable","i","_children","length","v1","v2","v3","ray","worldInverse","renderable","isSkinnedMesh","copy","invert","worldTransform","applyTransform","bbox","skeleton","boundingBox","intersectBoundingBox","cullBack","cullFace","BACK","frontFace","CCW","FRONT","CW","point","indices","positionAttr","attributes","position","weightAttr","weight","jointAttr","joint","skinMatricesArray","skinMatrices","value","getSubSkinMatrices","__uid__","joints","k","pos","skinnedPos","tmp","skinnedPositionAttr","skinnedPosition","createAttribute","init","vertexCount","get","set","transformMat4","scaleAndAdd","i1","i2","i3","finalPosAttr","array","intersectTriangle","culling","pointW","push","Intersection","dist","origin","a","b","distance","pointWorld","target","triangle","triangleIndex"],"sources":["E:/QuestionairePlanet_Fronted/mytest/node_modules/claygl/src/picking/RayPicking.js"],"sourcesContent":["import Base from '../core/Base';\nimport Ray from '../math/Ray';\nimport Vector2 from '../math/Vector2';\nimport Vector3 from '../math/Vector3';\nimport Matrix4 from '../math/Matrix4';\nimport Renderable from '../Renderable';\nimport glenum from '../core/glenum';\nimport vec3 from '../glmatrix/vec3';\n\n/**\n * @constructor clay.picking.RayPicking\n * @extends clay.core.Base\n */\nvar RayPicking = Base.extend(/** @lends clay.picking.RayPicking# */{\n    /**\n     * Target scene\n     * @type {clay.Scene}\n     */\n    scene: null,\n    /**\n     * Target camera\n     * @type {clay.Camera}\n     */\n    camera: null,\n    /**\n     * Target renderer\n     * @type {clay.Renderer}\n     */\n    renderer: null\n}, function () {\n    this._ray = new Ray();\n    this._ndc = new Vector2();\n},\n/** @lends clay.picking.RayPicking.prototype */\n{\n\n    /**\n     * Pick the nearest intersection object in the scene\n     * @param  {number} x Mouse position x\n     * @param  {number} y Mouse position y\n     * @param  {boolean} [forcePickAll=false] ignore ignorePicking\n     * @return {clay.picking.RayPicking~Intersection}\n     */\n    pick: function (x, y, forcePickAll) {\n        var out = this.pickAll(x, y, [], forcePickAll);\n        return out[0] || null;\n    },\n\n    /**\n     * Pick all intersection objects, wich will be sorted from near to far\n     * @param  {number} x Mouse position x\n     * @param  {number} y Mouse position y\n     * @param  {Array} [output]\n     * @param  {boolean} [forcePickAll=false] ignore ignorePicking\n     * @return {Array.<clay.picking.RayPicking~Intersection>}\n     */\n    pickAll: function (x, y, output, forcePickAll) {\n        this.renderer.screenToNDC(x, y, this._ndc);\n        this.camera.castRay(this._ndc, this._ray);\n\n        output = output || [];\n\n        this._intersectNode(this.scene, output, forcePickAll || false);\n\n        output.sort(this._intersectionCompareFunc);\n\n        return output;\n    },\n\n    _intersectNode: function (node, out, forcePickAll) {\n        if ((node instanceof Renderable) && node.isRenderable()) {\n            if ((!node.ignorePicking || forcePickAll)\n                && (\n                    // Only triangle mesh support ray picking\n                    (node.mode === glenum.TRIANGLES && node.geometry.isUseIndices())\n                    // Or if geometry has it's own pickByRay, pick, implementation\n                    || node.geometry.pickByRay\n                    || node.geometry.pick\n                )\n            ) {\n                this._intersectRenderable(node, out);\n            }\n        }\n        for (var i = 0; i < node._children.length; i++) {\n            this._intersectNode(node._children[i], out, forcePickAll);\n        }\n    },\n\n    _intersectRenderable: (function () {\n\n        var v1 = new Vector3();\n        var v2 = new Vector3();\n        var v3 = new Vector3();\n        var ray = new Ray();\n        var worldInverse = new Matrix4();\n\n        return function (renderable, out) {\n\n            var isSkinnedMesh = renderable.isSkinnedMesh();\n            ray.copy(this._ray);\n            Matrix4.invert(worldInverse, renderable.worldTransform);\n\n            // Skinned mesh will ignore the world transform.\n            if (!isSkinnedMesh) {\n                ray.applyTransform(worldInverse);\n            }\n\n            var geometry = renderable.geometry;\n\n            var bbox = isSkinnedMesh ? renderable.skeleton.boundingBox : geometry.boundingBox;\n\n            if (bbox && !ray.intersectBoundingBox(bbox)) {\n                return;\n            }\n            // Use user defined picking algorithm\n            if (geometry.pick) {\n                geometry.pick(\n                    this._ndc.x, this._ndc.y,\n                    this.renderer,\n                    this.camera,\n                    renderable, out\n                );\n                return;\n            }\n            // Use user defined ray picking algorithm\n            else if (geometry.pickByRay) {\n                geometry.pickByRay(ray, renderable, out);\n                return;\n            }\n\n            var cullBack = (renderable.cullFace === glenum.BACK && renderable.frontFace === glenum.CCW)\n                        || (renderable.cullFace === glenum.FRONT && renderable.frontFace === glenum.CW);\n\n            var point;\n            var indices = geometry.indices;\n            var positionAttr = geometry.attributes.position;\n            var weightAttr = geometry.attributes.weight;\n            var jointAttr = geometry.attributes.joint;\n            var skinMatricesArray;\n            var skinMatrices = [];\n            // Check if valid.\n            if (!positionAttr || !positionAttr.value || !indices) {\n                return;\n            }\n            if (isSkinnedMesh) {\n                skinMatricesArray = renderable.skeleton.getSubSkinMatrices(renderable.__uid__, renderable.joints);\n                for (var i = 0; i < renderable.joints.length; i++) {\n                    skinMatrices[i] = skinMatrices[i] || [];\n                    for (var k = 0; k < 16; k++) {\n                        skinMatrices[i][k] = skinMatricesArray[i * 16 + k];\n                    }\n                }\n                var pos = [];\n                var weight = [];\n                var joint = [];\n                var skinnedPos = [];\n                var tmp = [];\n                var skinnedPositionAttr = geometry.attributes.skinnedPosition;\n                if (!skinnedPositionAttr || !skinnedPositionAttr.value) {\n                    geometry.createAttribute('skinnedPosition', 'f', 3);\n                    skinnedPositionAttr = geometry.attributes.skinnedPosition;\n                    skinnedPositionAttr.init(geometry.vertexCount);\n                }\n                for (var i = 0; i < geometry.vertexCount; i++) {\n                    positionAttr.get(i, pos);\n                    weightAttr.get(i, weight);\n                    jointAttr.get(i, joint);\n                    weight[3] = 1 - weight[0] - weight[1] - weight[2];\n                    vec3.set(skinnedPos, 0, 0, 0);\n                    for (var k = 0; k < 4; k++) {\n                        if (joint[k] >= 0 && weight[k] > 1e-4) {\n                            vec3.transformMat4(tmp, pos, skinMatrices[joint[k]]);\n                            vec3.scaleAndAdd(skinnedPos, skinnedPos, tmp, weight[k]);\n                        }\n                    }\n                    skinnedPositionAttr.set(i, skinnedPos);\n                }\n            }\n\n            for (var i = 0; i < indices.length; i += 3) {\n                var i1 = indices[i];\n                var i2 = indices[i + 1];\n                var i3 = indices[i + 2];\n                var finalPosAttr = isSkinnedMesh\n                    ? geometry.attributes.skinnedPosition\n                    : positionAttr;\n                finalPosAttr.get(i1, v1.array);\n                finalPosAttr.get(i2, v2.array);\n                finalPosAttr.get(i3, v3.array);\n\n                if (cullBack) {\n                    point = ray.intersectTriangle(v1, v2, v3, renderable.culling);\n                }\n                else {\n                    point = ray.intersectTriangle(v1, v3, v2, renderable.culling);\n                }\n                if (point) {\n                    var pointW = new Vector3();\n                    if (!isSkinnedMesh) {\n                        Vector3.transformMat4(pointW, point, renderable.worldTransform);\n                    }\n                    else {\n                        // TODO point maybe not right.\n                        Vector3.copy(pointW, point);\n                    }\n                    out.push(new RayPicking.Intersection(\n                        point, pointW, renderable, [i1, i2, i3], i / 3,\n                        Vector3.dist(pointW, this._ray.origin)\n                    ));\n                }\n            }\n        };\n    })(),\n\n    _intersectionCompareFunc: function (a, b) {\n        return a.distance - b.distance;\n    }\n});\n\n/**\n * @constructor clay.picking.RayPicking~Intersection\n * @param {clay.Vector3} point\n * @param {clay.Vector3} pointWorld\n * @param {clay.Node} target\n * @param {Array.<number>} triangle\n * @param {number} triangleIndex\n * @param {number} distance\n */\nRayPicking.Intersection = function (point, pointWorld, target, triangle, triangleIndex, distance) {\n    /**\n     * Intersection point in local transform coordinates\n     * @type {clay.Vector3}\n     */\n    this.point = point;\n    /**\n     * Intersection point in world transform coordinates\n     * @type {clay.Vector3}\n     */\n    this.pointWorld = pointWorld;\n    /**\n     * Intersection scene node\n     * @type {clay.Node}\n     */\n    this.target = target;\n    /**\n     * Intersection triangle, which is an array of vertex index\n     * @type {Array.<number>}\n     */\n    this.triangle = triangle;\n    /**\n     * Index of intersection triangle.\n     */\n    this.triangleIndex = triangleIndex;\n    /**\n     * Distance from intersection point to ray origin\n     * @type {number}\n     */\n    this.distance = distance;\n};\n\nexport default RayPicking;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}