{"ast":null,"code":"import Base from './core/Base';\nimport Texture from './Texture';\nimport TextureCube from './TextureCube';\nimport glenum from './core/glenum';\nimport Cache from './core/Cache';\nvar KEY_FRAMEBUFFER = 'framebuffer';\nvar KEY_RENDERBUFFER = 'renderbuffer';\nvar KEY_RENDERBUFFER_WIDTH = KEY_RENDERBUFFER + '_width';\nvar KEY_RENDERBUFFER_HEIGHT = KEY_RENDERBUFFER + '_height';\nvar KEY_RENDERBUFFER_ATTACHED = KEY_RENDERBUFFER + '_attached';\nvar KEY_DEPTHTEXTURE_ATTACHED = 'depthtexture_attached';\nvar GL_FRAMEBUFFER = glenum.FRAMEBUFFER;\nvar GL_RENDERBUFFER = glenum.RENDERBUFFER;\nvar GL_DEPTH_ATTACHMENT = glenum.DEPTH_ATTACHMENT;\nvar GL_COLOR_ATTACHMENT0 = glenum.COLOR_ATTACHMENT0;\n/**\n * @constructor clay.FrameBuffer\n * @extends clay.core.Base\n */\nvar FrameBuffer = Base.extend( /** @lends clay.FrameBuffer# */\n{\n  /**\n   * If use depth buffer\n   * @type {boolean}\n   */\n  depthBuffer: true,\n  /**\n   * @type {Object}\n   */\n  viewport: null,\n  _width: 0,\n  _height: 0,\n  _textures: null,\n  _boundRenderer: null\n}, function () {\n  // Use cache\n  this._cache = new Cache();\n  this._textures = {};\n}, /**@lends clay.FrameBuffer.prototype. */\n{\n  /**\n   * Get attached texture width\n   * {number}\n   */\n  // FIXME Can't use before #bind\n  getTextureWidth: function () {\n    return this._width;\n  },\n  /**\n   * Get attached texture height\n   * {number}\n   */\n  getTextureHeight: function () {\n    return this._height;\n  },\n  /**\n   * Bind the framebuffer to given renderer before rendering\n   * @param  {clay.Renderer} renderer\n   */\n  bind: function (renderer) {\n    if (renderer.__currentFrameBuffer) {\n      // Already bound\n      if (renderer.__currentFrameBuffer === this) {\n        return;\n      }\n      console.warn('Renderer already bound with another framebuffer. Unbind it first');\n    }\n    renderer.__currentFrameBuffer = this;\n    var _gl = renderer.gl;\n    _gl.bindFramebuffer(GL_FRAMEBUFFER, this._getFrameBufferGL(renderer));\n    this._boundRenderer = renderer;\n    var cache = this._cache;\n    cache.put('viewport', renderer.viewport);\n    var hasTextureAttached = false;\n    var width;\n    var height;\n    for (var attachment in this._textures) {\n      hasTextureAttached = true;\n      var obj = this._textures[attachment];\n      if (obj) {\n        // TODO Do width, height checking, make sure size are same\n        width = obj.texture.width;\n        height = obj.texture.height;\n        // Attach textures\n        this._doAttach(renderer, obj.texture, attachment, obj.target);\n      }\n    }\n    this._width = width;\n    this._height = height;\n    if (!hasTextureAttached && this.depthBuffer) {\n      console.error('Must attach texture before bind, or renderbuffer may have incorrect width and height.');\n    }\n    if (this.viewport) {\n      renderer.setViewport(this.viewport);\n    } else {\n      renderer.setViewport(0, 0, width, height, 1);\n    }\n    var attachedTextures = cache.get('attached_textures');\n    if (attachedTextures) {\n      for (var attachment in attachedTextures) {\n        if (!this._textures[attachment]) {\n          var target = attachedTextures[attachment];\n          this._doDetach(_gl, attachment, target);\n        }\n      }\n    }\n    if (!cache.get(KEY_DEPTHTEXTURE_ATTACHED) && this.depthBuffer) {\n      // Create a new render buffer\n      if (cache.miss(KEY_RENDERBUFFER)) {\n        cache.put(KEY_RENDERBUFFER, _gl.createRenderbuffer());\n      }\n      var renderbuffer = cache.get(KEY_RENDERBUFFER);\n      if (width !== cache.get(KEY_RENDERBUFFER_WIDTH) || height !== cache.get(KEY_RENDERBUFFER_HEIGHT)) {\n        _gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer);\n        _gl.renderbufferStorage(GL_RENDERBUFFER, _gl.DEPTH_COMPONENT16, width, height);\n        cache.put(KEY_RENDERBUFFER_WIDTH, width);\n        cache.put(KEY_RENDERBUFFER_HEIGHT, height);\n        _gl.bindRenderbuffer(GL_RENDERBUFFER, null);\n      }\n      if (!cache.get(KEY_RENDERBUFFER_ATTACHED)) {\n        _gl.framebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, renderbuffer);\n        cache.put(KEY_RENDERBUFFER_ATTACHED, true);\n      }\n    }\n  },\n  /**\n   * Unbind the frame buffer after rendering\n   * @param  {clay.Renderer} renderer\n   */\n  unbind: function (renderer) {\n    // Remove status record on renderer\n    renderer.__currentFrameBuffer = null;\n    var _gl = renderer.gl;\n    _gl.bindFramebuffer(GL_FRAMEBUFFER, null);\n    this._boundRenderer = null;\n    this._cache.use(renderer.__uid__);\n    var viewport = this._cache.get('viewport');\n    // Reset viewport;\n    if (viewport) {\n      renderer.setViewport(viewport);\n    }\n    this.updateMipmap(renderer);\n  },\n  // Because the data of texture is changed over time,\n  // Here update the mipmaps of texture each time after rendered;\n  updateMipmap: function (renderer) {\n    var _gl = renderer.gl;\n    for (var attachment in this._textures) {\n      var obj = this._textures[attachment];\n      if (obj) {\n        var texture = obj.texture;\n        // FIXME some texture format can't generate mipmap\n        if (!texture.NPOT && texture.useMipmap && texture.minFilter === Texture.LINEAR_MIPMAP_LINEAR) {\n          var target = texture.textureType === 'textureCube' ? glenum.TEXTURE_CUBE_MAP : glenum.TEXTURE_2D;\n          _gl.bindTexture(target, texture.getWebGLTexture(renderer));\n          _gl.generateMipmap(target);\n          _gl.bindTexture(target, null);\n        }\n      }\n    }\n  },\n  // 0x8CD5, 36053, FRAMEBUFFER_COMPLETE\n  // 0x8CD6, 36054, FRAMEBUFFER_INCOMPLETE_ATTACHMENT\n  // 0x8CD7, 36055, FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\n  // 0x8CD9, 36057, FRAMEBUFFER_INCOMPLETE_DIMENSIONS\n  // 0x8CDD, 36061, FRAMEBUFFER_UNSUPPORTED\n  checkStatus: function (_gl) {\n    return _gl.checkFramebufferStatus(GL_FRAMEBUFFER);\n  },\n  _getFrameBufferGL: function (renderer) {\n    var cache = this._cache;\n    cache.use(renderer.__uid__);\n    if (cache.miss(KEY_FRAMEBUFFER)) {\n      cache.put(KEY_FRAMEBUFFER, renderer.gl.createFramebuffer());\n    }\n    return cache.get(KEY_FRAMEBUFFER);\n  },\n  /**\n   * Attach a texture(RTT) to the framebuffer\n   * @param  {clay.Texture} texture\n   * @param  {number} [attachment=gl.COLOR_ATTACHMENT0]\n   * @param  {number} [target=gl.TEXTURE_2D]\n   */\n  attach: function (texture, attachment, target) {\n    if (!texture.width) {\n      throw new Error('The texture attached to color buffer is not a valid.');\n    }\n    // TODO width and height check\n\n    // If the depth_texture extension is enabled, developers\n    // Can attach a depth texture to the depth buffer\n    // http://blog.tojicode.com/2012/07/using-webgldepthtexture.html\n    attachment = attachment || GL_COLOR_ATTACHMENT0;\n    target = target || glenum.TEXTURE_2D;\n    var boundRenderer = this._boundRenderer;\n    var _gl = boundRenderer && boundRenderer.gl;\n    var attachedTextures;\n    if (_gl) {\n      var cache = this._cache;\n      cache.use(boundRenderer.__uid__);\n      attachedTextures = cache.get('attached_textures');\n    }\n\n    // Check if texture attached\n    var previous = this._textures[attachment];\n    if (previous && previous.target === target && previous.texture === texture && attachedTextures && attachedTextures[attachment] != null) {\n      return;\n    }\n    var canAttach = true;\n    if (boundRenderer) {\n      canAttach = this._doAttach(boundRenderer, texture, attachment, target);\n      // Set viewport again incase attached to different size textures.\n      if (!this.viewport) {\n        boundRenderer.setViewport(0, 0, texture.width, texture.height, 1);\n      }\n    }\n    if (canAttach) {\n      this._textures[attachment] = this._textures[attachment] || {};\n      this._textures[attachment].texture = texture;\n      this._textures[attachment].target = target;\n    }\n  },\n  _doAttach: function (renderer, texture, attachment, target) {\n    var _gl = renderer.gl;\n    // Make sure texture is always updated\n    // Because texture width or height may be changed and in this we can't be notified\n    // FIXME awkward;\n    var webglTexture = texture.getWebGLTexture(renderer);\n    // Assume cache has been used.\n    var attachedTextures = this._cache.get('attached_textures');\n    if (attachedTextures && attachedTextures[attachment]) {\n      var obj = attachedTextures[attachment];\n      // Check if texture and target not changed\n      if (obj.texture === texture && obj.target === target) {\n        return;\n      }\n    }\n    attachment = +attachment;\n    var canAttach = true;\n    if (attachment === GL_DEPTH_ATTACHMENT || attachment === glenum.DEPTH_STENCIL_ATTACHMENT) {\n      var extension = renderer.getGLExtension('WEBGL_depth_texture');\n      if (!extension) {\n        console.error('Depth texture is not supported by the browser');\n        canAttach = false;\n      }\n      if (texture.format !== glenum.DEPTH_COMPONENT && texture.format !== glenum.DEPTH_STENCIL) {\n        console.error('The texture attached to depth buffer is not a valid.');\n        canAttach = false;\n      }\n\n      // Dispose render buffer created previous\n      if (canAttach) {\n        var renderbuffer = this._cache.get(KEY_RENDERBUFFER);\n        if (renderbuffer) {\n          _gl.framebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, null);\n          _gl.deleteRenderbuffer(renderbuffer);\n          this._cache.put(KEY_RENDERBUFFER, false);\n        }\n        this._cache.put(KEY_RENDERBUFFER_ATTACHED, false);\n        this._cache.put(KEY_DEPTHTEXTURE_ATTACHED, true);\n      }\n    }\n\n    // Mipmap level can only be 0\n    _gl.framebufferTexture2D(GL_FRAMEBUFFER, attachment, target, webglTexture, 0);\n    if (!attachedTextures) {\n      attachedTextures = {};\n      this._cache.put('attached_textures', attachedTextures);\n    }\n    attachedTextures[attachment] = attachedTextures[attachment] || {};\n    attachedTextures[attachment].texture = texture;\n    attachedTextures[attachment].target = target;\n    return canAttach;\n  },\n  _doDetach: function (_gl, attachment, target) {\n    // Detach a texture from framebuffer\n    // https://github.com/KhronosGroup/WebGL/blob/master/conformance-suites/1.0.0/conformance/framebuffer-test.html#L145\n    _gl.framebufferTexture2D(GL_FRAMEBUFFER, attachment, target, null, 0);\n\n    // Assume cache has been used.\n    var attachedTextures = this._cache.get('attached_textures');\n    if (attachedTextures && attachedTextures[attachment]) {\n      attachedTextures[attachment] = null;\n    }\n    if (attachment === GL_DEPTH_ATTACHMENT || attachment === glenum.DEPTH_STENCIL_ATTACHMENT) {\n      this._cache.put(KEY_DEPTHTEXTURE_ATTACHED, false);\n    }\n  },\n  /**\n   * Detach a texture\n   * @param  {number} [attachment=gl.COLOR_ATTACHMENT0]\n   * @param  {number} [target=gl.TEXTURE_2D]\n   */\n  detach: function (attachment, target) {\n    // TODO depth extension check ?\n    this._textures[attachment] = null;\n    if (this._boundRenderer) {\n      var cache = this._cache;\n      cache.use(this._boundRenderer.__uid__);\n      this._doDetach(this._boundRenderer.gl, attachment, target);\n    }\n  },\n  /**\n   * Dispose\n   * @param  {WebGLRenderingContext} _gl\n   */\n  dispose: function (renderer) {\n    var _gl = renderer.gl;\n    var cache = this._cache;\n    cache.use(renderer.__uid__);\n    var renderBuffer = cache.get(KEY_RENDERBUFFER);\n    if (renderBuffer) {\n      _gl.deleteRenderbuffer(renderBuffer);\n    }\n    var frameBuffer = cache.get(KEY_FRAMEBUFFER);\n    if (frameBuffer) {\n      _gl.deleteFramebuffer(frameBuffer);\n    }\n    cache.deleteContext(renderer.__uid__);\n\n    // Clear cache for reusing\n    this._textures = {};\n  }\n});\nFrameBuffer.DEPTH_ATTACHMENT = GL_DEPTH_ATTACHMENT;\nFrameBuffer.COLOR_ATTACHMENT0 = GL_COLOR_ATTACHMENT0;\nFrameBuffer.STENCIL_ATTACHMENT = glenum.STENCIL_ATTACHMENT;\nFrameBuffer.DEPTH_STENCIL_ATTACHMENT = glenum.DEPTH_STENCIL_ATTACHMENT;\nexport default FrameBuffer;","map":{"version":3,"names":["Base","Texture","TextureCube","glenum","Cache","KEY_FRAMEBUFFER","KEY_RENDERBUFFER","KEY_RENDERBUFFER_WIDTH","KEY_RENDERBUFFER_HEIGHT","KEY_RENDERBUFFER_ATTACHED","KEY_DEPTHTEXTURE_ATTACHED","GL_FRAMEBUFFER","FRAMEBUFFER","GL_RENDERBUFFER","RENDERBUFFER","GL_DEPTH_ATTACHMENT","DEPTH_ATTACHMENT","GL_COLOR_ATTACHMENT0","COLOR_ATTACHMENT0","FrameBuffer","extend","depthBuffer","viewport","_width","_height","_textures","_boundRenderer","_cache","getTextureWidth","getTextureHeight","bind","renderer","__currentFrameBuffer","console","warn","_gl","gl","bindFramebuffer","_getFrameBufferGL","cache","put","hasTextureAttached","width","height","attachment","obj","texture","_doAttach","target","error","setViewport","attachedTextures","get","_doDetach","miss","createRenderbuffer","renderbuffer","bindRenderbuffer","renderbufferStorage","DEPTH_COMPONENT16","framebufferRenderbuffer","unbind","use","__uid__","updateMipmap","NPOT","useMipmap","minFilter","LINEAR_MIPMAP_LINEAR","textureType","TEXTURE_CUBE_MAP","TEXTURE_2D","bindTexture","getWebGLTexture","generateMipmap","checkStatus","checkFramebufferStatus","createFramebuffer","attach","Error","boundRenderer","previous","canAttach","webglTexture","DEPTH_STENCIL_ATTACHMENT","extension","getGLExtension","format","DEPTH_COMPONENT","DEPTH_STENCIL","deleteRenderbuffer","framebufferTexture2D","detach","dispose","renderBuffer","frameBuffer","deleteFramebuffer","deleteContext","STENCIL_ATTACHMENT"],"sources":["E:/mytest/node_modules/claygl/src/FrameBuffer.js"],"sourcesContent":["import Base from './core/Base';\nimport Texture from './Texture';\nimport TextureCube from './TextureCube';\nimport glenum from './core/glenum';\nimport Cache from './core/Cache';\n\nvar KEY_FRAMEBUFFER = 'framebuffer';\nvar KEY_RENDERBUFFER = 'renderbuffer';\nvar KEY_RENDERBUFFER_WIDTH = KEY_RENDERBUFFER + '_width';\nvar KEY_RENDERBUFFER_HEIGHT = KEY_RENDERBUFFER + '_height';\nvar KEY_RENDERBUFFER_ATTACHED = KEY_RENDERBUFFER + '_attached';\nvar KEY_DEPTHTEXTURE_ATTACHED = 'depthtexture_attached';\n\nvar GL_FRAMEBUFFER = glenum.FRAMEBUFFER;\nvar GL_RENDERBUFFER = glenum.RENDERBUFFER;\nvar GL_DEPTH_ATTACHMENT = glenum.DEPTH_ATTACHMENT;\nvar GL_COLOR_ATTACHMENT0 = glenum.COLOR_ATTACHMENT0;\n/**\n * @constructor clay.FrameBuffer\n * @extends clay.core.Base\n */\nvar FrameBuffer = Base.extend(\n/** @lends clay.FrameBuffer# */\n{\n    /**\n     * If use depth buffer\n     * @type {boolean}\n     */\n    depthBuffer: true,\n\n    /**\n     * @type {Object}\n     */\n    viewport: null,\n\n    _width: 0,\n    _height: 0,\n\n    _textures: null,\n\n    _boundRenderer: null,\n}, function () {\n    // Use cache\n    this._cache = new Cache();\n\n    this._textures = {};\n},\n\n/**@lends clay.FrameBuffer.prototype. */\n{\n    /**\n     * Get attached texture width\n     * {number}\n     */\n    // FIXME Can't use before #bind\n    getTextureWidth: function () {\n        return this._width;\n    },\n\n    /**\n     * Get attached texture height\n     * {number}\n     */\n    getTextureHeight: function () {\n        return this._height;\n    },\n\n    /**\n     * Bind the framebuffer to given renderer before rendering\n     * @param  {clay.Renderer} renderer\n     */\n    bind: function (renderer) {\n\n        if (renderer.__currentFrameBuffer) {\n            // Already bound\n            if (renderer.__currentFrameBuffer === this) {\n                return;\n            }\n\n            console.warn('Renderer already bound with another framebuffer. Unbind it first');\n        }\n        renderer.__currentFrameBuffer = this;\n\n        var _gl = renderer.gl;\n\n        _gl.bindFramebuffer(GL_FRAMEBUFFER, this._getFrameBufferGL(renderer));\n        this._boundRenderer = renderer;\n        var cache = this._cache;\n\n        cache.put('viewport', renderer.viewport);\n\n        var hasTextureAttached = false;\n        var width;\n        var height;\n        for (var attachment in this._textures) {\n            hasTextureAttached = true;\n            var obj = this._textures[attachment];\n            if (obj) {\n                // TODO Do width, height checking, make sure size are same\n                width = obj.texture.width;\n                height = obj.texture.height;\n                // Attach textures\n                this._doAttach(renderer, obj.texture, attachment, obj.target);\n            }\n        }\n\n        this._width = width;\n        this._height = height;\n\n        if (!hasTextureAttached && this.depthBuffer) {\n            console.error('Must attach texture before bind, or renderbuffer may have incorrect width and height.')\n        }\n\n        if (this.viewport) {\n            renderer.setViewport(this.viewport);\n        }\n        else {\n            renderer.setViewport(0, 0, width, height, 1);\n        }\n\n        var attachedTextures = cache.get('attached_textures');\n        if (attachedTextures) {\n            for (var attachment in attachedTextures) {\n                if (!this._textures[attachment]) {\n                    var target = attachedTextures[attachment];\n                    this._doDetach(_gl, attachment, target);\n                }\n            }\n        }\n        if (!cache.get(KEY_DEPTHTEXTURE_ATTACHED) && this.depthBuffer) {\n            // Create a new render buffer\n            if (cache.miss(KEY_RENDERBUFFER)) {\n                cache.put(KEY_RENDERBUFFER, _gl.createRenderbuffer());\n            }\n            var renderbuffer = cache.get(KEY_RENDERBUFFER);\n\n            if (width !== cache.get(KEY_RENDERBUFFER_WIDTH)\n                    || height !== cache.get(KEY_RENDERBUFFER_HEIGHT)) {\n                _gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer);\n                _gl.renderbufferStorage(GL_RENDERBUFFER, _gl.DEPTH_COMPONENT16, width, height);\n                cache.put(KEY_RENDERBUFFER_WIDTH, width);\n                cache.put(KEY_RENDERBUFFER_HEIGHT, height);\n                _gl.bindRenderbuffer(GL_RENDERBUFFER, null);\n            }\n            if (!cache.get(KEY_RENDERBUFFER_ATTACHED)) {\n                _gl.framebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, renderbuffer);\n                cache.put(KEY_RENDERBUFFER_ATTACHED, true);\n            }\n        }\n    },\n\n    /**\n     * Unbind the frame buffer after rendering\n     * @param  {clay.Renderer} renderer\n     */\n    unbind: function (renderer) {\n        // Remove status record on renderer\n        renderer.__currentFrameBuffer = null;\n\n        var _gl = renderer.gl;\n\n        _gl.bindFramebuffer(GL_FRAMEBUFFER, null);\n        this._boundRenderer = null;\n\n        this._cache.use(renderer.__uid__);\n        var viewport = this._cache.get('viewport');\n        // Reset viewport;\n        if (viewport) {\n            renderer.setViewport(viewport);\n        }\n\n        this.updateMipmap(renderer);\n    },\n\n    // Because the data of texture is changed over time,\n    // Here update the mipmaps of texture each time after rendered;\n    updateMipmap: function (renderer) {\n        var _gl = renderer.gl;\n        for (var attachment in this._textures) {\n            var obj = this._textures[attachment];\n            if (obj) {\n                var texture = obj.texture;\n                // FIXME some texture format can't generate mipmap\n                if (!texture.NPOT && texture.useMipmap\n                    && texture.minFilter === Texture.LINEAR_MIPMAP_LINEAR) {\n                    var target = texture.textureType === 'textureCube' ? glenum.TEXTURE_CUBE_MAP : glenum.TEXTURE_2D;\n                    _gl.bindTexture(target, texture.getWebGLTexture(renderer));\n                    _gl.generateMipmap(target);\n                    _gl.bindTexture(target, null);\n                }\n            }\n        }\n    },\n\n\n    // 0x8CD5, 36053, FRAMEBUFFER_COMPLETE\n    // 0x8CD6, 36054, FRAMEBUFFER_INCOMPLETE_ATTACHMENT\n    // 0x8CD7, 36055, FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\n    // 0x8CD9, 36057, FRAMEBUFFER_INCOMPLETE_DIMENSIONS\n    // 0x8CDD, 36061, FRAMEBUFFER_UNSUPPORTED\n    checkStatus: function (_gl) {\n        return _gl.checkFramebufferStatus(GL_FRAMEBUFFER);\n    },\n\n    _getFrameBufferGL: function (renderer) {\n        var cache = this._cache;\n        cache.use(renderer.__uid__);\n\n        if (cache.miss(KEY_FRAMEBUFFER)) {\n            cache.put(KEY_FRAMEBUFFER, renderer.gl.createFramebuffer());\n        }\n\n        return cache.get(KEY_FRAMEBUFFER);\n    },\n\n    /**\n     * Attach a texture(RTT) to the framebuffer\n     * @param  {clay.Texture} texture\n     * @param  {number} [attachment=gl.COLOR_ATTACHMENT0]\n     * @param  {number} [target=gl.TEXTURE_2D]\n     */\n    attach: function (texture, attachment, target) {\n\n        if (!texture.width) {\n            throw new Error('The texture attached to color buffer is not a valid.');\n        }\n        // TODO width and height check\n\n        // If the depth_texture extension is enabled, developers\n        // Can attach a depth texture to the depth buffer\n        // http://blog.tojicode.com/2012/07/using-webgldepthtexture.html\n        attachment = attachment || GL_COLOR_ATTACHMENT0;\n        target = target || glenum.TEXTURE_2D;\n\n        var boundRenderer = this._boundRenderer;\n        var _gl = boundRenderer && boundRenderer.gl;\n        var attachedTextures;\n\n        if (_gl) {\n            var cache = this._cache;\n            cache.use(boundRenderer.__uid__);\n            attachedTextures = cache.get('attached_textures');\n        }\n\n        // Check if texture attached\n        var previous = this._textures[attachment];\n        if (previous && previous.target === target\n            && previous.texture === texture\n            && (attachedTextures && attachedTextures[attachment] != null)\n        ) {\n            return;\n        }\n\n        var canAttach = true;\n        if (boundRenderer) {\n            canAttach = this._doAttach(boundRenderer, texture, attachment, target);\n            // Set viewport again incase attached to different size textures.\n            if (!this.viewport) {\n                boundRenderer.setViewport(0, 0, texture.width, texture.height, 1);\n            }\n        }\n\n        if (canAttach) {\n            this._textures[attachment] = this._textures[attachment] || {};\n            this._textures[attachment].texture = texture;\n            this._textures[attachment].target = target;\n        }\n    },\n\n    _doAttach: function (renderer, texture, attachment, target) {\n        var _gl = renderer.gl;\n        // Make sure texture is always updated\n        // Because texture width or height may be changed and in this we can't be notified\n        // FIXME awkward;\n        var webglTexture = texture.getWebGLTexture(renderer);\n        // Assume cache has been used.\n        var attachedTextures = this._cache.get('attached_textures');\n        if (attachedTextures && attachedTextures[attachment]) {\n            var obj = attachedTextures[attachment];\n            // Check if texture and target not changed\n            if (obj.texture === texture && obj.target === target) {\n                return;\n            }\n        }\n        attachment = +attachment;\n\n        var canAttach = true;\n        if (attachment === GL_DEPTH_ATTACHMENT || attachment === glenum.DEPTH_STENCIL_ATTACHMENT) {\n            var extension = renderer.getGLExtension('WEBGL_depth_texture');\n\n            if (!extension) {\n                console.error('Depth texture is not supported by the browser');\n                canAttach = false;\n            }\n            if (texture.format !== glenum.DEPTH_COMPONENT\n                && texture.format !== glenum.DEPTH_STENCIL\n            ) {\n                console.error('The texture attached to depth buffer is not a valid.');\n                canAttach = false;\n            }\n\n            // Dispose render buffer created previous\n            if (canAttach) {\n                var renderbuffer = this._cache.get(KEY_RENDERBUFFER);\n                if (renderbuffer) {\n                    _gl.framebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, null);\n                    _gl.deleteRenderbuffer(renderbuffer);\n                    this._cache.put(KEY_RENDERBUFFER, false);\n                }\n\n                this._cache.put(KEY_RENDERBUFFER_ATTACHED, false);\n                this._cache.put(KEY_DEPTHTEXTURE_ATTACHED, true);\n            }\n        }\n\n        // Mipmap level can only be 0\n        _gl.framebufferTexture2D(GL_FRAMEBUFFER, attachment, target, webglTexture, 0);\n\n        if (!attachedTextures) {\n            attachedTextures = {};\n            this._cache.put('attached_textures', attachedTextures);\n        }\n        attachedTextures[attachment] = attachedTextures[attachment] || {};\n        attachedTextures[attachment].texture = texture;\n        attachedTextures[attachment].target = target;\n\n        return canAttach;\n    },\n\n    _doDetach: function (_gl, attachment, target) {\n        // Detach a texture from framebuffer\n        // https://github.com/KhronosGroup/WebGL/blob/master/conformance-suites/1.0.0/conformance/framebuffer-test.html#L145\n        _gl.framebufferTexture2D(GL_FRAMEBUFFER, attachment, target, null, 0);\n\n        // Assume cache has been used.\n        var attachedTextures = this._cache.get('attached_textures');\n        if (attachedTextures && attachedTextures[attachment]) {\n            attachedTextures[attachment] = null;\n        }\n\n        if (attachment === GL_DEPTH_ATTACHMENT || attachment === glenum.DEPTH_STENCIL_ATTACHMENT) {\n            this._cache.put(KEY_DEPTHTEXTURE_ATTACHED, false);\n        }\n    },\n\n    /**\n     * Detach a texture\n     * @param  {number} [attachment=gl.COLOR_ATTACHMENT0]\n     * @param  {number} [target=gl.TEXTURE_2D]\n     */\n    detach: function (attachment, target) {\n        // TODO depth extension check ?\n        this._textures[attachment] = null;\n        if (this._boundRenderer) {\n            var cache = this._cache;\n            cache.use(this._boundRenderer.__uid__);\n            this._doDetach(this._boundRenderer.gl, attachment, target);\n        }\n    },\n    /**\n     * Dispose\n     * @param  {WebGLRenderingContext} _gl\n     */\n    dispose: function (renderer) {\n\n        var _gl = renderer.gl;\n        var cache = this._cache;\n\n        cache.use(renderer.__uid__);\n\n        var renderBuffer = cache.get(KEY_RENDERBUFFER);\n        if (renderBuffer) {\n            _gl.deleteRenderbuffer(renderBuffer);\n        }\n        var frameBuffer = cache.get(KEY_FRAMEBUFFER);\n        if (frameBuffer) {\n            _gl.deleteFramebuffer(frameBuffer);\n        }\n        cache.deleteContext(renderer.__uid__);\n\n        // Clear cache for reusing\n        this._textures = {};\n\n    }\n});\n\nFrameBuffer.DEPTH_ATTACHMENT = GL_DEPTH_ATTACHMENT;\nFrameBuffer.COLOR_ATTACHMENT0 = GL_COLOR_ATTACHMENT0;\nFrameBuffer.STENCIL_ATTACHMENT = glenum.STENCIL_ATTACHMENT;\nFrameBuffer.DEPTH_STENCIL_ATTACHMENT = glenum.DEPTH_STENCIL_ATTACHMENT;\n\nexport default FrameBuffer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}