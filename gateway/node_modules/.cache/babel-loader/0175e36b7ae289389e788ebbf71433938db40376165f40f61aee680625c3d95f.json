{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport * as echarts from 'echarts/lib/echarts';\nimport componentShadingMixin from '../../component/common/componentShadingMixin';\nimport formatTooltip from '../common/formatTooltip';\nimport createList from '../common/createList';\nvar SurfaceSeries = echarts.SeriesModel.extend({\n  type: 'series.surface',\n  dependencies: ['globe', 'grid3D', 'geo3D'],\n  visualStyleAccessPath: 'itemStyle',\n  formatTooltip: function (dataIndex) {\n    return formatTooltip(this, dataIndex);\n  },\n  getInitialData: function (option, ecModel) {\n    var data = option.data;\n    function validateDimension(dimOpts) {\n      return !(isNaN(dimOpts.min) || isNaN(dimOpts.max) || isNaN(dimOpts.step));\n    }\n    function getPrecision(dimOpts) {\n      var getPrecision = echarts.number.getPrecisionSafe;\n      return Math.max(getPrecision(dimOpts.min), getPrecision(dimOpts.max), getPrecision(dimOpts.step)) + 1;\n    }\n    if (!data) {\n      if (!option.parametric) {\n        // From surface equation\n        var equation = option.equation || {};\n        var xOpts = equation.x || {};\n        var yOpts = equation.y || {};\n        ['x', 'y'].forEach(function (dim) {\n          if (!validateDimension(equation[dim])) {\n            if (process.env.NODE_ENV !== 'production') {\n              console.error('Invalid equation.%s', dim);\n            }\n            return;\n          }\n        });\n        if (typeof equation.z !== 'function') {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error('equation.z needs to be function');\n          }\n          return;\n        }\n        var xCount = Math.floor((xOpts.max + xOpts.step - xOpts.min) / xOpts.step);\n        var yCount = Math.floor((yOpts.max + yOpts.step - yOpts.min) / yOpts.step);\n        data = new Float32Array(xCount * yCount * 3);\n        var xPrecision = getPrecision(xOpts);\n        var yPrecision = getPrecision(yOpts);\n        var off = 0;\n        for (var j = 0; j < yCount; j++) {\n          for (var i = 0; i < xCount; i++) {\n            var x = i * xOpts.step + xOpts.min;\n            var y = j * yOpts.step + yOpts.min;\n            var x2 = echarts.number.round(Math.min(x, xOpts.max), xPrecision);\n            var y2 = echarts.number.round(Math.min(y, yOpts.max), yPrecision);\n            var z = equation.z(x2, y2);\n            data[off++] = x2;\n            data[off++] = y2;\n            data[off++] = z;\n          }\n        }\n      } else {\n        var parametricEquation = option.parametricEquation || {};\n        var uOpts = parametricEquation.u || {};\n        var vOpts = parametricEquation.v || {};\n        ['u', 'v'].forEach(function (dim) {\n          if (!validateDimension(parametricEquation[dim])) {\n            if (process.env.NODE_ENV !== 'production') {\n              console.error('Invalid parametricEquation.%s', dim);\n            }\n            return;\n          }\n        });\n        ['x', 'y', 'z'].forEach(function (dim) {\n          if (typeof parametricEquation[dim] !== 'function') {\n            if (process.env.NODE_ENV !== 'production') {\n              console.error('parametricEquation.%s needs to be function', dim);\n            }\n            return;\n          }\n        });\n        var uCount = Math.floor((uOpts.max + uOpts.step - uOpts.min) / uOpts.step);\n        var vCount = Math.floor((vOpts.max + vOpts.step - vOpts.min) / vOpts.step);\n        data = new Float32Array(uCount * vCount * 5);\n        var uPrecision = getPrecision(uOpts);\n        var vPrecision = getPrecision(vOpts);\n        var off = 0;\n        for (var j = 0; j < vCount; j++) {\n          for (var i = 0; i < uCount; i++) {\n            var u = i * uOpts.step + uOpts.min;\n            var v = j * vOpts.step + vOpts.min;\n            var u2 = echarts.number.round(Math.min(u, uOpts.max), uPrecision);\n            var v2 = echarts.number.round(Math.min(v, vOpts.max), vPrecision);\n            var x = parametricEquation.x(u2, v2);\n            var y = parametricEquation.y(u2, v2);\n            var z = parametricEquation.z(u2, v2);\n            data[off++] = x;\n            data[off++] = y;\n            data[off++] = z;\n            data[off++] = u2;\n            data[off++] = v2;\n          }\n        }\n      }\n    }\n    var dims = ['x', 'y', 'z'];\n    if (option.parametric) {\n      dims.push('u', 'v');\n    } // PENDING getSource?\n\n    var list = createList(this, dims, data);\n    return list;\n  },\n  defaultOption: {\n    coordinateSystem: 'cartesian3D',\n    zlevel: -10,\n    // Cartesian coordinate system\n    grid3DIndex: 0,\n    // Surface needs lambert shading to show the difference\n    shading: 'lambert',\n    // If parametric surface\n    parametric: false,\n    wireframe: {\n      show: true,\n      lineStyle: {\n        color: 'rgba(0,0,0,0.5)',\n        width: 1\n      }\n    },\n    /**\n     * Generate surface data from z = f(x, y) equation\n     */\n    equation: {\n      // [min, max, step]\n      x: {\n        min: -1,\n        max: 1,\n        step: 0.1\n      },\n      y: {\n        min: -1,\n        max: 1,\n        step: 0.1\n      },\n      z: null\n    },\n    parametricEquation: {\n      // [min, max, step]\n      u: {\n        min: -1,\n        max: 1,\n        step: 0.1\n      },\n      v: {\n        min: -1,\n        max: 1,\n        step: 0.1\n      },\n      // [x, y, z] = f(x, y)\n      x: null,\n      y: null,\n      z: null\n    },\n    // Shape of give data\n    // It is an array to specify rows and columns.\n    // For example [30, 30]\n    dataShape: null,\n    itemStyle: {// Color\n    },\n    animationDurationUpdate: 500\n  }\n});\necharts.util.merge(SurfaceSeries.prototype, componentShadingMixin);\nexport default SurfaceSeries;","map":{"version":3,"names":["echarts","componentShadingMixin","formatTooltip","createList","SurfaceSeries","SeriesModel","extend","type","dependencies","visualStyleAccessPath","dataIndex","getInitialData","option","ecModel","data","validateDimension","dimOpts","isNaN","min","max","step","getPrecision","number","getPrecisionSafe","Math","parametric","equation","xOpts","x","yOpts","y","forEach","dim","process","env","NODE_ENV","console","error","z","xCount","floor","yCount","Float32Array","xPrecision","yPrecision","off","j","i","x2","round","y2","parametricEquation","uOpts","u","vOpts","v","uCount","vCount","uPrecision","vPrecision","u2","v2","dims","push","list","defaultOption","coordinateSystem","zlevel","grid3DIndex","shading","wireframe","show","lineStyle","color","width","dataShape","itemStyle","animationDurationUpdate","util","merge","prototype"],"sources":["E:/mytest/node_modules/echarts-gl/lib/chart/surface/SurfaceSeries.js"],"sourcesContent":["import * as echarts from 'echarts/lib/echarts';\nimport componentShadingMixin from '../../component/common/componentShadingMixin';\nimport formatTooltip from '../common/formatTooltip';\nimport createList from '../common/createList';\nvar SurfaceSeries = echarts.SeriesModel.extend({\n  type: 'series.surface',\n  dependencies: ['globe', 'grid3D', 'geo3D'],\n  visualStyleAccessPath: 'itemStyle',\n  formatTooltip: function (dataIndex) {\n    return formatTooltip(this, dataIndex);\n  },\n  getInitialData: function (option, ecModel) {\n    var data = option.data;\n\n    function validateDimension(dimOpts) {\n      return !(isNaN(dimOpts.min) || isNaN(dimOpts.max) || isNaN(dimOpts.step));\n    }\n\n    function getPrecision(dimOpts) {\n      var getPrecision = echarts.number.getPrecisionSafe;\n      return Math.max(getPrecision(dimOpts.min), getPrecision(dimOpts.max), getPrecision(dimOpts.step)) + 1;\n    }\n\n    if (!data) {\n      if (!option.parametric) {\n        // From surface equation\n        var equation = option.equation || {};\n        var xOpts = equation.x || {};\n        var yOpts = equation.y || {};\n        ['x', 'y'].forEach(function (dim) {\n          if (!validateDimension(equation[dim])) {\n            if (process.env.NODE_ENV !== 'production') {\n              console.error('Invalid equation.%s', dim);\n            }\n\n            return;\n          }\n        });\n\n        if (typeof equation.z !== 'function') {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error('equation.z needs to be function');\n          }\n\n          return;\n        }\n\n        var xCount = Math.floor((xOpts.max + xOpts.step - xOpts.min) / xOpts.step);\n        var yCount = Math.floor((yOpts.max + yOpts.step - yOpts.min) / yOpts.step);\n        data = new Float32Array(xCount * yCount * 3);\n        var xPrecision = getPrecision(xOpts);\n        var yPrecision = getPrecision(yOpts);\n        var off = 0;\n\n        for (var j = 0; j < yCount; j++) {\n          for (var i = 0; i < xCount; i++) {\n            var x = i * xOpts.step + xOpts.min;\n            var y = j * yOpts.step + yOpts.min;\n            var x2 = echarts.number.round(Math.min(x, xOpts.max), xPrecision);\n            var y2 = echarts.number.round(Math.min(y, yOpts.max), yPrecision);\n            var z = equation.z(x2, y2);\n            data[off++] = x2;\n            data[off++] = y2;\n            data[off++] = z;\n          }\n        }\n      } else {\n        var parametricEquation = option.parametricEquation || {};\n        var uOpts = parametricEquation.u || {};\n        var vOpts = parametricEquation.v || {};\n        ['u', 'v'].forEach(function (dim) {\n          if (!validateDimension(parametricEquation[dim])) {\n            if (process.env.NODE_ENV !== 'production') {\n              console.error('Invalid parametricEquation.%s', dim);\n            }\n\n            return;\n          }\n        });\n        ['x', 'y', 'z'].forEach(function (dim) {\n          if (typeof parametricEquation[dim] !== 'function') {\n            if (process.env.NODE_ENV !== 'production') {\n              console.error('parametricEquation.%s needs to be function', dim);\n            }\n\n            return;\n          }\n        });\n        var uCount = Math.floor((uOpts.max + uOpts.step - uOpts.min) / uOpts.step);\n        var vCount = Math.floor((vOpts.max + vOpts.step - vOpts.min) / vOpts.step);\n        data = new Float32Array(uCount * vCount * 5);\n        var uPrecision = getPrecision(uOpts);\n        var vPrecision = getPrecision(vOpts);\n        var off = 0;\n\n        for (var j = 0; j < vCount; j++) {\n          for (var i = 0; i < uCount; i++) {\n            var u = i * uOpts.step + uOpts.min;\n            var v = j * vOpts.step + vOpts.min;\n            var u2 = echarts.number.round(Math.min(u, uOpts.max), uPrecision);\n            var v2 = echarts.number.round(Math.min(v, vOpts.max), vPrecision);\n            var x = parametricEquation.x(u2, v2);\n            var y = parametricEquation.y(u2, v2);\n            var z = parametricEquation.z(u2, v2);\n            data[off++] = x;\n            data[off++] = y;\n            data[off++] = z;\n            data[off++] = u2;\n            data[off++] = v2;\n          }\n        }\n      }\n    }\n\n    var dims = ['x', 'y', 'z'];\n\n    if (option.parametric) {\n      dims.push('u', 'v');\n    } // PENDING getSource?\n\n\n    var list = createList(this, dims, data);\n    return list;\n  },\n  defaultOption: {\n    coordinateSystem: 'cartesian3D',\n    zlevel: -10,\n    // Cartesian coordinate system\n    grid3DIndex: 0,\n    // Surface needs lambert shading to show the difference\n    shading: 'lambert',\n    // If parametric surface\n    parametric: false,\n    wireframe: {\n      show: true,\n      lineStyle: {\n        color: 'rgba(0,0,0,0.5)',\n        width: 1\n      }\n    },\n\n    /**\n     * Generate surface data from z = f(x, y) equation\n     */\n    equation: {\n      // [min, max, step]\n      x: {\n        min: -1,\n        max: 1,\n        step: 0.1\n      },\n      y: {\n        min: -1,\n        max: 1,\n        step: 0.1\n      },\n      z: null\n    },\n    parametricEquation: {\n      // [min, max, step]\n      u: {\n        min: -1,\n        max: 1,\n        step: 0.1\n      },\n      v: {\n        min: -1,\n        max: 1,\n        step: 0.1\n      },\n      // [x, y, z] = f(x, y)\n      x: null,\n      y: null,\n      z: null\n    },\n    // Shape of give data\n    // It is an array to specify rows and columns.\n    // For example [30, 30]\n    dataShape: null,\n    itemStyle: {// Color\n    },\n    animationDurationUpdate: 500\n  }\n});\necharts.util.merge(SurfaceSeries.prototype, componentShadingMixin);\nexport default SurfaceSeries;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}