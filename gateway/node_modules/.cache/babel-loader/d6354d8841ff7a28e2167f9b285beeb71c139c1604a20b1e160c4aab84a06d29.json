{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport Base from '../core/Base';\nimport glenum from '../core/glenum';\nimport Vector3 from '../math/Vector3';\nimport BoundingBox from '../math/BoundingBox';\nimport Frustum from '../math/Frustum';\nimport Matrix4 from '../math/Matrix4';\nimport Renderer from '../Renderer';\nimport Shader from '../Shader';\nimport Material from '../Material';\nimport FrameBuffer from '../FrameBuffer';\nimport Texture from '../Texture';\nimport Texture2D from '../Texture2D';\nimport TextureCube from '../TextureCube';\nimport PerspectiveCamera from '../camera/Perspective';\nimport OrthoCamera from '../camera/Orthographic';\nimport Pass from '../compositor/Pass';\nimport TexturePool from '../compositor/TexturePool';\nimport mat4 from '../glmatrix/mat4';\nvar targets = ['px', 'nx', 'py', 'ny', 'pz', 'nz'];\nimport shadowmapEssl from '../shader/source/shadowmap.glsl.js';\nShader['import'](shadowmapEssl);\nfunction getDepthMaterialUniform(renderable, depthMaterial, symbol) {\n  if (symbol === 'alphaMap') {\n    return renderable.material.get('diffuseMap');\n  } else if (symbol === 'alphaCutoff') {\n    if (renderable.material.isDefined('fragment', 'ALPHA_TEST') && renderable.material.get('diffuseMap')) {\n      var alphaCutoff = renderable.material.get('alphaCutoff');\n      return alphaCutoff || 0;\n    }\n    return 0;\n  } else if (symbol === 'uvRepeat') {\n    return renderable.material.get('uvRepeat');\n  } else if (symbol === 'uvOffset') {\n    return renderable.material.get('uvOffset');\n  } else {\n    return depthMaterial.get(symbol);\n  }\n}\nfunction isDepthMaterialChanged(renderable, prevRenderable) {\n  var matA = renderable.material;\n  var matB = prevRenderable.material;\n  return matA.get('diffuseMap') !== matB.get('diffuseMap') || (matA.get('alphaCutoff') || 0) !== (matB.get('alphaCutoff') || 0);\n}\n\n/**\n * Pass rendering shadow map.\n *\n * @constructor clay.prePass.ShadowMap\n * @extends clay.core.Base\n * @example\n *     var shadowMapPass = new clay.prePass.ShadowMap({\n *         softShadow: clay.prePass.ShadowMap.VSM\n *     });\n *     ...\n *     animation.on('frame', function (frameTime) {\n *         shadowMapPass.render(renderer, scene, camera);\n *         renderer.render(scene, camera);\n *     });\n */\nvar ShadowMapPass = Base.extend(function () {\n  return /** @lends clay.prePass.ShadowMap# */{\n    /**\n     * Soft shadow technique.\n     * Can be {@link clay.prePass.ShadowMap.PCF} or {@link clay.prePass.ShadowMap.VSM}\n     * @type {number}\n     */\n    softShadow: ShadowMapPass.PCF,\n    /**\n     * Soft shadow blur size\n     * @type {number}\n     */\n    shadowBlur: 1.0,\n    lightFrustumBias: 'auto',\n    kernelPCF: new Float32Array([1, 0, 1, 1, -1, 1, 0, 1, -1, 0, -1, -1, 1, -1, 0, -1]),\n    precision: 'highp',\n    _lastRenderNotCastShadow: false,\n    _frameBuffer: new FrameBuffer(),\n    _textures: {},\n    _shadowMapNumber: {\n      'POINT_LIGHT': 0,\n      'DIRECTIONAL_LIGHT': 0,\n      'SPOT_LIGHT': 0\n    },\n    _depthMaterials: {},\n    _distanceMaterials: {},\n    _receivers: [],\n    _lightsCastShadow: [],\n    _lightCameras: {},\n    _lightMaterials: {},\n    _texturePool: new TexturePool()\n  };\n}, function () {\n  // Gaussian filter pass for VSM\n  this._gaussianPassH = new Pass({\n    fragment: Shader.source('clay.compositor.gaussian_blur')\n  });\n  this._gaussianPassV = new Pass({\n    fragment: Shader.source('clay.compositor.gaussian_blur')\n  });\n  this._gaussianPassH.setUniform('blurSize', this.shadowBlur);\n  this._gaussianPassH.setUniform('blurDir', 0.0);\n  this._gaussianPassV.setUniform('blurSize', this.shadowBlur);\n  this._gaussianPassV.setUniform('blurDir', 1.0);\n  this._outputDepthPass = new Pass({\n    fragment: Shader.source('clay.sm.debug_depth')\n  });\n}, {\n  /**\n   * Render scene to shadow textures\n   * @param  {clay.Renderer} renderer\n   * @param  {clay.Scene} scene\n   * @param  {clay.Camera} sceneCamera\n   * @param  {boolean} [notUpdateScene=false]\n   * @memberOf clay.prePass.ShadowMap.prototype\n   */\n  render: function (renderer, scene, sceneCamera, notUpdateScene) {\n    if (!sceneCamera) {\n      sceneCamera = scene.getMainCamera();\n    }\n    this.trigger('beforerender', this, renderer, scene, sceneCamera);\n    this._renderShadowPass(renderer, scene, sceneCamera, notUpdateScene);\n    this.trigger('afterrender', this, renderer, scene, sceneCamera);\n  },\n  /**\n   * Debug rendering of shadow textures\n   * @param  {clay.Renderer} renderer\n   * @param  {number} size\n   * @memberOf clay.prePass.ShadowMap.prototype\n   */\n  renderDebug: function (renderer, size) {\n    renderer.saveClear();\n    var viewport = renderer.viewport;\n    var x = 0,\n      y = 0;\n    var width = size || viewport.width / 4;\n    var height = width;\n    if (this.softShadow === ShadowMapPass.VSM) {\n      this._outputDepthPass.material.define('fragment', 'USE_VSM');\n    } else {\n      this._outputDepthPass.material.undefine('fragment', 'USE_VSM');\n    }\n    for (var name in this._textures) {\n      var texture = this._textures[name];\n      renderer.setViewport(x, y, width * texture.width / texture.height, height);\n      this._outputDepthPass.setUniform('depthMap', texture);\n      this._outputDepthPass.render(renderer);\n      x += width * texture.width / texture.height;\n    }\n    renderer.setViewport(viewport);\n    renderer.restoreClear();\n  },\n  _updateReceivers: function (renderer, mesh) {\n    if (mesh.receiveShadow) {\n      this._receivers.push(mesh);\n      mesh.material.set('shadowEnabled', 1);\n      mesh.material.set('pcfKernel', this.kernelPCF);\n    } else {\n      mesh.material.set('shadowEnabled', 0);\n    }\n    if (this.softShadow === ShadowMapPass.VSM) {\n      mesh.material.define('fragment', 'USE_VSM');\n      mesh.material.undefine('fragment', 'PCF_KERNEL_SIZE');\n    } else {\n      mesh.material.undefine('fragment', 'USE_VSM');\n      var kernelPCF = this.kernelPCF;\n      if (kernelPCF && kernelPCF.length) {\n        mesh.material.define('fragment', 'PCF_KERNEL_SIZE', kernelPCF.length / 2);\n      } else {\n        mesh.material.undefine('fragment', 'PCF_KERNEL_SIZE');\n      }\n    }\n  },\n  _update: function (renderer, scene) {\n    var self = this;\n    scene.traverse(function (renderable) {\n      if (renderable.isRenderable()) {\n        self._updateReceivers(renderer, renderable);\n      }\n    });\n    for (var i = 0; i < scene.lights.length; i++) {\n      var light = scene.lights[i];\n      if (light.castShadow && !light.invisible) {\n        this._lightsCastShadow.push(light);\n      }\n    }\n  },\n  _renderShadowPass: function (renderer, scene, sceneCamera, notUpdateScene) {\n    // reset\n    for (var name in this._shadowMapNumber) {\n      this._shadowMapNumber[name] = 0;\n    }\n    this._lightsCastShadow.length = 0;\n    this._receivers.length = 0;\n    var _gl = renderer.gl;\n    if (!notUpdateScene) {\n      scene.update();\n    }\n    if (sceneCamera) {\n      sceneCamera.update();\n    }\n    scene.updateLights();\n    this._update(renderer, scene);\n\n    // Needs to update the receivers again if shadows come from 1 to 0.\n    if (!this._lightsCastShadow.length && this._lastRenderNotCastShadow) {\n      return;\n    }\n    this._lastRenderNotCastShadow = this._lightsCastShadow === 0;\n    _gl.enable(_gl.DEPTH_TEST);\n    _gl.depthMask(true);\n    _gl.disable(_gl.BLEND);\n\n    // Clear with high-z, so the part not rendered will not been shadowed\n    // TODO\n    // TODO restore\n    _gl.clearColor(1.0, 1.0, 1.0, 1.0);\n\n    // Shadow uniforms\n    var spotLightShadowMaps = [];\n    var spotLightMatrices = [];\n    var directionalLightShadowMaps = [];\n    var directionalLightMatrices = [];\n    var shadowCascadeClips = [];\n    var pointLightShadowMaps = [];\n    var dirLightHasCascade;\n    // Create textures for shadow map\n    for (var i = 0; i < this._lightsCastShadow.length; i++) {\n      var light = this._lightsCastShadow[i];\n      if (light.type === 'DIRECTIONAL_LIGHT') {\n        if (dirLightHasCascade) {\n          console.warn('Only one direectional light supported with shadow cascade');\n          continue;\n        }\n        if (light.shadowCascade > 4) {\n          console.warn('Support at most 4 cascade');\n          continue;\n        }\n        if (light.shadowCascade > 1) {\n          dirLightHasCascade = light;\n        }\n        this.renderDirectionalLightShadow(renderer, scene, sceneCamera, light, shadowCascadeClips, directionalLightMatrices, directionalLightShadowMaps);\n      } else if (light.type === 'SPOT_LIGHT') {\n        this.renderSpotLightShadow(renderer, scene, light, spotLightMatrices, spotLightShadowMaps);\n      } else if (light.type === 'POINT_LIGHT') {\n        this.renderPointLightShadow(renderer, scene, light, pointLightShadowMaps);\n      }\n      this._shadowMapNumber[light.type]++;\n    }\n    for (var lightType in this._shadowMapNumber) {\n      var number = this._shadowMapNumber[lightType];\n      var key = lightType + '_SHADOWMAP_COUNT';\n      for (var i = 0; i < this._receivers.length; i++) {\n        var mesh = this._receivers[i];\n        var material = mesh.material;\n        if (material.fragmentDefines[key] !== number) {\n          if (number > 0) {\n            material.define('fragment', key, number);\n          } else if (material.isDefined('fragment', key)) {\n            material.undefine('fragment', key);\n          }\n        }\n      }\n    }\n    for (var i = 0; i < this._receivers.length; i++) {\n      var mesh = this._receivers[i];\n      var material = mesh.material;\n      if (dirLightHasCascade) {\n        material.define('fragment', 'SHADOW_CASCADE', dirLightHasCascade.shadowCascade);\n      } else {\n        material.undefine('fragment', 'SHADOW_CASCADE');\n      }\n    }\n    var shadowUniforms = scene.shadowUniforms;\n    function getSize(texture) {\n      return texture.height;\n    }\n    if (directionalLightShadowMaps.length > 0) {\n      var directionalLightShadowMapSizes = directionalLightShadowMaps.map(getSize);\n      shadowUniforms.directionalLightShadowMaps = {\n        value: directionalLightShadowMaps,\n        type: 'tv'\n      };\n      shadowUniforms.directionalLightMatrices = {\n        value: directionalLightMatrices,\n        type: 'm4v'\n      };\n      shadowUniforms.directionalLightShadowMapSizes = {\n        value: directionalLightShadowMapSizes,\n        type: '1fv'\n      };\n      if (dirLightHasCascade) {\n        var shadowCascadeClipsNear = shadowCascadeClips.slice();\n        var shadowCascadeClipsFar = shadowCascadeClips.slice();\n        shadowCascadeClipsNear.pop();\n        shadowCascadeClipsFar.shift();\n\n        // Iterate from far to near\n        shadowCascadeClipsNear.reverse();\n        shadowCascadeClipsFar.reverse();\n        // directionalLightShadowMaps.reverse();\n        directionalLightMatrices.reverse();\n        shadowUniforms.shadowCascadeClipsNear = {\n          value: shadowCascadeClipsNear,\n          type: '1fv'\n        };\n        shadowUniforms.shadowCascadeClipsFar = {\n          value: shadowCascadeClipsFar,\n          type: '1fv'\n        };\n      }\n    }\n    if (spotLightShadowMaps.length > 0) {\n      var spotLightShadowMapSizes = spotLightShadowMaps.map(getSize);\n      var shadowUniforms = scene.shadowUniforms;\n      shadowUniforms.spotLightShadowMaps = {\n        value: spotLightShadowMaps,\n        type: 'tv'\n      };\n      shadowUniforms.spotLightMatrices = {\n        value: spotLightMatrices,\n        type: 'm4v'\n      };\n      shadowUniforms.spotLightShadowMapSizes = {\n        value: spotLightShadowMapSizes,\n        type: '1fv'\n      };\n    }\n    if (pointLightShadowMaps.length > 0) {\n      shadowUniforms.pointLightShadowMaps = {\n        value: pointLightShadowMaps,\n        type: 'tv'\n      };\n    }\n  },\n  renderDirectionalLightShadow: function () {\n    var splitFrustum = new Frustum();\n    var splitProjMatrix = new Matrix4();\n    var cropBBox = new BoundingBox();\n    var cropMatrix = new Matrix4();\n    var lightViewMatrix = new Matrix4();\n    var lightViewProjMatrix = new Matrix4();\n    var lightProjMatrix = new Matrix4();\n    return function (renderer, scene, sceneCamera, light, shadowCascadeClips, directionalLightMatrices, directionalLightShadowMaps) {\n      var defaultShadowMaterial = this._getDepthMaterial(light);\n      var passConfig = {\n        getMaterial: function (renderable) {\n          return renderable.shadowDepthMaterial || defaultShadowMaterial;\n        },\n        isMaterialChanged: isDepthMaterialChanged,\n        getUniform: getDepthMaterialUniform,\n        ifRender: function (renderable) {\n          return renderable.castShadow;\n        },\n        sortCompare: Renderer.opaqueSortCompare\n      };\n\n      // First frame\n      if (!scene.viewBoundingBoxLastFrame.isFinite()) {\n        var boundingBox = scene.getBoundingBox();\n        scene.viewBoundingBoxLastFrame.copy(boundingBox).applyTransform(sceneCamera.viewMatrix);\n      }\n      // Considering moving speed since the bounding box is from last frame\n      // TODO: add a bias\n      var clippedFar = Math.min(-scene.viewBoundingBoxLastFrame.min.z, sceneCamera.far);\n      var clippedNear = Math.max(-scene.viewBoundingBoxLastFrame.max.z, sceneCamera.near);\n      var lightCamera = this._getDirectionalLightCamera(light, scene, sceneCamera);\n      var lvpMat4Arr = lightViewProjMatrix.array;\n      lightProjMatrix.copy(lightCamera.projectionMatrix);\n      mat4.invert(lightViewMatrix.array, lightCamera.worldTransform.array);\n      mat4.multiply(lightViewMatrix.array, lightViewMatrix.array, sceneCamera.worldTransform.array);\n      mat4.multiply(lvpMat4Arr, lightProjMatrix.array, lightViewMatrix.array);\n      var clipPlanes = [];\n      var isPerspective = sceneCamera instanceof PerspectiveCamera;\n      var scaleZ = (sceneCamera.near + sceneCamera.far) / (sceneCamera.near - sceneCamera.far);\n      var offsetZ = 2 * sceneCamera.near * sceneCamera.far / (sceneCamera.near - sceneCamera.far);\n      for (var i = 0; i <= light.shadowCascade; i++) {\n        var clog = clippedNear * Math.pow(clippedFar / clippedNear, i / light.shadowCascade);\n        var cuni = clippedNear + (clippedFar - clippedNear) * i / light.shadowCascade;\n        var c = clog * light.cascadeSplitLogFactor + cuni * (1 - light.cascadeSplitLogFactor);\n        clipPlanes.push(c);\n        shadowCascadeClips.push(-(-c * scaleZ + offsetZ) / -c);\n      }\n      var texture = this._getTexture(light, light.shadowCascade);\n      directionalLightShadowMaps.push(texture);\n      var viewport = renderer.viewport;\n      var _gl = renderer.gl;\n      this._frameBuffer.attach(texture);\n      this._frameBuffer.bind(renderer);\n      _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);\n      for (var i = 0; i < light.shadowCascade; i++) {\n        // Get the splitted frustum\n        var nearPlane = clipPlanes[i];\n        var farPlane = clipPlanes[i + 1];\n        if (isPerspective) {\n          mat4.perspective(splitProjMatrix.array, sceneCamera.fov / 180 * Math.PI, sceneCamera.aspect, nearPlane, farPlane);\n        } else {\n          mat4.ortho(splitProjMatrix.array, sceneCamera.left, sceneCamera.right, sceneCamera.bottom, sceneCamera.top, nearPlane, farPlane);\n        }\n        splitFrustum.setFromProjection(splitProjMatrix);\n        splitFrustum.getTransformedBoundingBox(cropBBox, lightViewMatrix);\n        cropBBox.applyProjection(lightProjMatrix);\n        var _min = cropBBox.min.array;\n        var _max = cropBBox.max.array;\n        _min[0] = Math.max(_min[0], -1);\n        _min[1] = Math.max(_min[1], -1);\n        _max[0] = Math.min(_max[0], 1);\n        _max[1] = Math.min(_max[1], 1);\n        cropMatrix.ortho(_min[0], _max[0], _min[1], _max[1], 1, -1);\n        lightCamera.projectionMatrix.multiplyLeft(cropMatrix);\n        var shadowSize = light.shadowResolution || 512;\n\n        // Reversed, left to right => far to near\n        renderer.setViewport((light.shadowCascade - i - 1) * shadowSize, 0, shadowSize, shadowSize, 1);\n        var renderList = scene.updateRenderList(lightCamera);\n        renderer.renderPass(renderList.opaque, lightCamera, passConfig);\n\n        // Filter for VSM\n        if (this.softShadow === ShadowMapPass.VSM) {\n          this._gaussianFilter(renderer, texture, texture.width);\n        }\n        var matrix = new Matrix4();\n        matrix.copy(lightCamera.viewMatrix).multiplyLeft(lightCamera.projectionMatrix);\n        directionalLightMatrices.push(matrix.array);\n        lightCamera.projectionMatrix.copy(lightProjMatrix);\n      }\n      this._frameBuffer.unbind(renderer);\n      renderer.setViewport(viewport);\n    };\n  }(),\n  renderSpotLightShadow: function (renderer, scene, light, spotLightMatrices, spotLightShadowMaps) {\n    var texture = this._getTexture(light);\n    var lightCamera = this._getSpotLightCamera(light);\n    var _gl = renderer.gl;\n    this._frameBuffer.attach(texture);\n    this._frameBuffer.bind(renderer);\n    _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);\n    var defaultShadowMaterial = this._getDepthMaterial(light);\n    var passConfig = {\n      getMaterial: function (renderable) {\n        return renderable.shadowDepthMaterial || defaultShadowMaterial;\n      },\n      isMaterialChanged: isDepthMaterialChanged,\n      getUniform: getDepthMaterialUniform,\n      ifRender: function (renderable) {\n        return renderable.castShadow;\n      },\n      sortCompare: Renderer.opaqueSortCompare\n    };\n    var renderList = scene.updateRenderList(lightCamera);\n    renderer.renderPass(renderList.opaque, lightCamera, passConfig);\n    this._frameBuffer.unbind(renderer);\n\n    // Filter for VSM\n    if (this.softShadow === ShadowMapPass.VSM) {\n      this._gaussianFilter(renderer, texture, texture.width);\n    }\n    var matrix = new Matrix4();\n    matrix.copy(lightCamera.worldTransform).invert().multiplyLeft(lightCamera.projectionMatrix);\n    spotLightShadowMaps.push(texture);\n    spotLightMatrices.push(matrix.array);\n  },\n  renderPointLightShadow: function (renderer, scene, light, pointLightShadowMaps) {\n    var texture = this._getTexture(light);\n    var _gl = renderer.gl;\n    pointLightShadowMaps.push(texture);\n    var defaultShadowMaterial = this._getDepthMaterial(light);\n    var passConfig = {\n      getMaterial: function (renderable) {\n        return renderable.shadowDepthMaterial || defaultShadowMaterial;\n      },\n      getUniform: getDepthMaterialUniform,\n      sortCompare: Renderer.opaqueSortCompare\n    };\n    var renderListEachSide = {\n      px: [],\n      py: [],\n      pz: [],\n      nx: [],\n      ny: [],\n      nz: []\n    };\n    var bbox = new BoundingBox();\n    var lightWorldPosition = light.getWorldPosition().array;\n    var lightBBox = new BoundingBox();\n    var range = light.range;\n    lightBBox.min.setArray(lightWorldPosition);\n    lightBBox.max.setArray(lightWorldPosition);\n    var extent = new Vector3(range, range, range);\n    lightBBox.max.add(extent);\n    lightBBox.min.sub(extent);\n    var targetsNeedRender = {\n      px: false,\n      py: false,\n      pz: false,\n      nx: false,\n      ny: false,\n      nz: false\n    };\n    scene.traverse(function (renderable) {\n      if (renderable.isRenderable() && renderable.castShadow) {\n        var geometry = renderable.geometry;\n        if (!geometry.boundingBox) {\n          for (var i = 0; i < targets.length; i++) {\n            renderListEachSide[targets[i]].push(renderable);\n          }\n          return;\n        }\n        bbox.transformFrom(geometry.boundingBox, renderable.worldTransform);\n        if (!bbox.intersectBoundingBox(lightBBox)) {\n          return;\n        }\n        bbox.updateVertices();\n        for (var i = 0; i < targets.length; i++) {\n          targetsNeedRender[targets[i]] = false;\n        }\n        for (var i = 0; i < 8; i++) {\n          var vtx = bbox.vertices[i];\n          var x = vtx[0] - lightWorldPosition[0];\n          var y = vtx[1] - lightWorldPosition[1];\n          var z = vtx[2] - lightWorldPosition[2];\n          var absx = Math.abs(x);\n          var absy = Math.abs(y);\n          var absz = Math.abs(z);\n          if (absx > absy) {\n            if (absx > absz) {\n              targetsNeedRender[x > 0 ? 'px' : 'nx'] = true;\n            } else {\n              targetsNeedRender[z > 0 ? 'pz' : 'nz'] = true;\n            }\n          } else {\n            if (absy > absz) {\n              targetsNeedRender[y > 0 ? 'py' : 'ny'] = true;\n            } else {\n              targetsNeedRender[z > 0 ? 'pz' : 'nz'] = true;\n            }\n          }\n        }\n        for (var i = 0; i < targets.length; i++) {\n          if (targetsNeedRender[targets[i]]) {\n            renderListEachSide[targets[i]].push(renderable);\n          }\n        }\n      }\n    });\n    for (var i = 0; i < 6; i++) {\n      var target = targets[i];\n      var camera = this._getPointLightCamera(light, target);\n      this._frameBuffer.attach(texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);\n      this._frameBuffer.bind(renderer);\n      _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);\n      renderer.renderPass(renderListEachSide[target], camera, passConfig);\n    }\n    this._frameBuffer.unbind(renderer);\n  },\n  _getDepthMaterial: function (light) {\n    var shadowMaterial = this._lightMaterials[light.__uid__];\n    var isPointLight = light.type === 'POINT_LIGHT';\n    if (!shadowMaterial) {\n      var shaderPrefix = isPointLight ? 'clay.sm.distance.' : 'clay.sm.depth.';\n      shadowMaterial = new Material({\n        precision: this.precision,\n        shader: new Shader(Shader.source(shaderPrefix + 'vertex'), Shader.source(shaderPrefix + 'fragment'))\n      });\n      this._lightMaterials[light.__uid__] = shadowMaterial;\n    }\n    if (light.shadowSlopeScale != null) {\n      shadowMaterial.setUniform('slopeScale', light.shadowSlopeScale);\n    }\n    if (light.shadowBias != null) {\n      shadowMaterial.setUniform('bias', light.shadowBias);\n    }\n    if (this.softShadow === ShadowMapPass.VSM) {\n      shadowMaterial.define('fragment', 'USE_VSM');\n    } else {\n      shadowMaterial.undefine('fragment', 'USE_VSM');\n    }\n    if (isPointLight) {\n      shadowMaterial.set('lightPosition', light.getWorldPosition().array);\n      shadowMaterial.set('range', light.range);\n    }\n    return shadowMaterial;\n  },\n  _gaussianFilter: function (renderer, texture, size) {\n    var parameter = {\n      width: size,\n      height: size,\n      type: Texture.FLOAT\n    };\n    var tmpTexture = this._texturePool.get(parameter);\n    this._frameBuffer.attach(tmpTexture);\n    this._frameBuffer.bind(renderer);\n    this._gaussianPassH.setUniform('texture', texture);\n    this._gaussianPassH.setUniform('textureWidth', size);\n    this._gaussianPassH.render(renderer);\n    this._frameBuffer.attach(texture);\n    this._gaussianPassV.setUniform('texture', tmpTexture);\n    this._gaussianPassV.setUniform('textureHeight', size);\n    this._gaussianPassV.render(renderer);\n    this._frameBuffer.unbind(renderer);\n    this._texturePool.put(tmpTexture);\n  },\n  _getTexture: function (light, cascade) {\n    var key = light.__uid__;\n    var texture = this._textures[key];\n    var resolution = light.shadowResolution || 512;\n    cascade = cascade || 1;\n    if (!texture) {\n      if (light.type === 'POINT_LIGHT') {\n        texture = new TextureCube();\n      } else {\n        texture = new Texture2D();\n      }\n      // At most 4 cascade\n      // TODO share with height ?\n      texture.width = resolution * cascade;\n      texture.height = resolution;\n      if (this.softShadow === ShadowMapPass.VSM) {\n        texture.type = Texture.FLOAT;\n        texture.anisotropic = 4;\n      } else {\n        texture.minFilter = glenum.NEAREST;\n        texture.magFilter = glenum.NEAREST;\n        texture.useMipmap = false;\n      }\n      this._textures[key] = texture;\n    }\n    return texture;\n  },\n  _getPointLightCamera: function (light, target) {\n    if (!this._lightCameras.point) {\n      this._lightCameras.point = {\n        px: new PerspectiveCamera(),\n        nx: new PerspectiveCamera(),\n        py: new PerspectiveCamera(),\n        ny: new PerspectiveCamera(),\n        pz: new PerspectiveCamera(),\n        nz: new PerspectiveCamera()\n      };\n    }\n    var camera = this._lightCameras.point[target];\n    camera.far = light.range;\n    camera.fov = 90;\n    camera.position.set(0, 0, 0);\n    switch (target) {\n      case 'px':\n        camera.lookAt(Vector3.POSITIVE_X, Vector3.NEGATIVE_Y);\n        break;\n      case 'nx':\n        camera.lookAt(Vector3.NEGATIVE_X, Vector3.NEGATIVE_Y);\n        break;\n      case 'py':\n        camera.lookAt(Vector3.POSITIVE_Y, Vector3.POSITIVE_Z);\n        break;\n      case 'ny':\n        camera.lookAt(Vector3.NEGATIVE_Y, Vector3.NEGATIVE_Z);\n        break;\n      case 'pz':\n        camera.lookAt(Vector3.POSITIVE_Z, Vector3.NEGATIVE_Y);\n        break;\n      case 'nz':\n        camera.lookAt(Vector3.NEGATIVE_Z, Vector3.NEGATIVE_Y);\n        break;\n    }\n    light.getWorldPosition(camera.position);\n    camera.update();\n    return camera;\n  },\n  _getDirectionalLightCamera: function () {\n    var lightViewMatrix = new Matrix4();\n    var sceneViewBoundingBox = new BoundingBox();\n    var lightViewBBox = new BoundingBox();\n    // Camera of directional light will be adjusted\n    // to contain the view frustum and scene bounding box as tightly as possible\n    return function (light, scene, sceneCamera) {\n      if (!this._lightCameras.directional) {\n        this._lightCameras.directional = new OrthoCamera();\n      }\n      var camera = this._lightCameras.directional;\n      sceneViewBoundingBox.copy(scene.viewBoundingBoxLastFrame);\n      sceneViewBoundingBox.intersection(sceneCamera.frustum.boundingBox);\n      // Move to the center of frustum(in world space)\n      camera.position.copy(sceneViewBoundingBox.min).add(sceneViewBoundingBox.max).scale(0.5).transformMat4(sceneCamera.worldTransform);\n      camera.rotation.copy(light.rotation);\n      camera.scale.copy(light.scale);\n      camera.updateWorldTransform();\n\n      // Transform to light view space\n      Matrix4.invert(lightViewMatrix, camera.worldTransform);\n      Matrix4.multiply(lightViewMatrix, lightViewMatrix, sceneCamera.worldTransform);\n      lightViewBBox.copy(sceneViewBoundingBox).applyTransform(lightViewMatrix);\n      var min = lightViewBBox.min.array;\n      var max = lightViewBBox.max.array;\n\n      // Move camera to adjust the near to 0\n      camera.position.set((min[0] + max[0]) / 2, (min[1] + max[1]) / 2, max[2]).transformMat4(camera.worldTransform);\n      camera.near = 0;\n      camera.far = -min[2] + max[2];\n      // Make sure receivers not in the frustum will stil receive the shadow.\n      if (isNaN(this.lightFrustumBias)) {\n        camera.far *= 4;\n      } else {\n        camera.far += this.lightFrustumBias;\n      }\n      camera.left = min[0];\n      camera.right = max[0];\n      camera.top = max[1];\n      camera.bottom = min[1];\n      camera.update(true);\n      return camera;\n    };\n  }(),\n  _getSpotLightCamera: function (light) {\n    if (!this._lightCameras.spot) {\n      this._lightCameras.spot = new PerspectiveCamera();\n    }\n    var camera = this._lightCameras.spot;\n    // Update properties\n    camera.fov = light.penumbraAngle * 2;\n    camera.far = light.range;\n    camera.worldTransform.copy(light.worldTransform);\n    camera.updateProjectionMatrix();\n    mat4.invert(camera.viewMatrix.array, camera.worldTransform.array);\n    return camera;\n  },\n  /**\n   * @param  {clay.Renderer|WebGLRenderingContext} [renderer]\n   * @memberOf clay.prePass.ShadowMap.prototype\n   */\n  // PENDING Renderer or WebGLRenderingContext\n  dispose: function (renderer) {\n    var _gl = renderer.gl || renderer;\n    if (this._frameBuffer) {\n      this._frameBuffer.dispose(_gl);\n    }\n    for (var name in this._textures) {\n      this._textures[name].dispose(_gl);\n    }\n    this._texturePool.clear(renderer.gl);\n    this._depthMaterials = {};\n    this._distanceMaterials = {};\n    this._textures = {};\n    this._lightCameras = {};\n    this._shadowMapNumber = {\n      'POINT_LIGHT': 0,\n      'DIRECTIONAL_LIGHT': 0,\n      'SPOT_LIGHT': 0\n    };\n    this._meshMaterials = {};\n    for (var i = 0; i < this._receivers.length; i++) {\n      var mesh = this._receivers[i];\n      // Mesh may be disposed\n      if (mesh.material) {\n        var material = mesh.material;\n        material.undefine('fragment', 'POINT_LIGHT_SHADOW_COUNT');\n        material.undefine('fragment', 'DIRECTIONAL_LIGHT_SHADOW_COUNT');\n        material.undefine('fragment', 'AMBIENT_LIGHT_SHADOW_COUNT');\n        material.set('shadowEnabled', 0);\n      }\n    }\n    this._receivers = [];\n    this._lightsCastShadow = [];\n  }\n});\n\n/**\n * @name clay.prePass.ShadowMap.VSM\n * @type {number}\n */\nShadowMapPass.VSM = 1;\n\n/**\n * @name clay.prePass.ShadowMap.PCF\n * @type {number}\n */\nShadowMapPass.PCF = 2;\nexport default ShadowMapPass;","map":{"version":3,"names":["Base","glenum","Vector3","BoundingBox","Frustum","Matrix4","Renderer","Shader","Material","FrameBuffer","Texture","Texture2D","TextureCube","PerspectiveCamera","OrthoCamera","Pass","TexturePool","mat4","targets","shadowmapEssl","getDepthMaterialUniform","renderable","depthMaterial","symbol","material","get","isDefined","alphaCutoff","isDepthMaterialChanged","prevRenderable","matA","matB","ShadowMapPass","extend","softShadow","PCF","shadowBlur","lightFrustumBias","kernelPCF","Float32Array","precision","_lastRenderNotCastShadow","_frameBuffer","_textures","_shadowMapNumber","_depthMaterials","_distanceMaterials","_receivers","_lightsCastShadow","_lightCameras","_lightMaterials","_texturePool","_gaussianPassH","fragment","source","_gaussianPassV","setUniform","_outputDepthPass","render","renderer","scene","sceneCamera","notUpdateScene","getMainCamera","trigger","_renderShadowPass","renderDebug","size","saveClear","viewport","x","y","width","height","VSM","define","undefine","name","texture","setViewport","restoreClear","_updateReceivers","mesh","receiveShadow","push","set","length","_update","self","traverse","isRenderable","i","lights","light","castShadow","invisible","_gl","gl","update","updateLights","enable","DEPTH_TEST","depthMask","disable","BLEND","clearColor","spotLightShadowMaps","spotLightMatrices","directionalLightShadowMaps","directionalLightMatrices","shadowCascadeClips","pointLightShadowMaps","dirLightHasCascade","type","console","warn","shadowCascade","renderDirectionalLightShadow","renderSpotLightShadow","renderPointLightShadow","lightType","number","key","fragmentDefines","shadowUniforms","getSize","directionalLightShadowMapSizes","map","value","shadowCascadeClipsNear","slice","shadowCascadeClipsFar","pop","shift","reverse","spotLightShadowMapSizes","splitFrustum","splitProjMatrix","cropBBox","cropMatrix","lightViewMatrix","lightViewProjMatrix","lightProjMatrix","defaultShadowMaterial","_getDepthMaterial","passConfig","getMaterial","shadowDepthMaterial","isMaterialChanged","getUniform","ifRender","sortCompare","opaqueSortCompare","viewBoundingBoxLastFrame","isFinite","boundingBox","getBoundingBox","copy","applyTransform","viewMatrix","clippedFar","Math","min","z","far","clippedNear","max","near","lightCamera","_getDirectionalLightCamera","lvpMat4Arr","array","projectionMatrix","invert","worldTransform","multiply","clipPlanes","isPerspective","scaleZ","offsetZ","clog","pow","cuni","c","cascadeSplitLogFactor","_getTexture","attach","bind","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","nearPlane","farPlane","perspective","fov","PI","aspect","ortho","left","right","bottom","top","setFromProjection","getTransformedBoundingBox","applyProjection","_min","_max","multiplyLeft","shadowSize","shadowResolution","renderList","updateRenderList","renderPass","opaque","_gaussianFilter","matrix","unbind","_getSpotLightCamera","renderListEachSide","px","py","pz","nx","ny","nz","bbox","lightWorldPosition","getWorldPosition","lightBBox","range","setArray","extent","add","sub","targetsNeedRender","geometry","transformFrom","intersectBoundingBox","updateVertices","vtx","vertices","absx","abs","absy","absz","target","camera","_getPointLightCamera","COLOR_ATTACHMENT0","TEXTURE_CUBE_MAP_POSITIVE_X","shadowMaterial","__uid__","isPointLight","shaderPrefix","shader","shadowSlopeScale","shadowBias","parameter","FLOAT","tmpTexture","put","cascade","resolution","anisotropic","minFilter","NEAREST","magFilter","useMipmap","point","position","lookAt","POSITIVE_X","NEGATIVE_Y","NEGATIVE_X","POSITIVE_Y","POSITIVE_Z","NEGATIVE_Z","sceneViewBoundingBox","lightViewBBox","directional","intersection","frustum","scale","transformMat4","rotation","updateWorldTransform","isNaN","spot","penumbraAngle","updateProjectionMatrix","dispose","_meshMaterials"],"sources":["E:/mytest/node_modules/claygl/src/prePass/ShadowMap.js"],"sourcesContent":["import Base from '../core/Base';\nimport glenum from '../core/glenum';\nimport Vector3 from '../math/Vector3';\nimport BoundingBox from '../math/BoundingBox';\nimport Frustum from '../math/Frustum';\nimport Matrix4 from '../math/Matrix4';\nimport Renderer from '../Renderer';\nimport Shader from '../Shader';\nimport Material from '../Material';\nimport FrameBuffer from '../FrameBuffer';\nimport Texture from '../Texture';\nimport Texture2D from '../Texture2D';\nimport TextureCube from '../TextureCube';\nimport PerspectiveCamera from '../camera/Perspective';\nimport OrthoCamera from '../camera/Orthographic';\n\nimport Pass from '../compositor/Pass';\nimport TexturePool from '../compositor/TexturePool';\n\nimport mat4 from '../glmatrix/mat4';\n\nvar targets = ['px', 'nx', 'py', 'ny', 'pz', 'nz'];\n\nimport shadowmapEssl from '../shader/source/shadowmap.glsl.js';\nShader['import'](shadowmapEssl);\n\nfunction getDepthMaterialUniform(renderable, depthMaterial, symbol) {\n    if (symbol === 'alphaMap') {\n        return renderable.material.get('diffuseMap');\n    }\n    else if (symbol === 'alphaCutoff') {\n        if (renderable.material.isDefined('fragment', 'ALPHA_TEST')\n            && renderable.material.get('diffuseMap')\n        ) {\n            var alphaCutoff = renderable.material.get('alphaCutoff');\n            return alphaCutoff || 0;\n        }\n        return 0;\n    }\n    else if (symbol === 'uvRepeat') {\n        return renderable.material.get('uvRepeat');\n    }\n    else if (symbol === 'uvOffset') {\n        return renderable.material.get('uvOffset');\n    }\n    else {\n        return depthMaterial.get(symbol);\n    }\n}\n\nfunction isDepthMaterialChanged(renderable, prevRenderable) {\n    var matA = renderable.material;\n    var matB = prevRenderable.material;\n    return matA.get('diffuseMap') !== matB.get('diffuseMap')\n        || (matA.get('alphaCutoff') || 0) !== (matB.get('alphaCutoff') || 0);\n}\n\n/**\n * Pass rendering shadow map.\n *\n * @constructor clay.prePass.ShadowMap\n * @extends clay.core.Base\n * @example\n *     var shadowMapPass = new clay.prePass.ShadowMap({\n *         softShadow: clay.prePass.ShadowMap.VSM\n *     });\n *     ...\n *     animation.on('frame', function (frameTime) {\n *         shadowMapPass.render(renderer, scene, camera);\n *         renderer.render(scene, camera);\n *     });\n */\nvar ShadowMapPass = Base.extend(function () {\n    return /** @lends clay.prePass.ShadowMap# */ {\n        /**\n         * Soft shadow technique.\n         * Can be {@link clay.prePass.ShadowMap.PCF} or {@link clay.prePass.ShadowMap.VSM}\n         * @type {number}\n         */\n        softShadow: ShadowMapPass.PCF,\n\n        /**\n         * Soft shadow blur size\n         * @type {number}\n         */\n        shadowBlur: 1.0,\n\n        lightFrustumBias: 'auto',\n\n        kernelPCF: new Float32Array([\n            1, 0,\n            1, 1,\n            -1, 1,\n            0, 1,\n            -1, 0,\n            -1, -1,\n            1, -1,\n            0, -1\n        ]),\n\n        precision: 'highp',\n\n        _lastRenderNotCastShadow: false,\n\n        _frameBuffer: new FrameBuffer(),\n\n        _textures: {},\n        _shadowMapNumber: {\n            'POINT_LIGHT': 0,\n            'DIRECTIONAL_LIGHT': 0,\n            'SPOT_LIGHT': 0\n        },\n\n        _depthMaterials: {},\n        _distanceMaterials: {},\n\n        _receivers: [],\n        _lightsCastShadow: [],\n\n        _lightCameras: {},\n        _lightMaterials: {},\n\n        _texturePool: new TexturePool()\n    };\n}, function () {\n    // Gaussian filter pass for VSM\n    this._gaussianPassH = new Pass({\n        fragment: Shader.source('clay.compositor.gaussian_blur')\n    });\n    this._gaussianPassV = new Pass({\n        fragment: Shader.source('clay.compositor.gaussian_blur')\n    });\n    this._gaussianPassH.setUniform('blurSize', this.shadowBlur);\n    this._gaussianPassH.setUniform('blurDir', 0.0);\n    this._gaussianPassV.setUniform('blurSize', this.shadowBlur);\n    this._gaussianPassV.setUniform('blurDir', 1.0);\n\n    this._outputDepthPass = new Pass({\n        fragment: Shader.source('clay.sm.debug_depth')\n    });\n}, {\n    /**\n     * Render scene to shadow textures\n     * @param  {clay.Renderer} renderer\n     * @param  {clay.Scene} scene\n     * @param  {clay.Camera} sceneCamera\n     * @param  {boolean} [notUpdateScene=false]\n     * @memberOf clay.prePass.ShadowMap.prototype\n     */\n    render: function (renderer, scene, sceneCamera, notUpdateScene) {\n        if (!sceneCamera) {\n            sceneCamera = scene.getMainCamera();\n        }\n        this.trigger('beforerender', this, renderer, scene, sceneCamera);\n        this._renderShadowPass(renderer, scene, sceneCamera, notUpdateScene);\n        this.trigger('afterrender', this, renderer, scene, sceneCamera);\n    },\n\n    /**\n     * Debug rendering of shadow textures\n     * @param  {clay.Renderer} renderer\n     * @param  {number} size\n     * @memberOf clay.prePass.ShadowMap.prototype\n     */\n    renderDebug: function (renderer, size) {\n        renderer.saveClear();\n        var viewport = renderer.viewport;\n        var x = 0, y = 0;\n        var width = size || viewport.width / 4;\n        var height = width;\n        if (this.softShadow === ShadowMapPass.VSM) {\n            this._outputDepthPass.material.define('fragment', 'USE_VSM');\n        }\n        else {\n            this._outputDepthPass.material.undefine('fragment', 'USE_VSM');\n        }\n        for (var name in this._textures) {\n            var texture = this._textures[name];\n            renderer.setViewport(x, y, width * texture.width / texture.height, height);\n            this._outputDepthPass.setUniform('depthMap', texture);\n            this._outputDepthPass.render(renderer);\n            x += width * texture.width / texture.height;\n        }\n        renderer.setViewport(viewport);\n        renderer.restoreClear();\n    },\n\n    _updateReceivers: function (renderer, mesh) {\n        if (mesh.receiveShadow) {\n            this._receivers.push(mesh);\n            mesh.material.set('shadowEnabled', 1);\n\n            mesh.material.set('pcfKernel', this.kernelPCF);\n        }\n        else {\n            mesh.material.set('shadowEnabled', 0);\n        }\n\n        if (this.softShadow === ShadowMapPass.VSM) {\n            mesh.material.define('fragment', 'USE_VSM');\n            mesh.material.undefine('fragment', 'PCF_KERNEL_SIZE');\n        }\n        else {\n            mesh.material.undefine('fragment', 'USE_VSM');\n            var kernelPCF = this.kernelPCF;\n            if (kernelPCF && kernelPCF.length) {\n                mesh.material.define('fragment', 'PCF_KERNEL_SIZE', kernelPCF.length / 2);\n            }\n            else {\n                mesh.material.undefine('fragment', 'PCF_KERNEL_SIZE');\n            }\n        }\n    },\n\n    _update: function (renderer, scene) {\n        var self = this;\n        scene.traverse(function (renderable) {\n            if (renderable.isRenderable()) {\n                self._updateReceivers(renderer, renderable);\n            }\n        });\n\n        for (var i = 0; i < scene.lights.length; i++) {\n            var light = scene.lights[i];\n            if (light.castShadow && !light.invisible) {\n                this._lightsCastShadow.push(light);\n            }\n        }\n    },\n\n    _renderShadowPass: function (renderer, scene, sceneCamera, notUpdateScene) {\n        // reset\n        for (var name in this._shadowMapNumber) {\n            this._shadowMapNumber[name] = 0;\n        }\n        this._lightsCastShadow.length = 0;\n        this._receivers.length = 0;\n\n        var _gl = renderer.gl;\n\n        if (!notUpdateScene) {\n            scene.update();\n        }\n        if (sceneCamera) {\n            sceneCamera.update();\n        }\n\n        scene.updateLights();\n        this._update(renderer, scene);\n\n        // Needs to update the receivers again if shadows come from 1 to 0.\n        if (!this._lightsCastShadow.length && this._lastRenderNotCastShadow) {\n            return;\n        }\n\n        this._lastRenderNotCastShadow = this._lightsCastShadow === 0;\n\n        _gl.enable(_gl.DEPTH_TEST);\n        _gl.depthMask(true);\n        _gl.disable(_gl.BLEND);\n\n        // Clear with high-z, so the part not rendered will not been shadowed\n        // TODO\n        // TODO restore\n        _gl.clearColor(1.0, 1.0, 1.0, 1.0);\n\n        // Shadow uniforms\n        var spotLightShadowMaps = [];\n        var spotLightMatrices = [];\n        var directionalLightShadowMaps = [];\n        var directionalLightMatrices = [];\n        var shadowCascadeClips = [];\n        var pointLightShadowMaps = [];\n\n        var dirLightHasCascade;\n        // Create textures for shadow map\n        for (var i = 0; i < this._lightsCastShadow.length; i++) {\n            var light = this._lightsCastShadow[i];\n            if (light.type === 'DIRECTIONAL_LIGHT') {\n\n                if (dirLightHasCascade) {\n                    console.warn('Only one direectional light supported with shadow cascade');\n                    continue;\n                }\n                if (light.shadowCascade > 4) {\n                    console.warn('Support at most 4 cascade');\n                    continue;\n                }\n                if (light.shadowCascade > 1) {\n                    dirLightHasCascade = light;\n                }\n\n                this.renderDirectionalLightShadow(\n                    renderer,\n                    scene,\n                    sceneCamera,\n                    light,\n                    shadowCascadeClips,\n                    directionalLightMatrices,\n                    directionalLightShadowMaps\n                );\n            }\n            else if (light.type === 'SPOT_LIGHT') {\n                this.renderSpotLightShadow(\n                    renderer,\n                    scene,\n                    light,\n                    spotLightMatrices,\n                    spotLightShadowMaps\n                );\n            }\n            else if (light.type === 'POINT_LIGHT') {\n                this.renderPointLightShadow(\n                    renderer,\n                    scene,\n                    light,\n                    pointLightShadowMaps\n                );\n            }\n\n            this._shadowMapNumber[light.type]++;\n        }\n\n        for (var lightType in this._shadowMapNumber) {\n            var number = this._shadowMapNumber[lightType];\n            var key = lightType + '_SHADOWMAP_COUNT';\n            for (var i = 0; i < this._receivers.length; i++) {\n                var mesh = this._receivers[i];\n                var material = mesh.material;\n                if (material.fragmentDefines[key] !== number) {\n                    if (number > 0) {\n                        material.define('fragment', key, number);\n                    }\n                    else if (material.isDefined('fragment', key)) {\n                        material.undefine('fragment', key);\n                    }\n                }\n            }\n        }\n        for (var i = 0; i < this._receivers.length; i++) {\n            var mesh = this._receivers[i];\n            var material = mesh.material;\n            if (dirLightHasCascade) {\n                material.define('fragment', 'SHADOW_CASCADE', dirLightHasCascade.shadowCascade);\n            }\n            else {\n                material.undefine('fragment', 'SHADOW_CASCADE');\n            }\n        }\n\n        var shadowUniforms = scene.shadowUniforms;\n\n        function getSize(texture) {\n            return texture.height;\n        }\n        if (directionalLightShadowMaps.length > 0) {\n            var directionalLightShadowMapSizes = directionalLightShadowMaps.map(getSize);\n            shadowUniforms.directionalLightShadowMaps = { value: directionalLightShadowMaps, type: 'tv' };\n            shadowUniforms.directionalLightMatrices = { value: directionalLightMatrices, type: 'm4v' };\n            shadowUniforms.directionalLightShadowMapSizes = { value: directionalLightShadowMapSizes, type: '1fv' };\n            if (dirLightHasCascade) {\n                var shadowCascadeClipsNear = shadowCascadeClips.slice();\n                var shadowCascadeClipsFar = shadowCascadeClips.slice();\n                shadowCascadeClipsNear.pop();\n                shadowCascadeClipsFar.shift();\n\n                // Iterate from far to near\n                shadowCascadeClipsNear.reverse();\n                shadowCascadeClipsFar.reverse();\n                // directionalLightShadowMaps.reverse();\n                directionalLightMatrices.reverse();\n                shadowUniforms.shadowCascadeClipsNear = { value: shadowCascadeClipsNear, type: '1fv' };\n                shadowUniforms.shadowCascadeClipsFar = { value: shadowCascadeClipsFar, type: '1fv' };\n            }\n        }\n\n        if (spotLightShadowMaps.length > 0) {\n            var spotLightShadowMapSizes = spotLightShadowMaps.map(getSize);\n            var shadowUniforms = scene.shadowUniforms;\n            shadowUniforms.spotLightShadowMaps = { value: spotLightShadowMaps, type: 'tv' };\n            shadowUniforms.spotLightMatrices = { value: spotLightMatrices, type: 'm4v' };\n            shadowUniforms.spotLightShadowMapSizes = { value: spotLightShadowMapSizes, type: '1fv' };\n        }\n\n        if (pointLightShadowMaps.length > 0) {\n            shadowUniforms.pointLightShadowMaps = { value: pointLightShadowMaps, type: 'tv' };\n        }\n    },\n\n    renderDirectionalLightShadow: (function () {\n\n        var splitFrustum = new Frustum();\n        var splitProjMatrix = new Matrix4();\n        var cropBBox = new BoundingBox();\n        var cropMatrix = new Matrix4();\n        var lightViewMatrix = new Matrix4();\n        var lightViewProjMatrix = new Matrix4();\n        var lightProjMatrix = new Matrix4();\n\n        return function (renderer, scene, sceneCamera, light, shadowCascadeClips, directionalLightMatrices, directionalLightShadowMaps) {\n\n            var defaultShadowMaterial = this._getDepthMaterial(light);\n            var passConfig = {\n                getMaterial: function (renderable) {\n                    return renderable.shadowDepthMaterial || defaultShadowMaterial;\n                },\n                isMaterialChanged: isDepthMaterialChanged,\n                getUniform: getDepthMaterialUniform,\n                ifRender: function (renderable) {\n                    return renderable.castShadow;\n                },\n                sortCompare: Renderer.opaqueSortCompare\n            };\n\n            // First frame\n            if (!scene.viewBoundingBoxLastFrame.isFinite()) {\n                var boundingBox = scene.getBoundingBox();\n                scene.viewBoundingBoxLastFrame\n                    .copy(boundingBox).applyTransform(sceneCamera.viewMatrix);\n            }\n            // Considering moving speed since the bounding box is from last frame\n            // TODO: add a bias\n            var clippedFar = Math.min(-scene.viewBoundingBoxLastFrame.min.z, sceneCamera.far);\n            var clippedNear = Math.max(-scene.viewBoundingBoxLastFrame.max.z, sceneCamera.near);\n\n            var lightCamera = this._getDirectionalLightCamera(light, scene, sceneCamera);\n\n            var lvpMat4Arr = lightViewProjMatrix.array;\n            lightProjMatrix.copy(lightCamera.projectionMatrix);\n            mat4.invert(lightViewMatrix.array, lightCamera.worldTransform.array);\n            mat4.multiply(lightViewMatrix.array, lightViewMatrix.array, sceneCamera.worldTransform.array);\n            mat4.multiply(lvpMat4Arr, lightProjMatrix.array, lightViewMatrix.array);\n\n            var clipPlanes = [];\n            var isPerspective = sceneCamera instanceof PerspectiveCamera;\n\n            var scaleZ = (sceneCamera.near + sceneCamera.far) / (sceneCamera.near - sceneCamera.far);\n            var offsetZ = 2 * sceneCamera.near * sceneCamera.far / (sceneCamera.near - sceneCamera.far);\n            for (var i = 0; i <= light.shadowCascade; i++) {\n                var clog = clippedNear * Math.pow(clippedFar / clippedNear, i / light.shadowCascade);\n                var cuni = clippedNear + (clippedFar - clippedNear) * i / light.shadowCascade;\n                var c = clog * light.cascadeSplitLogFactor + cuni * (1 - light.cascadeSplitLogFactor);\n                clipPlanes.push(c);\n                shadowCascadeClips.push(-(-c * scaleZ + offsetZ) / -c);\n            }\n            var texture = this._getTexture(light, light.shadowCascade);\n            directionalLightShadowMaps.push(texture);\n\n            var viewport = renderer.viewport;\n\n            var _gl = renderer.gl;\n            this._frameBuffer.attach(texture);\n            this._frameBuffer.bind(renderer);\n            _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);\n\n            for (var i = 0; i < light.shadowCascade; i++) {\n                // Get the splitted frustum\n                var nearPlane = clipPlanes[i];\n                var farPlane = clipPlanes[i + 1];\n                if (isPerspective) {\n                    mat4.perspective(splitProjMatrix.array, sceneCamera.fov / 180 * Math.PI, sceneCamera.aspect, nearPlane, farPlane);\n                }\n                else {\n                    mat4.ortho(\n                        splitProjMatrix.array,\n                        sceneCamera.left, sceneCamera.right, sceneCamera.bottom, sceneCamera.top,\n                        nearPlane, farPlane\n                    );\n                }\n                splitFrustum.setFromProjection(splitProjMatrix);\n                splitFrustum.getTransformedBoundingBox(cropBBox, lightViewMatrix);\n                cropBBox.applyProjection(lightProjMatrix);\n                var _min = cropBBox.min.array;\n                var _max = cropBBox.max.array;\n                _min[0] = Math.max(_min[0], -1);\n                _min[1] = Math.max(_min[1], -1);\n                _max[0] = Math.min(_max[0], 1);\n                _max[1] = Math.min(_max[1], 1);\n                cropMatrix.ortho(_min[0], _max[0], _min[1], _max[1], 1, -1);\n                lightCamera.projectionMatrix.multiplyLeft(cropMatrix);\n\n                var shadowSize = light.shadowResolution || 512;\n\n                // Reversed, left to right => far to near\n                renderer.setViewport((light.shadowCascade - i - 1) * shadowSize, 0, shadowSize, shadowSize, 1);\n\n                var renderList = scene.updateRenderList(lightCamera);\n                renderer.renderPass(renderList.opaque, lightCamera, passConfig);\n\n                // Filter for VSM\n                if (this.softShadow === ShadowMapPass.VSM) {\n                    this._gaussianFilter(renderer, texture, texture.width);\n                }\n\n                var matrix = new Matrix4();\n                matrix.copy(lightCamera.viewMatrix)\n                    .multiplyLeft(lightCamera.projectionMatrix);\n\n                directionalLightMatrices.push(matrix.array);\n\n                lightCamera.projectionMatrix.copy(lightProjMatrix);\n            }\n\n            this._frameBuffer.unbind(renderer);\n\n            renderer.setViewport(viewport);\n        };\n    })(),\n\n    renderSpotLightShadow: function (renderer, scene, light, spotLightMatrices, spotLightShadowMaps) {\n\n        var texture = this._getTexture(light);\n        var lightCamera = this._getSpotLightCamera(light);\n        var _gl = renderer.gl;\n\n        this._frameBuffer.attach(texture);\n        this._frameBuffer.bind(renderer);\n\n        _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);\n\n        var defaultShadowMaterial = this._getDepthMaterial(light);\n        var passConfig = {\n            getMaterial: function (renderable) {\n                return renderable.shadowDepthMaterial || defaultShadowMaterial;\n            },\n            isMaterialChanged: isDepthMaterialChanged,\n            getUniform: getDepthMaterialUniform,\n            ifRender: function (renderable) {\n                return renderable.castShadow;\n            },\n            sortCompare: Renderer.opaqueSortCompare\n        };\n\n        var renderList = scene.updateRenderList(lightCamera);\n        renderer.renderPass(renderList.opaque, lightCamera, passConfig);\n\n        this._frameBuffer.unbind(renderer);\n\n        // Filter for VSM\n        if (this.softShadow === ShadowMapPass.VSM) {\n            this._gaussianFilter(renderer, texture, texture.width);\n        }\n\n        var matrix = new Matrix4();\n        matrix.copy(lightCamera.worldTransform)\n            .invert()\n            .multiplyLeft(lightCamera.projectionMatrix);\n\n        spotLightShadowMaps.push(texture);\n        spotLightMatrices.push(matrix.array);\n    },\n\n    renderPointLightShadow: function (renderer, scene, light, pointLightShadowMaps) {\n        var texture = this._getTexture(light);\n        var _gl = renderer.gl;\n        pointLightShadowMaps.push(texture);\n\n        var defaultShadowMaterial = this._getDepthMaterial(light);\n        var passConfig = {\n            getMaterial: function (renderable) {\n                return renderable.shadowDepthMaterial || defaultShadowMaterial;\n            },\n            getUniform: getDepthMaterialUniform,\n            sortCompare: Renderer.opaqueSortCompare\n        };\n\n        var renderListEachSide = {\n            px: [], py: [], pz: [], nx: [], ny: [], nz: []\n        };\n        var bbox = new BoundingBox();\n        var lightWorldPosition = light.getWorldPosition().array;\n        var lightBBox = new BoundingBox();\n        var range = light.range;\n        lightBBox.min.setArray(lightWorldPosition);\n        lightBBox.max.setArray(lightWorldPosition);\n        var extent = new Vector3(range, range, range);\n        lightBBox.max.add(extent);\n        lightBBox.min.sub(extent);\n\n        var targetsNeedRender = { px: false, py: false, pz: false, nx: false, ny: false, nz: false };\n        scene.traverse(function (renderable) {\n            if (renderable.isRenderable() && renderable.castShadow) {\n                var geometry = renderable.geometry;\n                if (!geometry.boundingBox) {\n                    for (var i = 0; i < targets.length; i++) {\n                        renderListEachSide[targets[i]].push(renderable);\n                    }\n                    return;\n                }\n                bbox.transformFrom(geometry.boundingBox, renderable.worldTransform);\n                if (!bbox.intersectBoundingBox(lightBBox)) {\n                    return;\n                }\n\n                bbox.updateVertices();\n                for (var i = 0; i < targets.length; i++) {\n                    targetsNeedRender[targets[i]] = false;\n                }\n                for (var i = 0; i < 8; i++) {\n                    var vtx = bbox.vertices[i];\n                    var x = vtx[0] - lightWorldPosition[0];\n                    var y = vtx[1] - lightWorldPosition[1];\n                    var z = vtx[2] - lightWorldPosition[2];\n                    var absx = Math.abs(x);\n                    var absy = Math.abs(y);\n                    var absz = Math.abs(z);\n                    if (absx > absy) {\n                        if (absx > absz) {\n                            targetsNeedRender[x > 0 ? 'px' : 'nx'] = true;\n                        }\n                        else {\n                            targetsNeedRender[z > 0 ? 'pz' : 'nz'] = true;\n                        }\n                    }\n                    else {\n                        if (absy > absz) {\n                            targetsNeedRender[y > 0 ? 'py' : 'ny'] = true;\n                        }\n                        else {\n                            targetsNeedRender[z > 0 ? 'pz' : 'nz'] = true;\n                        }\n                    }\n                }\n                for (var i = 0; i < targets.length; i++) {\n                    if (targetsNeedRender[targets[i]]) {\n                        renderListEachSide[targets[i]].push(renderable);\n                    }\n                }\n            }\n        });\n\n        for (var i = 0; i < 6; i++) {\n            var target = targets[i];\n            var camera = this._getPointLightCamera(light, target);\n\n            this._frameBuffer.attach(texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);\n            this._frameBuffer.bind(renderer);\n            _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);\n\n            renderer.renderPass(renderListEachSide[target], camera, passConfig);\n        }\n\n        this._frameBuffer.unbind(renderer);\n    },\n\n    _getDepthMaterial: function (light) {\n        var shadowMaterial = this._lightMaterials[light.__uid__];\n        var isPointLight = light.type === 'POINT_LIGHT';\n        if (!shadowMaterial) {\n            var shaderPrefix = isPointLight ? 'clay.sm.distance.' : 'clay.sm.depth.';\n            shadowMaterial = new Material({\n                precision: this.precision,\n                shader: new Shader(Shader.source(shaderPrefix + 'vertex'), Shader.source(shaderPrefix + 'fragment'))\n            });\n\n            this._lightMaterials[light.__uid__] = shadowMaterial;\n        }\n        if (light.shadowSlopeScale != null) {\n            shadowMaterial.setUniform('slopeScale', light.shadowSlopeScale);\n        }\n        if (light.shadowBias != null) {\n            shadowMaterial.setUniform('bias', light.shadowBias);\n        }\n        if (this.softShadow === ShadowMapPass.VSM) {\n            shadowMaterial.define('fragment', 'USE_VSM');\n        }\n        else {\n            shadowMaterial.undefine('fragment', 'USE_VSM');\n        }\n\n        if (isPointLight) {\n            shadowMaterial.set('lightPosition', light.getWorldPosition().array);\n            shadowMaterial.set('range', light.range);\n        }\n\n        return shadowMaterial;\n    },\n\n    _gaussianFilter: function (renderer, texture, size) {\n        var parameter = {\n            width: size,\n            height: size,\n            type: Texture.FLOAT\n        };\n        var tmpTexture = this._texturePool.get(parameter);\n\n        this._frameBuffer.attach(tmpTexture);\n        this._frameBuffer.bind(renderer);\n        this._gaussianPassH.setUniform('texture', texture);\n        this._gaussianPassH.setUniform('textureWidth', size);\n        this._gaussianPassH.render(renderer);\n\n        this._frameBuffer.attach(texture);\n        this._gaussianPassV.setUniform('texture', tmpTexture);\n        this._gaussianPassV.setUniform('textureHeight', size);\n        this._gaussianPassV.render(renderer);\n        this._frameBuffer.unbind(renderer);\n\n        this._texturePool.put(tmpTexture);\n    },\n\n    _getTexture: function (light, cascade) {\n        var key = light.__uid__;\n        var texture = this._textures[key];\n        var resolution = light.shadowResolution || 512;\n        cascade = cascade || 1;\n        if (!texture) {\n            if (light.type === 'POINT_LIGHT') {\n                texture = new TextureCube();\n            }\n            else {\n                texture = new Texture2D();\n            }\n            // At most 4 cascade\n            // TODO share with height ?\n            texture.width = resolution * cascade;\n            texture.height = resolution;\n            if (this.softShadow === ShadowMapPass.VSM) {\n                texture.type = Texture.FLOAT;\n                texture.anisotropic = 4;\n            }\n            else {\n                texture.minFilter = glenum.NEAREST;\n                texture.magFilter = glenum.NEAREST;\n                texture.useMipmap = false;\n            }\n            this._textures[key] = texture;\n        }\n\n        return texture;\n    },\n\n    _getPointLightCamera: function (light, target) {\n        if (!this._lightCameras.point) {\n            this._lightCameras.point = {\n                px: new PerspectiveCamera(),\n                nx: new PerspectiveCamera(),\n                py: new PerspectiveCamera(),\n                ny: new PerspectiveCamera(),\n                pz: new PerspectiveCamera(),\n                nz: new PerspectiveCamera()\n            };\n        }\n        var camera = this._lightCameras.point[target];\n\n        camera.far = light.range;\n        camera.fov = 90;\n        camera.position.set(0, 0, 0);\n        switch (target) {\n            case 'px':\n                camera.lookAt(Vector3.POSITIVE_X, Vector3.NEGATIVE_Y);\n                break;\n            case 'nx':\n                camera.lookAt(Vector3.NEGATIVE_X, Vector3.NEGATIVE_Y);\n                break;\n            case 'py':\n                camera.lookAt(Vector3.POSITIVE_Y, Vector3.POSITIVE_Z);\n                break;\n            case 'ny':\n                camera.lookAt(Vector3.NEGATIVE_Y, Vector3.NEGATIVE_Z);\n                break;\n            case 'pz':\n                camera.lookAt(Vector3.POSITIVE_Z, Vector3.NEGATIVE_Y);\n                break;\n            case 'nz':\n                camera.lookAt(Vector3.NEGATIVE_Z, Vector3.NEGATIVE_Y);\n                break;\n        }\n        light.getWorldPosition(camera.position);\n        camera.update();\n\n        return camera;\n    },\n\n    _getDirectionalLightCamera: (function () {\n        var lightViewMatrix = new Matrix4();\n        var sceneViewBoundingBox = new BoundingBox();\n        var lightViewBBox = new BoundingBox();\n        // Camera of directional light will be adjusted\n        // to contain the view frustum and scene bounding box as tightly as possible\n        return function (light, scene, sceneCamera) {\n            if (!this._lightCameras.directional) {\n                this._lightCameras.directional = new OrthoCamera();\n            }\n            var camera = this._lightCameras.directional;\n\n            sceneViewBoundingBox.copy(scene.viewBoundingBoxLastFrame);\n            sceneViewBoundingBox.intersection(sceneCamera.frustum.boundingBox);\n            // Move to the center of frustum(in world space)\n            camera.position\n                .copy(sceneViewBoundingBox.min)\n                .add(sceneViewBoundingBox.max)\n                .scale(0.5)\n                .transformMat4(sceneCamera.worldTransform);\n            camera.rotation.copy(light.rotation);\n            camera.scale.copy(light.scale);\n            camera.updateWorldTransform();\n\n            // Transform to light view space\n            Matrix4.invert(lightViewMatrix, camera.worldTransform);\n            Matrix4.multiply(lightViewMatrix, lightViewMatrix, sceneCamera.worldTransform);\n\n            lightViewBBox.copy(sceneViewBoundingBox).applyTransform(lightViewMatrix);\n\n            var min = lightViewBBox.min.array;\n            var max = lightViewBBox.max.array;\n\n            // Move camera to adjust the near to 0\n            camera.position.set((min[0] + max[0]) / 2, (min[1] + max[1]) / 2, max[2])\n                .transformMat4(camera.worldTransform);\n            camera.near = 0;\n            camera.far = -min[2] + max[2];\n            // Make sure receivers not in the frustum will stil receive the shadow.\n            if (isNaN(this.lightFrustumBias)) {\n                camera.far *= 4;\n            }\n            else {\n                camera.far += this.lightFrustumBias;\n            }\n            camera.left = min[0];\n            camera.right = max[0];\n            camera.top = max[1];\n            camera.bottom = min[1];\n            camera.update(true);\n\n            return camera;\n        };\n    })(),\n\n    _getSpotLightCamera: function (light) {\n        if (!this._lightCameras.spot) {\n            this._lightCameras.spot = new PerspectiveCamera();\n        }\n        var camera = this._lightCameras.spot;\n        // Update properties\n        camera.fov = light.penumbraAngle * 2;\n        camera.far = light.range;\n        camera.worldTransform.copy(light.worldTransform);\n        camera.updateProjectionMatrix();\n        mat4.invert(camera.viewMatrix.array, camera.worldTransform.array);\n\n        return camera;\n    },\n\n    /**\n     * @param  {clay.Renderer|WebGLRenderingContext} [renderer]\n     * @memberOf clay.prePass.ShadowMap.prototype\n     */\n    // PENDING Renderer or WebGLRenderingContext\n    dispose: function (renderer) {\n        var _gl = renderer.gl || renderer;\n\n        if (this._frameBuffer) {\n            this._frameBuffer.dispose(_gl);\n        }\n\n        for (var name in this._textures) {\n            this._textures[name].dispose(_gl);\n        }\n\n        this._texturePool.clear(renderer.gl);\n\n        this._depthMaterials = {};\n        this._distanceMaterials = {};\n        this._textures = {};\n        this._lightCameras = {};\n        this._shadowMapNumber = {\n            'POINT_LIGHT': 0,\n            'DIRECTIONAL_LIGHT': 0,\n            'SPOT_LIGHT': 0\n        };\n        this._meshMaterials = {};\n\n        for (var i = 0; i < this._receivers.length; i++) {\n            var mesh = this._receivers[i];\n            // Mesh may be disposed\n            if (mesh.material) {\n                var material = mesh.material;\n                material.undefine('fragment', 'POINT_LIGHT_SHADOW_COUNT');\n                material.undefine('fragment', 'DIRECTIONAL_LIGHT_SHADOW_COUNT');\n                material.undefine('fragment', 'AMBIENT_LIGHT_SHADOW_COUNT');\n                material.set('shadowEnabled', 0);\n            }\n        }\n\n        this._receivers = [];\n        this._lightsCastShadow = [];\n    }\n});\n\n/**\n * @name clay.prePass.ShadowMap.VSM\n * @type {number}\n */\nShadowMapPass.VSM = 1;\n\n/**\n * @name clay.prePass.ShadowMap.PCF\n * @type {number}\n */\nShadowMapPass.PCF = 2;\n\nexport default ShadowMapPass;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}