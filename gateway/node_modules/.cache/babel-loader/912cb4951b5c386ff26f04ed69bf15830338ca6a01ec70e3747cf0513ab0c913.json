{"ast":null,"code":"import Vector3 from './Vector3';\nimport mat4 from '../glmatrix/mat4';\nimport vec3 from '../glmatrix/vec3';\nimport vec4 from '../glmatrix/vec4';\n\n/**\n * @constructor\n * @alias clay.Plane\n * @param {clay.Vector3} [normal]\n * @param {number} [distance]\n */\nvar Plane = function (normal, distance) {\n  /**\n   * Normal of the plane\n   * @type {clay.Vector3}\n   */\n  this.normal = normal || new Vector3(0, 1, 0);\n\n  /**\n   * Constant of the plane equation, used as distance to the origin\n   * @type {number}\n   */\n  this.distance = distance || 0;\n};\nPlane.prototype = {\n  constructor: Plane,\n  /**\n   * Distance from a given point to the plane\n   * @param  {clay.Vector3} point\n   * @return {number}\n   */\n  distanceToPoint: function (point) {\n    return vec3.dot(point.array, this.normal.array) - this.distance;\n  },\n  /**\n   * Calculate the projection point on the plane\n   * @param  {clay.Vector3} point\n   * @param  {clay.Vector3} out\n   * @return {clay.Vector3}\n   */\n  projectPoint: function (point, out) {\n    if (!out) {\n      out = new Vector3();\n    }\n    var d = this.distanceToPoint(point);\n    vec3.scaleAndAdd(out.array, point.array, this.normal.array, -d);\n    out._dirty = true;\n    return out;\n  },\n  /**\n   * Normalize the plane's normal and calculate the distance\n   */\n  normalize: function () {\n    var invLen = 1 / vec3.len(this.normal.array);\n    vec3.scale(this.normal.array, invLen);\n    this.distance *= invLen;\n  },\n  /**\n   * If the plane intersect a frustum\n   * @param  {clay.Frustum} Frustum\n   * @return {boolean}\n   */\n  intersectFrustum: function (frustum) {\n    // Check if all coords of frustum is on plane all under plane\n    var coords = frustum.vertices;\n    var normal = this.normal.array;\n    var onPlane = vec3.dot(coords[0].array, normal) > this.distance;\n    for (var i = 1; i < 8; i++) {\n      if (vec3.dot(coords[i].array, normal) > this.distance != onPlane) {\n        return true;\n      }\n    }\n  },\n  /**\n   * Calculate the intersection point between plane and a given line\n   * @function\n   * @param {clay.Vector3} start start point of line\n   * @param {clay.Vector3} end end point of line\n   * @param {clay.Vector3} [out]\n   * @return {clay.Vector3}\n   */\n  intersectLine: function () {\n    var rd = vec3.create();\n    return function (start, end, out) {\n      var d0 = this.distanceToPoint(start);\n      var d1 = this.distanceToPoint(end);\n      if (d0 > 0 && d1 > 0 || d0 < 0 && d1 < 0) {\n        return null;\n      }\n      // Ray intersection\n      var pn = this.normal.array;\n      var d = this.distance;\n      var ro = start.array;\n      // direction\n      vec3.sub(rd, end.array, start.array);\n      vec3.normalize(rd, rd);\n      var divider = vec3.dot(pn, rd);\n      // ray is parallel to the plane\n      if (divider === 0) {\n        return null;\n      }\n      if (!out) {\n        out = new Vector3();\n      }\n      var t = (vec3.dot(pn, ro) - d) / divider;\n      vec3.scaleAndAdd(out.array, ro, rd, -t);\n      out._dirty = true;\n      return out;\n    };\n  }(),\n  /**\n   * Apply an affine transform matrix to plane\n   * @function\n   * @return {clay.Matrix4}\n   */\n  applyTransform: function () {\n    var inverseTranspose = mat4.create();\n    var normalv4 = vec4.create();\n    var pointv4 = vec4.create();\n    pointv4[3] = 1;\n    return function (m4) {\n      m4 = m4.array;\n      // Transform point on plane\n      vec3.scale(pointv4, this.normal.array, this.distance);\n      vec4.transformMat4(pointv4, pointv4, m4);\n      this.distance = vec3.dot(pointv4, this.normal.array);\n      // Transform plane normal\n      mat4.invert(inverseTranspose, m4);\n      mat4.transpose(inverseTranspose, inverseTranspose);\n      normalv4[3] = 0;\n      vec3.copy(normalv4, this.normal.array);\n      vec4.transformMat4(normalv4, normalv4, inverseTranspose);\n      vec3.copy(this.normal.array, normalv4);\n    };\n  }(),\n  /**\n   * Copy from another plane\n   * @param  {clay.Vector3} plane\n   */\n  copy: function (plane) {\n    vec3.copy(this.normal.array, plane.normal.array);\n    this.normal._dirty = true;\n    this.distance = plane.distance;\n  },\n  /**\n   * Clone a new plane\n   * @return {clay.Plane}\n   */\n  clone: function () {\n    var plane = new Plane();\n    plane.copy(this);\n    return plane;\n  }\n};\nexport default Plane;","map":{"version":3,"names":["Vector3","mat4","vec3","vec4","Plane","normal","distance","prototype","constructor","distanceToPoint","point","dot","array","projectPoint","out","d","scaleAndAdd","_dirty","normalize","invLen","len","scale","intersectFrustum","frustum","coords","vertices","onPlane","i","intersectLine","rd","create","start","end","d0","d1","pn","ro","sub","divider","t","applyTransform","inverseTranspose","normalv4","pointv4","m4","transformMat4","invert","transpose","copy","plane","clone"],"sources":["E:/mytest/node_modules/claygl/src/math/Plane.js"],"sourcesContent":["import Vector3 from './Vector3';\nimport mat4 from '../glmatrix/mat4';\nimport vec3 from '../glmatrix/vec3';\nimport vec4 from '../glmatrix/vec4';\n\n/**\n * @constructor\n * @alias clay.Plane\n * @param {clay.Vector3} [normal]\n * @param {number} [distance]\n */\nvar Plane = function(normal, distance) {\n    /**\n     * Normal of the plane\n     * @type {clay.Vector3}\n     */\n    this.normal = normal || new Vector3(0, 1, 0);\n\n    /**\n     * Constant of the plane equation, used as distance to the origin\n     * @type {number}\n     */\n    this.distance = distance || 0;\n};\n\nPlane.prototype = {\n\n    constructor: Plane,\n\n    /**\n     * Distance from a given point to the plane\n     * @param  {clay.Vector3} point\n     * @return {number}\n     */\n    distanceToPoint: function(point) {\n        return vec3.dot(point.array, this.normal.array) - this.distance;\n    },\n\n    /**\n     * Calculate the projection point on the plane\n     * @param  {clay.Vector3} point\n     * @param  {clay.Vector3} out\n     * @return {clay.Vector3}\n     */\n    projectPoint: function(point, out) {\n        if (!out) {\n            out = new Vector3();\n        }\n        var d = this.distanceToPoint(point);\n        vec3.scaleAndAdd(out.array, point.array, this.normal.array, -d);\n        out._dirty = true;\n        return out;\n    },\n\n    /**\n     * Normalize the plane's normal and calculate the distance\n     */\n    normalize: function() {\n        var invLen = 1 / vec3.len(this.normal.array);\n        vec3.scale(this.normal.array, invLen);\n        this.distance *= invLen;\n    },\n\n    /**\n     * If the plane intersect a frustum\n     * @param  {clay.Frustum} Frustum\n     * @return {boolean}\n     */\n    intersectFrustum: function(frustum) {\n        // Check if all coords of frustum is on plane all under plane\n        var coords = frustum.vertices;\n        var normal = this.normal.array;\n        var onPlane = vec3.dot(coords[0].array, normal) > this.distance;\n        for (var i = 1; i < 8; i++) {\n            if ((vec3.dot(coords[i].array, normal) > this.distance) != onPlane) {\n                return true;\n            }\n        }\n    },\n\n    /**\n     * Calculate the intersection point between plane and a given line\n     * @function\n     * @param {clay.Vector3} start start point of line\n     * @param {clay.Vector3} end end point of line\n     * @param {clay.Vector3} [out]\n     * @return {clay.Vector3}\n     */\n    intersectLine: (function() {\n        var rd = vec3.create();\n        return function(start, end, out) {\n            var d0 = this.distanceToPoint(start);\n            var d1 = this.distanceToPoint(end);\n            if ((d0 > 0 && d1 > 0) || (d0 < 0 && d1 < 0)) {\n                return null;\n            }\n            // Ray intersection\n            var pn = this.normal.array;\n            var d = this.distance;\n            var ro = start.array;\n            // direction\n            vec3.sub(rd, end.array, start.array);\n            vec3.normalize(rd, rd);\n\n            var divider = vec3.dot(pn, rd);\n            // ray is parallel to the plane\n            if (divider === 0) {\n                return null;\n            }\n            if (!out) {\n                out = new Vector3();\n            }\n            var t = (vec3.dot(pn, ro) - d) / divider;\n            vec3.scaleAndAdd(out.array, ro, rd, -t);\n            out._dirty = true;\n            return out;\n        };\n    })(),\n\n    /**\n     * Apply an affine transform matrix to plane\n     * @function\n     * @return {clay.Matrix4}\n     */\n    applyTransform: (function() {\n        var inverseTranspose = mat4.create();\n        var normalv4 = vec4.create();\n        var pointv4 = vec4.create();\n        pointv4[3] = 1;\n        return function(m4) {\n            m4 = m4.array;\n            // Transform point on plane\n            vec3.scale(pointv4, this.normal.array, this.distance);\n            vec4.transformMat4(pointv4, pointv4, m4);\n            this.distance = vec3.dot(pointv4, this.normal.array);\n            // Transform plane normal\n            mat4.invert(inverseTranspose, m4);\n            mat4.transpose(inverseTranspose, inverseTranspose);\n            normalv4[3] = 0;\n            vec3.copy(normalv4, this.normal.array);\n            vec4.transformMat4(normalv4, normalv4, inverseTranspose);\n            vec3.copy(this.normal.array, normalv4);\n        };\n    })(),\n\n    /**\n     * Copy from another plane\n     * @param  {clay.Vector3} plane\n     */\n    copy: function(plane) {\n        vec3.copy(this.normal.array, plane.normal.array);\n        this.normal._dirty = true;\n        this.distance = plane.distance;\n    },\n\n    /**\n     * Clone a new plane\n     * @return {clay.Plane}\n     */\n    clone: function() {\n        var plane = new Plane();\n        plane.copy(this);\n        return plane;\n    }\n};\n\nexport default Plane;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}