{"ast":null,"code":"import \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport Texture from '../Texture';\nimport Texture2D from '../Texture2D';\nvar toChar = String.fromCharCode;\nvar MINELEN = 8;\nvar MAXELEN = 0x7fff;\nfunction rgbe2float(rgbe, buffer, offset, exposure) {\n  if (rgbe[3] > 0) {\n    var f = Math.pow(2.0, rgbe[3] - 128 - 8 + exposure);\n    buffer[offset + 0] = rgbe[0] * f;\n    buffer[offset + 1] = rgbe[1] * f;\n    buffer[offset + 2] = rgbe[2] * f;\n  } else {\n    buffer[offset + 0] = 0;\n    buffer[offset + 1] = 0;\n    buffer[offset + 2] = 0;\n  }\n  buffer[offset + 3] = 1.0;\n  return buffer;\n}\nfunction uint82string(array, offset, size) {\n  var str = '';\n  for (var i = offset; i < size; i++) {\n    str += toChar(array[i]);\n  }\n  return str;\n}\nfunction copyrgbe(s, t) {\n  t[0] = s[0];\n  t[1] = s[1];\n  t[2] = s[2];\n  t[3] = s[3];\n}\n\n// TODO : check\nfunction oldReadColors(scan, buffer, offset, xmax) {\n  var rshift = 0,\n    x = 0,\n    len = xmax;\n  while (len > 0) {\n    scan[x][0] = buffer[offset++];\n    scan[x][1] = buffer[offset++];\n    scan[x][2] = buffer[offset++];\n    scan[x][3] = buffer[offset++];\n    if (scan[x][0] === 1 && scan[x][1] === 1 && scan[x][2] === 1) {\n      // exp is count of repeated pixels\n      for (var i = scan[x][3] << rshift >>> 0; i > 0; i--) {\n        copyrgbe(scan[x - 1], scan[x]);\n        x++;\n        len--;\n      }\n      rshift += 8;\n    } else {\n      x++;\n      len--;\n      rshift = 0;\n    }\n  }\n  return offset;\n}\nfunction readColors(scan, buffer, offset, xmax) {\n  if (xmax < MINELEN | xmax > MAXELEN) {\n    return oldReadColors(scan, buffer, offset, xmax);\n  }\n  var i = buffer[offset++];\n  if (i != 2) {\n    return oldReadColors(scan, buffer, offset - 1, xmax);\n  }\n  scan[0][1] = buffer[offset++];\n  scan[0][2] = buffer[offset++];\n  i = buffer[offset++];\n  if ((scan[0][2] << 8 >>> 0 | i) >>> 0 !== xmax) {\n    return null;\n  }\n  for (var i = 0; i < 4; i++) {\n    for (var x = 0; x < xmax;) {\n      var code = buffer[offset++];\n      if (code > 128) {\n        code = (code & 127) >>> 0;\n        var val = buffer[offset++];\n        while (code--) {\n          scan[x++][i] = val;\n        }\n      } else {\n        while (code--) {\n          scan[x++][i] = buffer[offset++];\n        }\n      }\n    }\n  }\n  return offset;\n}\nvar ret = {\n  // http://www.graphics.cornell.edu/~bjw/rgbe.html\n  // Blender source\n  // http://radsite.lbl.gov/radiance/refer/Notes/picture_format.html\n  parseRGBE: function (arrayBuffer, texture, exposure) {\n    if (exposure == null) {\n      exposure = 0;\n    }\n    var data = new Uint8Array(arrayBuffer);\n    var size = data.length;\n    if (uint82string(data, 0, 2) !== '#?') {\n      return;\n    }\n    // find empty line, next line is resolution info\n    for (var i = 2; i < size; i++) {\n      if (toChar(data[i]) === '\\n' && toChar(data[i + 1]) === '\\n') {\n        break;\n      }\n    }\n    if (i >= size) {\n      // not found\n      return;\n    }\n    // find resolution info line\n    i += 2;\n    var str = '';\n    for (; i < size; i++) {\n      var _char = toChar(data[i]);\n      if (_char === '\\n') {\n        break;\n      }\n      str += _char;\n    }\n    // -Y M +X N\n    var tmp = str.split(' ');\n    var height = parseInt(tmp[1]);\n    var width = parseInt(tmp[3]);\n    if (!width || !height) {\n      return;\n    }\n\n    // read and decode actual data\n    var offset = i + 1;\n    var scanline = [];\n    // memzero\n    for (var x = 0; x < width; x++) {\n      scanline[x] = [];\n      for (var j = 0; j < 4; j++) {\n        scanline[x][j] = 0;\n      }\n    }\n    var pixels = new Float32Array(width * height * 4);\n    var offset2 = 0;\n    for (var y = 0; y < height; y++) {\n      var offset = readColors(scanline, data, offset, width);\n      if (!offset) {\n        return null;\n      }\n      for (var x = 0; x < width; x++) {\n        rgbe2float(scanline[x], pixels, offset2, exposure);\n        offset2 += 4;\n      }\n    }\n    if (!texture) {\n      texture = new Texture2D();\n    }\n    texture.width = width;\n    texture.height = height;\n    texture.pixels = pixels;\n    // HALF_FLOAT can't use Float32Array\n    texture.type = Texture.FLOAT;\n    return texture;\n  },\n  parseRGBEFromPNG: function (png) {}\n};\nexport default ret;","map":{"version":3,"names":["Texture","Texture2D","toChar","String","fromCharCode","MINELEN","MAXELEN","rgbe2float","rgbe","buffer","offset","exposure","f","Math","pow","uint82string","array","size","str","i","copyrgbe","s","t","oldReadColors","scan","xmax","rshift","x","len","readColors","code","val","ret","parseRGBE","arrayBuffer","texture","data","Uint8Array","length","_char","tmp","split","height","parseInt","width","scanline","j","pixels","Float32Array","offset2","y","type","FLOAT","parseRGBEFromPNG","png"],"sources":["E:/QuestionairePlanet_Fronted/mytest/node_modules/claygl/src/util/hdr.js"],"sourcesContent":["import Texture from '../Texture';\nimport Texture2D from '../Texture2D';\nvar toChar = String.fromCharCode;\n\nvar MINELEN = 8;\nvar MAXELEN = 0x7fff;\nfunction rgbe2float(rgbe, buffer, offset, exposure) {\n    if (rgbe[3] > 0) {\n        var f = Math.pow(2.0, rgbe[3] - 128 - 8 + exposure);\n        buffer[offset + 0] = rgbe[0] * f;\n        buffer[offset + 1] = rgbe[1] * f;\n        buffer[offset + 2] = rgbe[2] * f;\n    }\n    else {\n        buffer[offset + 0] = 0;\n        buffer[offset + 1] = 0;\n        buffer[offset + 2] = 0;\n    }\n    buffer[offset + 3] = 1.0;\n    return buffer;\n}\n\nfunction uint82string(array, offset, size) {\n    var str = '';\n    for (var i = offset; i < size; i++) {\n        str += toChar(array[i]);\n    }\n    return str;\n}\n\nfunction copyrgbe(s, t) {\n    t[0] = s[0];\n    t[1] = s[1];\n    t[2] = s[2];\n    t[3] = s[3];\n}\n\n// TODO : check\nfunction oldReadColors(scan, buffer, offset, xmax) {\n    var rshift = 0, x = 0, len = xmax;\n    while (len > 0) {\n        scan[x][0] = buffer[offset++];\n        scan[x][1] = buffer[offset++];\n        scan[x][2] = buffer[offset++];\n        scan[x][3] = buffer[offset++];\n        if (scan[x][0] === 1 && scan[x][1] === 1 && scan[x][2] === 1) {\n            // exp is count of repeated pixels\n            for (var i = (scan[x][3] << rshift) >>> 0; i > 0; i--) {\n                copyrgbe(scan[x-1], scan[x]);\n                x++;\n                len--;\n            }\n            rshift += 8;\n        } else {\n            x++;\n            len--;\n            rshift = 0;\n        }\n    }\n    return offset;\n}\n\nfunction readColors(scan, buffer, offset, xmax) {\n    if ((xmax < MINELEN) | (xmax > MAXELEN)) {\n        return oldReadColors(scan, buffer, offset, xmax);\n    }\n    var i = buffer[offset++];\n    if (i != 2) {\n        return oldReadColors(scan, buffer, offset - 1, xmax);\n    }\n    scan[0][1] = buffer[offset++];\n    scan[0][2] = buffer[offset++];\n\n    i = buffer[offset++];\n    if ((((scan[0][2] << 8) >>> 0) | i) >>> 0 !== xmax) {\n        return null;\n    }\n    for (var i = 0; i < 4; i++) {\n        for (var x = 0; x < xmax;) {\n            var code = buffer[offset++];\n            if (code > 128) {\n                code = (code & 127) >>> 0;\n                var val = buffer[offset++];\n                while (code--) {\n                    scan[x++][i] = val;\n                }\n            } else {\n                while (code--) {\n                    scan[x++][i] = buffer[offset++];\n                }\n            }\n        }\n    }\n    return offset;\n}\n\n\nvar ret = {\n    // http://www.graphics.cornell.edu/~bjw/rgbe.html\n    // Blender source\n    // http://radsite.lbl.gov/radiance/refer/Notes/picture_format.html\n    parseRGBE: function(arrayBuffer, texture, exposure) {\n        if (exposure == null) {\n            exposure = 0;\n        }\n        var data = new Uint8Array(arrayBuffer);\n        var size = data.length;\n        if (uint82string(data, 0, 2) !== '#?') {\n            return;\n        }\n        // find empty line, next line is resolution info\n        for (var i = 2; i < size; i++) {\n            if (toChar(data[i]) === '\\n' && toChar(data[i+1]) === '\\n') {\n                break;\n            }\n        }\n        if (i >= size) { // not found\n            return;\n        }\n        // find resolution info line\n        i += 2;\n        var str = '';\n        for (; i < size; i++) {\n            var _char = toChar(data[i]);\n            if (_char === '\\n') {\n                break;\n            }\n            str += _char;\n        }\n        // -Y M +X N\n        var tmp = str.split(' ');\n        var height = parseInt(tmp[1]);\n        var width = parseInt(tmp[3]);\n        if (!width || !height) {\n            return;\n        }\n\n        // read and decode actual data\n        var offset = i+1;\n        var scanline = [];\n        // memzero\n        for (var x = 0; x < width; x++) {\n            scanline[x] = [];\n            for (var j = 0; j < 4; j++) {\n                scanline[x][j] = 0;\n            }\n        }\n        var pixels = new Float32Array(width * height * 4);\n        var offset2 = 0;\n        for (var y = 0; y < height; y++) {\n            var offset = readColors(scanline, data, offset, width);\n            if (!offset) {\n                return null;\n            }\n            for (var x = 0; x < width; x++) {\n                rgbe2float(scanline[x], pixels, offset2, exposure);\n                offset2 += 4;\n            }\n        }\n\n        if (!texture) {\n            texture = new Texture2D();\n        }\n        texture.width = width;\n        texture.height = height;\n        texture.pixels = pixels;\n        // HALF_FLOAT can't use Float32Array\n        texture.type = Texture.FLOAT;\n        return texture;\n    },\n\n    parseRGBEFromPNG: function(png) {\n\n    }\n};\n\nexport default ret;\n"],"mappings":";;;;;;AAAA,OAAOA,OAAO,MAAM,YAAY;AAChC,OAAOC,SAAS,MAAM,cAAc;AACpC,IAAIC,MAAM,GAAGC,MAAM,CAACC,YAAY;AAEhC,IAAIC,OAAO,GAAG,CAAC;AACf,IAAIC,OAAO,GAAG,MAAM;AACpB,SAASC,UAAUA,CAACC,IAAI,EAAEC,MAAM,EAAEC,MAAM,EAAEC,QAAQ,EAAE;EAChD,IAAIH,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE;IACb,IAAII,CAAC,GAAGC,IAAI,CAACC,GAAG,CAAC,GAAG,EAAEN,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,GAAG,CAAC,GAAGG,QAAQ,CAAC;IACnDF,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,GAAGF,IAAI,CAAC,CAAC,CAAC,GAAGI,CAAC;IAChCH,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,GAAGF,IAAI,CAAC,CAAC,CAAC,GAAGI,CAAC;IAChCH,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,GAAGF,IAAI,CAAC,CAAC,CAAC,GAAGI,CAAC;EACpC,CAAC,MACI;IACDH,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC;IACtBD,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC;IACtBD,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC;EAC1B;EACAD,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,GAAG,GAAG;EACxB,OAAOD,MAAM;AACjB;AAEA,SAASM,YAAYA,CAACC,KAAK,EAAEN,MAAM,EAAEO,IAAI,EAAE;EACvC,IAAIC,GAAG,GAAG,EAAE;EACZ,KAAK,IAAIC,CAAC,GAAGT,MAAM,EAAES,CAAC,GAAGF,IAAI,EAAEE,CAAC,EAAE,EAAE;IAChCD,GAAG,IAAIhB,MAAM,CAACc,KAAK,CAACG,CAAC,CAAC,CAAC;EAC3B;EACA,OAAOD,GAAG;AACd;AAEA,SAASE,QAAQA,CAACC,CAAC,EAAEC,CAAC,EAAE;EACpBA,CAAC,CAAC,CAAC,CAAC,GAAGD,CAAC,CAAC,CAAC,CAAC;EACXC,CAAC,CAAC,CAAC,CAAC,GAAGD,CAAC,CAAC,CAAC,CAAC;EACXC,CAAC,CAAC,CAAC,CAAC,GAAGD,CAAC,CAAC,CAAC,CAAC;EACXC,CAAC,CAAC,CAAC,CAAC,GAAGD,CAAC,CAAC,CAAC,CAAC;AACf;;AAEA;AACA,SAASE,aAAaA,CAACC,IAAI,EAAEf,MAAM,EAAEC,MAAM,EAAEe,IAAI,EAAE;EAC/C,IAAIC,MAAM,GAAG,CAAC;IAAEC,CAAC,GAAG,CAAC;IAAEC,GAAG,GAAGH,IAAI;EACjC,OAAOG,GAAG,GAAG,CAAC,EAAE;IACZJ,IAAI,CAACG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGlB,MAAM,CAACC,MAAM,EAAE,CAAC;IAC7Bc,IAAI,CAACG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGlB,MAAM,CAACC,MAAM,EAAE,CAAC;IAC7Bc,IAAI,CAACG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGlB,MAAM,CAACC,MAAM,EAAE,CAAC;IAC7Bc,IAAI,CAACG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGlB,MAAM,CAACC,MAAM,EAAE,CAAC;IAC7B,IAAIc,IAAI,CAACG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,IAAIH,IAAI,CAACG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,IAAIH,IAAI,CAACG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;MAC1D;MACA,KAAK,IAAIR,CAAC,GAAIK,IAAI,CAACG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAID,MAAM,KAAM,CAAC,EAAEP,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QACnDC,QAAQ,CAACI,IAAI,CAACG,CAAC,GAAC,CAAC,CAAC,EAAEH,IAAI,CAACG,CAAC,CAAC,CAAC;QAC5BA,CAAC,EAAE;QACHC,GAAG,EAAE;MACT;MACAF,MAAM,IAAI,CAAC;IACf,CAAC,MAAM;MACHC,CAAC,EAAE;MACHC,GAAG,EAAE;MACLF,MAAM,GAAG,CAAC;IACd;EACJ;EACA,OAAOhB,MAAM;AACjB;AAEA,SAASmB,UAAUA,CAACL,IAAI,EAAEf,MAAM,EAAEC,MAAM,EAAEe,IAAI,EAAE;EAC5C,IAAKA,IAAI,GAAGpB,OAAO,GAAKoB,IAAI,GAAGnB,OAAQ,EAAE;IACrC,OAAOiB,aAAa,CAACC,IAAI,EAAEf,MAAM,EAAEC,MAAM,EAAEe,IAAI,CAAC;EACpD;EACA,IAAIN,CAAC,GAAGV,MAAM,CAACC,MAAM,EAAE,CAAC;EACxB,IAAIS,CAAC,IAAI,CAAC,EAAE;IACR,OAAOI,aAAa,CAACC,IAAI,EAAEf,MAAM,EAAEC,MAAM,GAAG,CAAC,EAAEe,IAAI,CAAC;EACxD;EACAD,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGf,MAAM,CAACC,MAAM,EAAE,CAAC;EAC7Bc,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGf,MAAM,CAACC,MAAM,EAAE,CAAC;EAE7BS,CAAC,GAAGV,MAAM,CAACC,MAAM,EAAE,CAAC;EACpB,IAAI,CAAGc,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAM,CAAC,GAAIL,CAAC,MAAM,CAAC,KAAKM,IAAI,EAAE;IAChD,OAAO,IAAI;EACf;EACA,KAAK,IAAIN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IACxB,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,IAAI,GAAG;MACvB,IAAIK,IAAI,GAAGrB,MAAM,CAACC,MAAM,EAAE,CAAC;MAC3B,IAAIoB,IAAI,GAAG,GAAG,EAAE;QACZA,IAAI,GAAG,CAACA,IAAI,GAAG,GAAG,MAAM,CAAC;QACzB,IAAIC,GAAG,GAAGtB,MAAM,CAACC,MAAM,EAAE,CAAC;QAC1B,OAAOoB,IAAI,EAAE,EAAE;UACXN,IAAI,CAACG,CAAC,EAAE,CAAC,CAACR,CAAC,CAAC,GAAGY,GAAG;QACtB;MACJ,CAAC,MAAM;QACH,OAAOD,IAAI,EAAE,EAAE;UACXN,IAAI,CAACG,CAAC,EAAE,CAAC,CAACR,CAAC,CAAC,GAAGV,MAAM,CAACC,MAAM,EAAE,CAAC;QACnC;MACJ;IACJ;EACJ;EACA,OAAOA,MAAM;AACjB;AAGA,IAAIsB,GAAG,GAAG;EACN;EACA;EACA;EACAC,SAAS,EAAE,SAAAA,CAASC,WAAW,EAAEC,OAAO,EAAExB,QAAQ,EAAE;IAChD,IAAIA,QAAQ,IAAI,IAAI,EAAE;MAClBA,QAAQ,GAAG,CAAC;IAChB;IACA,IAAIyB,IAAI,GAAG,IAAIC,UAAU,CAACH,WAAW,CAAC;IACtC,IAAIjB,IAAI,GAAGmB,IAAI,CAACE,MAAM;IACtB,IAAIvB,YAAY,CAACqB,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,EAAE;MACnC;IACJ;IACA;IACA,KAAK,IAAIjB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,IAAI,EAAEE,CAAC,EAAE,EAAE;MAC3B,IAAIjB,MAAM,CAACkC,IAAI,CAACjB,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIjB,MAAM,CAACkC,IAAI,CAACjB,CAAC,GAAC,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;QACxD;MACJ;IACJ;IACA,IAAIA,CAAC,IAAIF,IAAI,EAAE;MAAE;MACb;IACJ;IACA;IACAE,CAAC,IAAI,CAAC;IACN,IAAID,GAAG,GAAG,EAAE;IACZ,OAAOC,CAAC,GAAGF,IAAI,EAAEE,CAAC,EAAE,EAAE;MAClB,IAAIoB,KAAK,GAAGrC,MAAM,CAACkC,IAAI,CAACjB,CAAC,CAAC,CAAC;MAC3B,IAAIoB,KAAK,KAAK,IAAI,EAAE;QAChB;MACJ;MACArB,GAAG,IAAIqB,KAAK;IAChB;IACA;IACA,IAAIC,GAAG,GAAGtB,GAAG,CAACuB,KAAK,CAAC,GAAG,CAAC;IACxB,IAAIC,MAAM,GAAGC,QAAQ,CAACH,GAAG,CAAC,CAAC,CAAC,CAAC;IAC7B,IAAII,KAAK,GAAGD,QAAQ,CAACH,GAAG,CAAC,CAAC,CAAC,CAAC;IAC5B,IAAI,CAACI,KAAK,IAAI,CAACF,MAAM,EAAE;MACnB;IACJ;;IAEA;IACA,IAAIhC,MAAM,GAAGS,CAAC,GAAC,CAAC;IAChB,IAAI0B,QAAQ,GAAG,EAAE;IACjB;IACA,KAAK,IAAIlB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,KAAK,EAAEjB,CAAC,EAAE,EAAE;MAC5BkB,QAAQ,CAAClB,CAAC,CAAC,GAAG,EAAE;MAChB,KAAK,IAAImB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QACxBD,QAAQ,CAAClB,CAAC,CAAC,CAACmB,CAAC,CAAC,GAAG,CAAC;MACtB;IACJ;IACA,IAAIC,MAAM,GAAG,IAAIC,YAAY,CAACJ,KAAK,GAAGF,MAAM,GAAG,CAAC,CAAC;IACjD,IAAIO,OAAO,GAAG,CAAC;IACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,MAAM,EAAEQ,CAAC,EAAE,EAAE;MAC7B,IAAIxC,MAAM,GAAGmB,UAAU,CAACgB,QAAQ,EAAET,IAAI,EAAE1B,MAAM,EAAEkC,KAAK,CAAC;MACtD,IAAI,CAAClC,MAAM,EAAE;QACT,OAAO,IAAI;MACf;MACA,KAAK,IAAIiB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,KAAK,EAAEjB,CAAC,EAAE,EAAE;QAC5BpB,UAAU,CAACsC,QAAQ,CAAClB,CAAC,CAAC,EAAEoB,MAAM,EAAEE,OAAO,EAAEtC,QAAQ,CAAC;QAClDsC,OAAO,IAAI,CAAC;MAChB;IACJ;IAEA,IAAI,CAACd,OAAO,EAAE;MACVA,OAAO,GAAG,IAAIlC,SAAS,CAAC,CAAC;IAC7B;IACAkC,OAAO,CAACS,KAAK,GAAGA,KAAK;IACrBT,OAAO,CAACO,MAAM,GAAGA,MAAM;IACvBP,OAAO,CAACY,MAAM,GAAGA,MAAM;IACvB;IACAZ,OAAO,CAACgB,IAAI,GAAGnD,OAAO,CAACoD,KAAK;IAC5B,OAAOjB,OAAO;EAClB,CAAC;EAEDkB,gBAAgB,EAAE,SAAAA,CAASC,GAAG,EAAE,CAEhC;AACJ,CAAC;AAED,eAAetB,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}