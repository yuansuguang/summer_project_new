{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Base from './core/Base';\nimport util from './core/util';\nimport colorUtil from './core/color';\nvar parseColor = colorUtil.parseToFloat;\nvar programKeyCache = {};\nfunction getDefineCode(defines) {\n  var defineKeys = Object.keys(defines);\n  defineKeys.sort();\n  var defineStr = [];\n  // Custom Defines\n  for (var i = 0; i < defineKeys.length; i++) {\n    var key = defineKeys[i];\n    var value = defines[key];\n    if (value === null) {\n      defineStr.push(key);\n    } else {\n      defineStr.push(key + ' ' + value.toString());\n    }\n  }\n  return defineStr.join('\\n');\n}\nfunction getProgramKey(vertexDefines, fragmentDefines, enabledTextures) {\n  enabledTextures.sort();\n  var defineStr = [];\n  for (var i = 0; i < enabledTextures.length; i++) {\n    var symbol = enabledTextures[i];\n    defineStr.push(symbol);\n  }\n  var key = getDefineCode(vertexDefines) + '\\n' + getDefineCode(fragmentDefines) + '\\n' + defineStr.join('\\n');\n  if (programKeyCache[key]) {\n    return programKeyCache[key];\n  }\n  var id = util.genGUID();\n  programKeyCache[key] = id;\n  return id;\n}\n\n/**\n * Material defines the appearance of mesh surface, like `color`, `roughness`, `metalness`, etc.\n * It contains a {@link clay.Shader} and corresponding uniforms.\n *\n * Here is a basic example to create a standard material\n```js\nvar material = new clay.Material({\n    shader: new clay.Shader(\n        clay.Shader.source('clay.vertex'),\n        clay.Shader.source('clay.fragment')\n    )\n});\n```\n * @constructor clay.Material\n * @extends clay.core.Base\n */\nvar Material = Base.extend(function () {\n  return /** @lends clay.Material# */{\n    /**\n     * @type {string}\n     */\n    name: '',\n    /**\n     * @type {Object}\n     */\n    // uniforms: null,\n\n    /**\n     * @type {clay.Shader}\n     */\n    // shader: null,\n\n    /**\n     * @type {boolean}\n     */\n    depthTest: true,\n    /**\n     * @type {boolean}\n     */\n    depthMask: true,\n    /**\n     * @type {boolean}\n     */\n    transparent: false,\n    /**\n     * Blend func is a callback function when the material\n     * have custom blending\n     * The gl context will be the only argument passed in tho the\n     * blend function\n     * Detail of blend function in WebGL:\n     * http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf\n     *\n     * Example :\n     * function(_gl) {\n     *  _gl.blendEquation(_gl.FUNC_ADD);\n     *  _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA);\n     * }\n     */\n    blend: null,\n    /**\n     * If update texture status automatically.\n     */\n    autoUpdateTextureStatus: true,\n    uniforms: {},\n    vertexDefines: {},\n    fragmentDefines: {},\n    _textureStatus: {},\n    // shadowTransparentMap : null\n\n    // PENDING enable the uniform that only used in shader.\n    _enabledUniforms: null\n  };\n}, function () {\n  if (!this.name) {\n    this.name = 'MATERIAL_' + this.__uid__;\n  }\n  if (this.shader) {\n    // Keep status, mainly preset uniforms, vertexDefines and fragmentDefines\n    this.attachShader(this.shader, true);\n  }\n}, /** @lends clay.Material.prototype */\n{\n  precision: 'highp',\n  /**\n   * Set material uniform\n   * @example\n   *  mat.setUniform('color', [1, 1, 1, 1]);\n   * @param {string} symbol\n   * @param {number|array|clay.Texture|ArrayBufferView} value\n   */\n  setUniform: function (symbol, value) {\n    if (value === undefined) {\n      console.warn('Uniform value \"' + symbol + '\" is undefined');\n    }\n    var uniform = this.uniforms[symbol];\n    if (uniform) {\n      if (typeof value === 'string') {\n        // Try to parse as a color. Invalid color string will return null.\n        value = parseColor(value) || value;\n      }\n      uniform.value = value;\n      if (this.autoUpdateTextureStatus && uniform.type === 't') {\n        if (value) {\n          this.enableTexture(symbol);\n        } else {\n          this.disableTexture(symbol);\n        }\n      }\n    }\n  },\n  /**\n   * @param {Object} obj\n   */\n  setUniforms: function (obj) {\n    for (var key in obj) {\n      var val = obj[key];\n      this.setUniform(key, val);\n    }\n  },\n  /**\n   * @param  {string}  symbol\n   * @return {boolean}\n   */\n  isUniformEnabled: function (symbol) {\n    return this._enabledUniforms.indexOf(symbol) >= 0;\n  },\n  getEnabledUniforms: function () {\n    return this._enabledUniforms;\n  },\n  getTextureUniforms: function () {\n    return this._textureUniforms;\n  },\n  /**\n   * Alias of setUniform and setUniforms\n   * @param {object|string} symbol\n   * @param {number|array|clay.Texture|ArrayBufferView} [value]\n   */\n  set: function (symbol, value) {\n    if (typeof symbol === 'object') {\n      for (var key in symbol) {\n        var val = symbol[key];\n        this.setUniform(key, val);\n      }\n    } else {\n      this.setUniform(symbol, value);\n    }\n  },\n  /**\n   * Get uniform value\n   * @param  {string} symbol\n   * @return {number|array|clay.Texture|ArrayBufferView}\n   */\n  get: function (symbol) {\n    var uniform = this.uniforms[symbol];\n    if (uniform) {\n      return uniform.value;\n    }\n  },\n  /**\n   * Attach a shader instance\n   * @param  {clay.Shader} shader\n   * @param  {boolean} keepStatus If try to keep uniform and texture\n   */\n  attachShader: function (shader, keepStatus) {\n    var originalUniforms = this.uniforms;\n\n    // Ignore if uniform can use in shader.\n    this.uniforms = shader.createUniforms();\n    this.shader = shader;\n    var uniforms = this.uniforms;\n    this._enabledUniforms = Object.keys(uniforms);\n    // Make sure uniforms are set in same order to avoid texture slot wrong\n    this._enabledUniforms.sort();\n    this._textureUniforms = this._enabledUniforms.filter(function (uniformName) {\n      var type = this.uniforms[uniformName].type;\n      return type === 't' || type === 'tv';\n    }, this);\n    var originalVertexDefines = this.vertexDefines;\n    var originalFragmentDefines = this.fragmentDefines;\n    this.vertexDefines = util.clone(shader.vertexDefines);\n    this.fragmentDefines = util.clone(shader.fragmentDefines);\n    if (keepStatus) {\n      for (var symbol in originalUniforms) {\n        if (uniforms[symbol]) {\n          uniforms[symbol].value = originalUniforms[symbol].value;\n        }\n      }\n      util.defaults(this.vertexDefines, originalVertexDefines);\n      util.defaults(this.fragmentDefines, originalFragmentDefines);\n    }\n    var textureStatus = {};\n    for (var key in shader.textures) {\n      textureStatus[key] = {\n        shaderType: shader.textures[key].shaderType,\n        type: shader.textures[key].type,\n        enabled: keepStatus && this._textureStatus[key] ? this._textureStatus[key].enabled : false\n      };\n    }\n    this._textureStatus = textureStatus;\n    this._programKey = '';\n  },\n  /**\n   * Clone a new material and keep uniforms, shader will not be cloned\n   * @return {clay.Material}\n   */\n  clone: function () {\n    var material = new this.constructor({\n      name: this.name,\n      shader: this.shader\n    });\n    for (var symbol in this.uniforms) {\n      material.uniforms[symbol].value = this.uniforms[symbol].value;\n    }\n    material.depthTest = this.depthTest;\n    material.depthMask = this.depthMask;\n    material.transparent = this.transparent;\n    material.blend = this.blend;\n    material.vertexDefines = util.clone(this.vertexDefines);\n    material.fragmentDefines = util.clone(this.fragmentDefines);\n    material.enableTexture(this.getEnabledTextures());\n    material.precision = this.precision;\n    return material;\n  },\n  /**\n   * Add a #define macro in shader code\n   * @param  {string} shaderType Can be vertex, fragment or both\n   * @param  {string} symbol\n   * @param  {number} [val]\n   */\n  define: function (shaderType, symbol, val) {\n    var vertexDefines = this.vertexDefines;\n    var fragmentDefines = this.fragmentDefines;\n    if (shaderType !== 'vertex' && shaderType !== 'fragment' && shaderType !== 'both' && arguments.length < 3) {\n      // shaderType default to be 'both'\n      val = symbol;\n      symbol = shaderType;\n      shaderType = 'both';\n    }\n    val = val != null ? val : null;\n    if (shaderType === 'vertex' || shaderType === 'both') {\n      if (vertexDefines[symbol] !== val) {\n        vertexDefines[symbol] = val;\n        // Mark as dirty\n        this._programKey = '';\n      }\n    }\n    if (shaderType === 'fragment' || shaderType === 'both') {\n      if (fragmentDefines[symbol] !== val) {\n        fragmentDefines[symbol] = val;\n        if (shaderType !== 'both') {\n          this._programKey = '';\n        }\n      }\n    }\n  },\n  /**\n   * Remove a #define macro in shader code\n   * @param  {string} shaderType Can be vertex, fragment or both\n   * @param  {string} symbol\n   */\n  undefine: function (shaderType, symbol) {\n    if (shaderType !== 'vertex' && shaderType !== 'fragment' && shaderType !== 'both' && arguments.length < 2) {\n      // shaderType default to be 'both'\n      symbol = shaderType;\n      shaderType = 'both';\n    }\n    if (shaderType === 'vertex' || shaderType === 'both') {\n      if (this.isDefined('vertex', symbol)) {\n        delete this.vertexDefines[symbol];\n        // Mark as dirty\n        this._programKey = '';\n      }\n    }\n    if (shaderType === 'fragment' || shaderType === 'both') {\n      if (this.isDefined('fragment', symbol)) {\n        delete this.fragmentDefines[symbol];\n        if (shaderType !== 'both') {\n          this._programKey = '';\n        }\n      }\n    }\n  },\n  /**\n   * If macro is defined in shader.\n   * @param  {string} shaderType Can be vertex, fragment or both\n   * @param  {string} symbol\n   */\n  isDefined: function (shaderType, symbol) {\n    // PENDING hasOwnProperty ?\n    switch (shaderType) {\n      case 'vertex':\n        return this.vertexDefines[symbol] !== undefined;\n      case 'fragment':\n        return this.fragmentDefines[symbol] !== undefined;\n    }\n  },\n  /**\n   * Get macro value defined in shader.\n   * @param  {string} shaderType Can be vertex, fragment or both\n   * @param  {string} symbol\n   */\n  getDefine: function (shaderType, symbol) {\n    switch (shaderType) {\n      case 'vertex':\n        return this.vertexDefines[symbol];\n      case 'fragment':\n        return this.fragmentDefines[symbol];\n    }\n  },\n  /**\n   * Enable a texture, actually it will add a #define macro in the shader code\n   * For example, if texture symbol is diffuseMap, it will add a line `#define DIFFUSEMAP_ENABLED` in the shader code\n   * @param  {string} symbol\n   */\n  enableTexture: function (symbol) {\n    if (Array.isArray(symbol)) {\n      for (var i = 0; i < symbol.length; i++) {\n        this.enableTexture(symbol[i]);\n      }\n      return;\n    }\n    var status = this._textureStatus[symbol];\n    if (status) {\n      var isEnabled = status.enabled;\n      if (!isEnabled) {\n        status.enabled = true;\n        this._programKey = '';\n      }\n    }\n  },\n  /**\n   * Enable all textures used in the shader\n   */\n  enableTexturesAll: function () {\n    var textureStatus = this._textureStatus;\n    for (var symbol in textureStatus) {\n      textureStatus[symbol].enabled = true;\n    }\n    this._programKey = '';\n  },\n  /**\n   * Disable a texture, it remove a #define macro in the shader\n   * @param  {string} symbol\n   */\n  disableTexture: function (symbol) {\n    if (Array.isArray(symbol)) {\n      for (var i = 0; i < symbol.length; i++) {\n        this.disableTexture(symbol[i]);\n      }\n      return;\n    }\n    var status = this._textureStatus[symbol];\n    if (status) {\n      var isDisabled = !status.enabled;\n      if (!isDisabled) {\n        status.enabled = false;\n        this._programKey = '';\n      }\n    }\n  },\n  /**\n   * Disable all textures used in the shader\n   */\n  disableTexturesAll: function () {\n    var textureStatus = this._textureStatus;\n    for (var symbol in textureStatus) {\n      textureStatus[symbol].enabled = false;\n    }\n    this._programKey = '';\n  },\n  /**\n   * If texture of given type is enabled.\n   * @param  {string}  symbol\n   * @return {boolean}\n   */\n  isTextureEnabled: function (symbol) {\n    var textureStatus = this._textureStatus;\n    return !!textureStatus[symbol] && textureStatus[symbol].enabled;\n  },\n  /**\n   * Get all enabled textures\n   * @return {string[]}\n   */\n  getEnabledTextures: function () {\n    var enabledTextures = [];\n    var textureStatus = this._textureStatus;\n    for (var symbol in textureStatus) {\n      if (textureStatus[symbol].enabled) {\n        enabledTextures.push(symbol);\n      }\n    }\n    return enabledTextures;\n  },\n  /**\n   * Mark defines are updated.\n   */\n  dirtyDefines: function () {\n    this._programKey = '';\n  },\n  getProgramKey: function () {\n    if (!this._programKey) {\n      this._programKey = getProgramKey(this.vertexDefines, this.fragmentDefines, this.getEnabledTextures());\n    }\n    return this._programKey;\n  }\n});\nexport default Material;","map":{"version":3,"names":["Base","util","colorUtil","parseColor","parseToFloat","programKeyCache","getDefineCode","defines","defineKeys","Object","keys","sort","defineStr","i","length","key","value","push","toString","join","getProgramKey","vertexDefines","fragmentDefines","enabledTextures","symbol","id","genGUID","Material","extend","name","depthTest","depthMask","transparent","blend","autoUpdateTextureStatus","uniforms","_textureStatus","_enabledUniforms","__uid__","shader","attachShader","precision","setUniform","undefined","console","warn","uniform","type","enableTexture","disableTexture","setUniforms","obj","val","isUniformEnabled","indexOf","getEnabledUniforms","getTextureUniforms","_textureUniforms","set","get","keepStatus","originalUniforms","createUniforms","filter","uniformName","originalVertexDefines","originalFragmentDefines","clone","defaults","textureStatus","textures","shaderType","enabled","_programKey","material","constructor","getEnabledTextures","define","arguments","undefine","isDefined","getDefine","Array","isArray","status","isEnabled","enableTexturesAll","isDisabled","disableTexturesAll","isTextureEnabled","dirtyDefines"],"sources":["E:/QuestionairePlanet_Fronted/mytest/node_modules/claygl/src/Material.js"],"sourcesContent":["import Base from './core/Base';\nimport util from './core/util';\nimport colorUtil from './core/color';\nvar parseColor = colorUtil.parseToFloat;\n\nvar programKeyCache = {};\n\nfunction getDefineCode(defines) {\n    var defineKeys = Object.keys(defines);\n    defineKeys.sort();\n    var defineStr = [];\n    // Custom Defines\n    for (var i = 0; i < defineKeys.length; i++) {\n        var key = defineKeys[i];\n        var value = defines[key];\n        if (value === null) {\n            defineStr.push(key);\n        }\n        else{\n            defineStr.push(key + ' ' + value.toString());\n        }\n    }\n    return defineStr.join('\\n');\n}\n\nfunction getProgramKey(vertexDefines, fragmentDefines, enabledTextures) {\n    enabledTextures.sort();\n    var defineStr = [];\n    for (var i = 0; i < enabledTextures.length; i++) {\n        var symbol = enabledTextures[i];\n        defineStr.push(symbol);\n    }\n    var key = getDefineCode(vertexDefines) + '\\n'\n        + getDefineCode(fragmentDefines) + '\\n'\n        + defineStr.join('\\n');\n\n    if (programKeyCache[key]) {\n        return programKeyCache[key];\n    }\n\n    var id = util.genGUID();\n    programKeyCache[key] = id;\n    return id;\n}\n\n/**\n * Material defines the appearance of mesh surface, like `color`, `roughness`, `metalness`, etc.\n * It contains a {@link clay.Shader} and corresponding uniforms.\n *\n * Here is a basic example to create a standard material\n```js\nvar material = new clay.Material({\n    shader: new clay.Shader(\n        clay.Shader.source('clay.vertex'),\n        clay.Shader.source('clay.fragment')\n    )\n});\n```\n * @constructor clay.Material\n * @extends clay.core.Base\n */\nvar Material = Base.extend(function () {\n    return /** @lends clay.Material# */ {\n        /**\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * @type {Object}\n         */\n        // uniforms: null,\n\n        /**\n         * @type {clay.Shader}\n         */\n        // shader: null,\n\n        /**\n         * @type {boolean}\n         */\n        depthTest: true,\n\n        /**\n         * @type {boolean}\n         */\n        depthMask: true,\n\n        /**\n         * @type {boolean}\n         */\n        transparent: false,\n        /**\n         * Blend func is a callback function when the material\n         * have custom blending\n         * The gl context will be the only argument passed in tho the\n         * blend function\n         * Detail of blend function in WebGL:\n         * http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf\n         *\n         * Example :\n         * function(_gl) {\n         *  _gl.blendEquation(_gl.FUNC_ADD);\n         *  _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA);\n         * }\n         */\n        blend: null,\n\n        /**\n         * If update texture status automatically.\n         */\n        autoUpdateTextureStatus: true,\n\n        uniforms: {},\n        vertexDefines: {},\n        fragmentDefines: {},\n        _textureStatus: {},\n\n        // shadowTransparentMap : null\n\n        // PENDING enable the uniform that only used in shader.\n        _enabledUniforms: null,\n    };\n}, function () {\n    if (!this.name) {\n        this.name = 'MATERIAL_' + this.__uid__;\n    }\n\n    if (this.shader) {\n        // Keep status, mainly preset uniforms, vertexDefines and fragmentDefines\n        this.attachShader(this.shader, true);\n    }\n},\n/** @lends clay.Material.prototype */\n{\n    precision: 'highp',\n\n    /**\n     * Set material uniform\n     * @example\n     *  mat.setUniform('color', [1, 1, 1, 1]);\n     * @param {string} symbol\n     * @param {number|array|clay.Texture|ArrayBufferView} value\n     */\n    setUniform: function (symbol, value) {\n        if (value === undefined) {\n            console.warn('Uniform value \"' + symbol + '\" is undefined');\n        }\n        var uniform = this.uniforms[symbol];\n        if (uniform) {\n\n            if (typeof value === 'string') {\n                // Try to parse as a color. Invalid color string will return null.\n                value = parseColor(value) || value;\n            }\n\n            uniform.value = value;\n\n            if (this.autoUpdateTextureStatus && uniform.type === 't') {\n                if (value) {\n                    this.enableTexture(symbol);\n                }\n                else {\n                    this.disableTexture(symbol);\n                }\n            }\n        }\n    },\n\n    /**\n     * @param {Object} obj\n     */\n    setUniforms: function(obj) {\n        for (var key in obj) {\n            var val = obj[key];\n            this.setUniform(key, val);\n        }\n    },\n\n    /**\n     * @param  {string}  symbol\n     * @return {boolean}\n     */\n    isUniformEnabled: function (symbol) {\n        return this._enabledUniforms.indexOf(symbol) >= 0;\n    },\n\n    getEnabledUniforms: function () {\n        return this._enabledUniforms;\n    },\n    getTextureUniforms: function () {\n        return this._textureUniforms;\n    },\n\n    /**\n     * Alias of setUniform and setUniforms\n     * @param {object|string} symbol\n     * @param {number|array|clay.Texture|ArrayBufferView} [value]\n     */\n    set: function (symbol, value) {\n        if (typeof(symbol) === 'object') {\n            for (var key in symbol) {\n                var val = symbol[key];\n                this.setUniform(key, val);\n            }\n        }\n        else {\n            this.setUniform(symbol, value);\n        }\n    },\n    /**\n     * Get uniform value\n     * @param  {string} symbol\n     * @return {number|array|clay.Texture|ArrayBufferView}\n     */\n    get: function (symbol) {\n        var uniform = this.uniforms[symbol];\n        if (uniform) {\n            return uniform.value;\n        }\n    },\n    /**\n     * Attach a shader instance\n     * @param  {clay.Shader} shader\n     * @param  {boolean} keepStatus If try to keep uniform and texture\n     */\n    attachShader: function(shader, keepStatus) {\n        var originalUniforms = this.uniforms;\n\n        // Ignore if uniform can use in shader.\n        this.uniforms = shader.createUniforms();\n        this.shader = shader;\n\n        var uniforms = this.uniforms;\n        this._enabledUniforms = Object.keys(uniforms);\n        // Make sure uniforms are set in same order to avoid texture slot wrong\n        this._enabledUniforms.sort();\n        this._textureUniforms = this._enabledUniforms.filter(function (uniformName) {\n            var type = this.uniforms[uniformName].type;\n            return type === 't' || type === 'tv';\n        }, this);\n\n        var originalVertexDefines = this.vertexDefines;\n        var originalFragmentDefines = this.fragmentDefines;\n\n        this.vertexDefines = util.clone(shader.vertexDefines);\n        this.fragmentDefines = util.clone(shader.fragmentDefines);\n\n        if (keepStatus) {\n            for (var symbol in originalUniforms) {\n                if (uniforms[symbol]) {\n                    uniforms[symbol].value = originalUniforms[symbol].value;\n                }\n            }\n\n            util.defaults(this.vertexDefines, originalVertexDefines);\n            util.defaults(this.fragmentDefines, originalFragmentDefines);\n        }\n\n        var textureStatus = {};\n        for (var key in shader.textures) {\n            textureStatus[key] = {\n                shaderType: shader.textures[key].shaderType,\n                type: shader.textures[key].type,\n                enabled: (keepStatus && this._textureStatus[key]) ? this._textureStatus[key].enabled : false\n            };\n        }\n\n        this._textureStatus = textureStatus;\n\n        this._programKey = '';\n    },\n\n    /**\n     * Clone a new material and keep uniforms, shader will not be cloned\n     * @return {clay.Material}\n     */\n    clone: function () {\n        var material = new this.constructor({\n            name: this.name,\n            shader: this.shader\n        });\n        for (var symbol in this.uniforms) {\n            material.uniforms[symbol].value = this.uniforms[symbol].value;\n        }\n        material.depthTest = this.depthTest;\n        material.depthMask = this.depthMask;\n        material.transparent = this.transparent;\n        material.blend = this.blend;\n\n        material.vertexDefines = util.clone(this.vertexDefines);\n        material.fragmentDefines = util.clone(this.fragmentDefines);\n        material.enableTexture(this.getEnabledTextures());\n        material.precision = this.precision;\n\n        return material;\n    },\n\n    /**\n     * Add a #define macro in shader code\n     * @param  {string} shaderType Can be vertex, fragment or both\n     * @param  {string} symbol\n     * @param  {number} [val]\n     */\n    define: function (shaderType, symbol, val) {\n        var vertexDefines = this.vertexDefines;\n        var fragmentDefines = this.fragmentDefines;\n        if (shaderType !== 'vertex' && shaderType !== 'fragment' && shaderType !== 'both'\n            && arguments.length < 3\n        ) {\n            // shaderType default to be 'both'\n            val = symbol;\n            symbol = shaderType;\n            shaderType = 'both';\n        }\n        val = val != null ? val : null;\n        if (shaderType === 'vertex' || shaderType === 'both') {\n            if (vertexDefines[symbol] !== val) {\n                vertexDefines[symbol] = val;\n                // Mark as dirty\n                this._programKey = '';\n            }\n        }\n        if (shaderType === 'fragment' || shaderType === 'both') {\n            if (fragmentDefines[symbol] !== val) {\n                fragmentDefines[symbol] = val;\n                if (shaderType !== 'both') {\n                    this._programKey = '';\n                }\n            }\n        }\n    },\n\n    /**\n     * Remove a #define macro in shader code\n     * @param  {string} shaderType Can be vertex, fragment or both\n     * @param  {string} symbol\n     */\n    undefine: function (shaderType, symbol) {\n        if (shaderType !== 'vertex' && shaderType !== 'fragment' && shaderType !== 'both'\n            && arguments.length < 2\n        ) {\n            // shaderType default to be 'both'\n            symbol = shaderType;\n            shaderType = 'both';\n        }\n        if (shaderType === 'vertex' || shaderType === 'both') {\n            if (this.isDefined('vertex', symbol)) {\n                delete this.vertexDefines[symbol];\n                // Mark as dirty\n                this._programKey = '';\n            }\n        }\n        if (shaderType === 'fragment' || shaderType === 'both') {\n            if (this.isDefined('fragment', symbol)) {\n                delete this.fragmentDefines[symbol];\n                if (shaderType !== 'both') {\n                    this._programKey = '';\n                }\n            }\n        }\n    },\n\n    /**\n     * If macro is defined in shader.\n     * @param  {string} shaderType Can be vertex, fragment or both\n     * @param  {string} symbol\n     */\n    isDefined: function (shaderType, symbol) {\n        // PENDING hasOwnProperty ?\n        switch (shaderType) {\n            case 'vertex':\n                return this.vertexDefines[symbol] !== undefined;\n            case 'fragment':\n                return this.fragmentDefines[symbol] !== undefined;\n        }\n    },\n    /**\n     * Get macro value defined in shader.\n     * @param  {string} shaderType Can be vertex, fragment or both\n     * @param  {string} symbol\n     */\n    getDefine: function (shaderType, symbol) {\n        switch(shaderType) {\n            case 'vertex':\n                return this.vertexDefines[symbol];\n            case 'fragment':\n                return this.fragmentDefines[symbol];\n        }\n    },\n    /**\n     * Enable a texture, actually it will add a #define macro in the shader code\n     * For example, if texture symbol is diffuseMap, it will add a line `#define DIFFUSEMAP_ENABLED` in the shader code\n     * @param  {string} symbol\n     */\n    enableTexture: function (symbol) {\n        if (Array.isArray(symbol)) {\n            for (var i = 0; i < symbol.length; i++) {\n                this.enableTexture(symbol[i]);\n            }\n            return;\n        }\n\n        var status = this._textureStatus[symbol];\n        if (status) {\n            var isEnabled = status.enabled;\n            if (!isEnabled) {\n                status.enabled = true;\n                this._programKey = '';\n            }\n        }\n    },\n    /**\n     * Enable all textures used in the shader\n     */\n    enableTexturesAll: function () {\n        var textureStatus = this._textureStatus;\n        for (var symbol in textureStatus) {\n            textureStatus[symbol].enabled = true;\n        }\n\n        this._programKey = '';\n    },\n    /**\n     * Disable a texture, it remove a #define macro in the shader\n     * @param  {string} symbol\n     */\n    disableTexture: function (symbol) {\n        if (Array.isArray(symbol)) {\n            for (var i = 0; i < symbol.length; i++) {\n                this.disableTexture(symbol[i]);\n            }\n            return;\n        }\n\n        var status = this._textureStatus[symbol];\n        if (status) {\n            var isDisabled = ! status.enabled;\n            if (!isDisabled) {\n                status.enabled = false;\n                this._programKey = '';\n            }\n        }\n    },\n    /**\n     * Disable all textures used in the shader\n     */\n    disableTexturesAll: function () {\n        var textureStatus = this._textureStatus;\n        for (var symbol in textureStatus) {\n            textureStatus[symbol].enabled = false;\n        }\n\n        this._programKey = '';\n    },\n    /**\n     * If texture of given type is enabled.\n     * @param  {string}  symbol\n     * @return {boolean}\n     */\n    isTextureEnabled: function (symbol) {\n        var textureStatus = this._textureStatus;\n        return !!textureStatus[symbol]\n            && textureStatus[symbol].enabled;\n    },\n\n    /**\n     * Get all enabled textures\n     * @return {string[]}\n     */\n    getEnabledTextures: function () {\n        var enabledTextures = [];\n        var textureStatus = this._textureStatus;\n        for (var symbol in textureStatus) {\n            if (textureStatus[symbol].enabled) {\n                enabledTextures.push(symbol);\n            }\n        }\n        return enabledTextures;\n    },\n\n    /**\n     * Mark defines are updated.\n     */\n    dirtyDefines: function () {\n        this._programKey = '';\n    },\n\n    getProgramKey: function () {\n        if (!this._programKey) {\n            this._programKey = getProgramKey(\n                this.vertexDefines, this.fragmentDefines, this.getEnabledTextures()\n            );\n        }\n        return this._programKey;\n    }\n});\n\nexport default Material;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}