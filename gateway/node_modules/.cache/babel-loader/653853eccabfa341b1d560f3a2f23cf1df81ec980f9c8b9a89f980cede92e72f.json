{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Base from '../core/Base';\n\n// PENDING\n// Use topological sort ?\n\n/**\n * Node of graph based post processing.\n *\n * @constructor clay.compositor.CompositorNode\n * @extends clay.core.Base\n *\n */\nvar CompositorNode = Base.extend(function () {\n  return /** @lends clay.compositor.CompositorNode# */{\n    /**\n     * @type {string}\n     */\n    name: '',\n    /**\n     * Input links, will be updated by the graph\n     * @example:\n     *     inputName: {\n     *         node: someNode,\n     *         pin: 'xxxx'\n     *     }\n     * @type {Object}\n     */\n    inputLinks: {},\n    /**\n     * Output links, will be updated by the graph\n     * @example:\n     *     outputName: {\n     *         node: someNode,\n     *         pin: 'xxxx'\n     *     }\n     * @type {Object}\n     */\n    outputLinks: {},\n    // Save the output texture of previous frame\n    // Will be used when there exist a circular reference\n    _prevOutputTextures: {},\n    _outputTextures: {},\n    // Example: { name: 2 }\n    _outputReferences: {},\n    _rendering: false,\n    // If rendered in this frame\n    _rendered: false,\n    _compositor: null\n  };\n}, /** @lends clay.compositor.CompositorNode.prototype */\n{\n  // TODO Remove parameter function callback\n  updateParameter: function (outputName, renderer) {\n    var outputInfo = this.outputs[outputName];\n    var parameters = outputInfo.parameters;\n    var parametersCopy = outputInfo._parametersCopy;\n    if (!parametersCopy) {\n      parametersCopy = outputInfo._parametersCopy = {};\n    }\n    if (parameters) {\n      for (var key in parameters) {\n        if (key !== 'width' && key !== 'height') {\n          parametersCopy[key] = parameters[key];\n        }\n      }\n    }\n    var width, height;\n    if (parameters.width instanceof Function) {\n      width = parameters.width.call(this, renderer);\n    } else {\n      width = parameters.width;\n    }\n    if (parameters.height instanceof Function) {\n      height = parameters.height.call(this, renderer);\n    } else {\n      height = parameters.height;\n    }\n    if (parametersCopy.width !== width || parametersCopy.height !== height) {\n      if (this._outputTextures[outputName]) {\n        this._outputTextures[outputName].dispose(renderer.gl);\n      }\n    }\n    parametersCopy.width = width;\n    parametersCopy.height = height;\n    return parametersCopy;\n  },\n  /**\n   * Set parameter\n   * @param {string} name\n   * @param {} value\n   */\n  setParameter: function (name, value) {},\n  /**\n   * Get parameter value\n   * @param  {string} name\n   * @return {}\n   */\n  getParameter: function (name) {},\n  /**\n   * Set parameters\n   * @param {Object} obj\n   */\n  setParameters: function (obj) {\n    for (var name in obj) {\n      this.setParameter(name, obj[name]);\n    }\n  },\n  render: function () {},\n  getOutput: function (renderer /*optional*/, name) {\n    if (name == null) {\n      // Return the output texture without rendering\n      name = renderer;\n      return this._outputTextures[name];\n    }\n    var outputInfo = this.outputs[name];\n    if (!outputInfo) {\n      return;\n    }\n\n    // Already been rendered in this frame\n    if (this._rendered) {\n      // Force return texture in last frame\n      if (outputInfo.outputLastFrame) {\n        return this._prevOutputTextures[name];\n      } else {\n        return this._outputTextures[name];\n      }\n    } else if (\n    // TODO\n    this._rendering // Solve Circular Reference\n    ) {\n      if (!this._prevOutputTextures[name]) {\n        // Create a blank texture at first pass\n        this._prevOutputTextures[name] = this._compositor.allocateTexture(outputInfo.parameters || {});\n      }\n      return this._prevOutputTextures[name];\n    }\n    this.render(renderer);\n    return this._outputTextures[name];\n  },\n  removeReference: function (outputName) {\n    this._outputReferences[outputName]--;\n    if (this._outputReferences[outputName] === 0) {\n      var outputInfo = this.outputs[outputName];\n      if (outputInfo.keepLastFrame) {\n        if (this._prevOutputTextures[outputName]) {\n          this._compositor.releaseTexture(this._prevOutputTextures[outputName]);\n        }\n        this._prevOutputTextures[outputName] = this._outputTextures[outputName];\n      } else {\n        // Output of this node have alreay been used by all other nodes\n        // Put the texture back to the pool.\n        this._compositor.releaseTexture(this._outputTextures[outputName]);\n      }\n    }\n  },\n  link: function (inputPinName, fromNode, fromPinName) {\n    // The relationship from output pin to input pin is one-on-multiple\n    this.inputLinks[inputPinName] = {\n      node: fromNode,\n      pin: fromPinName\n    };\n    if (!fromNode.outputLinks[fromPinName]) {\n      fromNode.outputLinks[fromPinName] = [];\n    }\n    fromNode.outputLinks[fromPinName].push({\n      node: this,\n      pin: inputPinName\n    });\n\n    // Enabled the pin texture in shader\n    this.pass.material.enableTexture(inputPinName);\n  },\n  clear: function () {\n    this.inputLinks = {};\n    this.outputLinks = {};\n  },\n  updateReference: function (outputName) {\n    if (!this._rendering) {\n      this._rendering = true;\n      for (var inputName in this.inputLinks) {\n        var link = this.inputLinks[inputName];\n        link.node.updateReference(link.pin);\n      }\n      this._rendering = false;\n    }\n    if (outputName) {\n      this._outputReferences[outputName]++;\n    }\n  },\n  beforeFrame: function () {\n    this._rendered = false;\n    for (var name in this.outputLinks) {\n      this._outputReferences[name] = 0;\n    }\n  },\n  afterFrame: function () {\n    // Put back all the textures to pool\n    for (var name in this.outputLinks) {\n      if (this._outputReferences[name] > 0) {\n        var outputInfo = this.outputs[name];\n        if (outputInfo.keepLastFrame) {\n          if (this._prevOutputTextures[name]) {\n            this._compositor.releaseTexture(this._prevOutputTextures[name]);\n          }\n          this._prevOutputTextures[name] = this._outputTextures[name];\n        } else {\n          this._compositor.releaseTexture(this._outputTextures[name]);\n        }\n      }\n    }\n  }\n});\nexport default CompositorNode;","map":{"version":3,"names":["Base","CompositorNode","extend","name","inputLinks","outputLinks","_prevOutputTextures","_outputTextures","_outputReferences","_rendering","_rendered","_compositor","updateParameter","outputName","renderer","outputInfo","outputs","parameters","parametersCopy","_parametersCopy","key","width","height","Function","call","dispose","gl","setParameter","value","getParameter","setParameters","obj","render","getOutput","outputLastFrame","allocateTexture","removeReference","keepLastFrame","releaseTexture","link","inputPinName","fromNode","fromPinName","node","pin","push","pass","material","enableTexture","clear","updateReference","inputName","beforeFrame","afterFrame"],"sources":["E:/QuestionairePlanet_Fronted/mytest/node_modules/claygl/src/compositor/CompositorNode.js"],"sourcesContent":["import Base from '../core/Base';\n\n// PENDING\n// Use topological sort ?\n\n/**\n * Node of graph based post processing.\n *\n * @constructor clay.compositor.CompositorNode\n * @extends clay.core.Base\n *\n */\nvar CompositorNode = Base.extend(function () {\n    return /** @lends clay.compositor.CompositorNode# */ {\n        /**\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * Input links, will be updated by the graph\n         * @example:\n         *     inputName: {\n         *         node: someNode,\n         *         pin: 'xxxx'\n         *     }\n         * @type {Object}\n         */\n        inputLinks: {},\n\n        /**\n         * Output links, will be updated by the graph\n         * @example:\n         *     outputName: {\n         *         node: someNode,\n         *         pin: 'xxxx'\n         *     }\n         * @type {Object}\n         */\n        outputLinks: {},\n\n        // Save the output texture of previous frame\n        // Will be used when there exist a circular reference\n        _prevOutputTextures: {},\n        _outputTextures: {},\n\n        // Example: { name: 2 }\n        _outputReferences: {},\n\n        _rendering: false,\n        // If rendered in this frame\n        _rendered: false,\n\n        _compositor: null\n    };\n},\n/** @lends clay.compositor.CompositorNode.prototype */\n{\n\n    // TODO Remove parameter function callback\n    updateParameter: function (outputName, renderer) {\n        var outputInfo = this.outputs[outputName];\n        var parameters = outputInfo.parameters;\n        var parametersCopy = outputInfo._parametersCopy;\n        if (!parametersCopy) {\n            parametersCopy = outputInfo._parametersCopy = {};\n        }\n        if (parameters) {\n            for (var key in parameters) {\n                if (key !== 'width' && key !== 'height') {\n                    parametersCopy[key] = parameters[key];\n                }\n            }\n        }\n        var width, height;\n        if (parameters.width instanceof Function) {\n            width = parameters.width.call(this, renderer);\n        }\n        else {\n            width = parameters.width;\n        }\n        if (parameters.height instanceof Function) {\n            height = parameters.height.call(this, renderer);\n        }\n        else {\n            height = parameters.height;\n        }\n        if (\n            parametersCopy.width !== width\n            || parametersCopy.height !== height\n        ) {\n            if (this._outputTextures[outputName]) {\n                this._outputTextures[outputName].dispose(renderer.gl);\n            }\n        }\n        parametersCopy.width = width;\n        parametersCopy.height = height;\n\n        return parametersCopy;\n    },\n\n    /**\n     * Set parameter\n     * @param {string} name\n     * @param {} value\n     */\n    setParameter: function (name, value) {},\n    /**\n     * Get parameter value\n     * @param  {string} name\n     * @return {}\n     */\n    getParameter: function (name) {},\n    /**\n     * Set parameters\n     * @param {Object} obj\n     */\n    setParameters: function (obj) {\n        for (var name in obj) {\n            this.setParameter(name, obj[name]);\n        }\n    },\n\n    render: function () {},\n\n    getOutput: function (renderer /*optional*/, name) {\n        if (name == null) {\n            // Return the output texture without rendering\n            name = renderer;\n            return this._outputTextures[name];\n        }\n        var outputInfo = this.outputs[name];\n        if (!outputInfo) {\n            return ;\n        }\n\n        // Already been rendered in this frame\n        if (this._rendered) {\n            // Force return texture in last frame\n            if (outputInfo.outputLastFrame) {\n                return this._prevOutputTextures[name];\n            }\n            else {\n                return this._outputTextures[name];\n            }\n        }\n        else if (\n            // TODO\n            this._rendering   // Solve Circular Reference\n        ) {\n            if (!this._prevOutputTextures[name]) {\n                // Create a blank texture at first pass\n                this._prevOutputTextures[name] = this._compositor.allocateTexture(outputInfo.parameters || {});\n            }\n            return this._prevOutputTextures[name];\n        }\n\n        this.render(renderer);\n\n        return this._outputTextures[name];\n    },\n\n    removeReference: function (outputName) {\n        this._outputReferences[outputName]--;\n        if (this._outputReferences[outputName] === 0) {\n            var outputInfo = this.outputs[outputName];\n            if (outputInfo.keepLastFrame) {\n                if (this._prevOutputTextures[outputName]) {\n                    this._compositor.releaseTexture(this._prevOutputTextures[outputName]);\n                }\n                this._prevOutputTextures[outputName] = this._outputTextures[outputName];\n            }\n            else {\n                // Output of this node have alreay been used by all other nodes\n                // Put the texture back to the pool.\n                this._compositor.releaseTexture(this._outputTextures[outputName]);\n            }\n        }\n    },\n\n    link: function (inputPinName, fromNode, fromPinName) {\n\n        // The relationship from output pin to input pin is one-on-multiple\n        this.inputLinks[inputPinName] = {\n            node: fromNode,\n            pin: fromPinName\n        };\n        if (!fromNode.outputLinks[fromPinName]) {\n            fromNode.outputLinks[fromPinName] = [];\n        }\n        fromNode.outputLinks[fromPinName].push({\n            node: this,\n            pin: inputPinName\n        });\n\n        // Enabled the pin texture in shader\n        this.pass.material.enableTexture(inputPinName);\n    },\n\n    clear: function () {\n        this.inputLinks = {};\n        this.outputLinks = {};\n    },\n\n    updateReference: function (outputName) {\n        if (!this._rendering) {\n            this._rendering = true;\n            for (var inputName in this.inputLinks) {\n                var link = this.inputLinks[inputName];\n                link.node.updateReference(link.pin);\n            }\n            this._rendering = false;\n        }\n        if (outputName) {\n            this._outputReferences[outputName] ++;\n        }\n    },\n\n    beforeFrame: function () {\n        this._rendered = false;\n\n        for (var name in this.outputLinks) {\n            this._outputReferences[name] = 0;\n        }\n    },\n\n    afterFrame: function () {\n        // Put back all the textures to pool\n        for (var name in this.outputLinks) {\n            if (this._outputReferences[name] > 0) {\n                var outputInfo = this.outputs[name];\n                if (outputInfo.keepLastFrame) {\n                    if (this._prevOutputTextures[name]) {\n                        this._compositor.releaseTexture(this._prevOutputTextures[name]);\n                    }\n                    this._prevOutputTextures[name] = this._outputTextures[name];\n                }\n                else {\n                    this._compositor.releaseTexture(this._outputTextures[name]);\n                }\n            }\n        }\n    }\n});\n\nexport default CompositorNode;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}