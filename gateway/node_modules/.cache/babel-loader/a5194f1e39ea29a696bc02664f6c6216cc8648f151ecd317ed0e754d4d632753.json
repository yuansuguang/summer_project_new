{"ast":null,"code":"import glmatrix from 'claygl/src/dep/glmatrix';\nvar vec3 = glmatrix.vec3;\nfunction Globe(radius) {\n  this.radius = radius;\n  this.viewGL = null;\n  this.altitudeAxis; // Displacement data provided by texture.\n\n  this.displacementData = null;\n  this.displacementWidth;\n  this.displacementHeight;\n}\nGlobe.prototype = {\n  constructor: Globe,\n  dimensions: ['lng', 'lat', 'alt'],\n  type: 'globe',\n  containPoint: function () {},\n  setDisplacementData: function (data, width, height) {\n    this.displacementData = data;\n    this.displacementWidth = width;\n    this.displacementHeight = height;\n  },\n  _getDisplacementScale: function (lng, lat) {\n    var i = (lng + 180) / 360 * (this.displacementWidth - 1);\n    var j = (90 - lat) / 180 * (this.displacementHeight - 1); // NEAREST SAMPLING\n    // TODO Better bilinear sampling\n\n    var idx = Math.round(i) + Math.round(j) * this.displacementWidth;\n    return this.displacementData[idx];\n  },\n  dataToPoint: function (data, out) {\n    var lng = data[0];\n    var lat = data[1]; // Default have 0 altitude\n\n    var altVal = data[2] || 0;\n    var r = this.radius;\n    if (this.displacementData) {\n      r *= 1 + this._getDisplacementScale(lng, lat);\n    }\n    if (this.altitudeAxis) {\n      r += this.altitudeAxis.dataToCoord(altVal);\n    }\n    lng = lng * Math.PI / 180;\n    lat = lat * Math.PI / 180;\n    var r0 = Math.cos(lat) * r;\n    out = out || []; // PENDING\n\n    out[0] = -r0 * Math.cos(lng + Math.PI);\n    out[1] = Math.sin(lat) * r;\n    out[2] = r0 * Math.sin(lng + Math.PI);\n    return out;\n  },\n  pointToData: function (point, out) {\n    var x = point[0];\n    var y = point[1];\n    var z = point[2];\n    var len = vec3.len(point);\n    x /= len;\n    y /= len;\n    z /= len;\n    var theta = Math.asin(y);\n    var phi = Math.atan2(z, -x);\n    if (phi < 0) {\n      phi = Math.PI * 2 + phi;\n    }\n    var lat = theta * 180 / Math.PI;\n    var lng = phi * 180 / Math.PI - 180;\n    out = out || [];\n    out[0] = lng;\n    out[1] = lat;\n    out[2] = len - this.radius;\n    if (this.altitudeAxis) {\n      out[2] = this.altitudeAxis.coordToData(out[2]);\n    }\n    return out;\n  }\n};\nexport default Globe;","map":{"version":3,"names":["glmatrix","vec3","Globe","radius","viewGL","altitudeAxis","displacementData","displacementWidth","displacementHeight","prototype","constructor","dimensions","type","containPoint","setDisplacementData","data","width","height","_getDisplacementScale","lng","lat","i","j","idx","Math","round","dataToPoint","out","altVal","r","dataToCoord","PI","r0","cos","sin","pointToData","point","x","y","z","len","theta","asin","phi","atan2","coordToData"],"sources":["E:/mytest/node_modules/echarts-gl/lib/coord/globe/Globe.js"],"sourcesContent":["import glmatrix from 'claygl/src/dep/glmatrix';\nvar vec3 = glmatrix.vec3;\n\nfunction Globe(radius) {\n  this.radius = radius;\n  this.viewGL = null;\n  this.altitudeAxis; // Displacement data provided by texture.\n\n  this.displacementData = null;\n  this.displacementWidth;\n  this.displacementHeight;\n}\n\nGlobe.prototype = {\n  constructor: Globe,\n  dimensions: ['lng', 'lat', 'alt'],\n  type: 'globe',\n  containPoint: function () {},\n  setDisplacementData: function (data, width, height) {\n    this.displacementData = data;\n    this.displacementWidth = width;\n    this.displacementHeight = height;\n  },\n  _getDisplacementScale: function (lng, lat) {\n    var i = (lng + 180) / 360 * (this.displacementWidth - 1);\n    var j = (90 - lat) / 180 * (this.displacementHeight - 1); // NEAREST SAMPLING\n    // TODO Better bilinear sampling\n\n    var idx = Math.round(i) + Math.round(j) * this.displacementWidth;\n    return this.displacementData[idx];\n  },\n  dataToPoint: function (data, out) {\n    var lng = data[0];\n    var lat = data[1]; // Default have 0 altitude\n\n    var altVal = data[2] || 0;\n    var r = this.radius;\n\n    if (this.displacementData) {\n      r *= 1 + this._getDisplacementScale(lng, lat);\n    }\n\n    if (this.altitudeAxis) {\n      r += this.altitudeAxis.dataToCoord(altVal);\n    }\n\n    lng = lng * Math.PI / 180;\n    lat = lat * Math.PI / 180;\n    var r0 = Math.cos(lat) * r;\n    out = out || []; // PENDING\n\n    out[0] = -r0 * Math.cos(lng + Math.PI);\n    out[1] = Math.sin(lat) * r;\n    out[2] = r0 * Math.sin(lng + Math.PI);\n    return out;\n  },\n  pointToData: function (point, out) {\n    var x = point[0];\n    var y = point[1];\n    var z = point[2];\n    var len = vec3.len(point);\n    x /= len;\n    y /= len;\n    z /= len;\n    var theta = Math.asin(y);\n    var phi = Math.atan2(z, -x);\n\n    if (phi < 0) {\n      phi = Math.PI * 2 + phi;\n    }\n\n    var lat = theta * 180 / Math.PI;\n    var lng = phi * 180 / Math.PI - 180;\n    out = out || [];\n    out[0] = lng;\n    out[1] = lat;\n    out[2] = len - this.radius;\n\n    if (this.altitudeAxis) {\n      out[2] = this.altitudeAxis.coordToData(out[2]);\n    }\n\n    return out;\n  }\n};\nexport default Globe;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}