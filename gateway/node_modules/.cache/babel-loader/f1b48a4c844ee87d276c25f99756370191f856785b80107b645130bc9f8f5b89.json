{"ast":null,"code":"import glmatrix from 'claygl/src/dep/glmatrix';\nvar mat4 = glmatrix.mat4;\nvar TILE_SIZE = 512;\nvar FOV = 0.6435011087932844;\nvar PI = Math.PI;\nvar WORLD_SCALE = 1 / 10;\nfunction MapServiceCoordSys3D() {\n  /**\n   * Width of mapbox viewport\n   */\n  this.width = 0;\n  /**\n   * Height of mapbox viewport\n   */\n\n  this.height = 0;\n  this.altitudeScale = 1; // TODO Change boxHeight won't have animation.\n\n  this.boxHeight = 'auto'; // Set by mapbox creator\n\n  this.altitudeExtent;\n  this.bearing = 0;\n  this.pitch = 0;\n  this.center = [0, 0];\n  this._origin;\n  this.zoom = 0;\n  this._initialZoom; // Some parameters for different map services.\n\n  this.maxPitch = 60;\n  this.zoomOffset = 0;\n}\nMapServiceCoordSys3D.prototype = {\n  constructor: MapServiceCoordSys3D,\n  dimensions: ['lng', 'lat', 'alt'],\n  containPoint: function () {},\n  setCameraOption: function (option) {\n    this.bearing = option.bearing;\n    this.pitch = option.pitch;\n    this.center = option.center;\n    this.zoom = option.zoom;\n    if (!this._origin) {\n      this._origin = this.projectOnTileWithScale(this.center, TILE_SIZE);\n    }\n    if (this._initialZoom == null) {\n      this._initialZoom = this.zoom;\n    }\n    this.updateTransform();\n  },\n  // https://github.com/mapbox/mapbox-gl-js/blob/master/src/geo/transform.js#L479\n  updateTransform: function () {\n    if (!this.height) {\n      return;\n    }\n    var cameraToCenterDistance = 0.5 / Math.tan(FOV / 2) * this.height * WORLD_SCALE; // Convert to radian.\n\n    var pitch = Math.max(Math.min(this.pitch, this.maxPitch), 0) / 180 * Math.PI; // Find the distance from the center point [width/2, height/2] to the\n    // center top point [width/2, 0] in Z units, using the law of sines.\n    // 1 Z unit is equivalent to 1 horizontal px at the center of the map\n    // (the distance between[width/2, height/2] and [width/2 + 1, height/2])\n\n    var halfFov = FOV / 2;\n    var groundAngle = Math.PI / 2 + pitch;\n    var topHalfSurfaceDistance = Math.sin(halfFov) * cameraToCenterDistance / Math.sin(Math.PI - groundAngle - halfFov); // Calculate z distance of the farthest fragment that should be rendered.\n\n    var furthestDistance = Math.cos(Math.PI / 2 - pitch) * topHalfSurfaceDistance + cameraToCenterDistance; // Add a bit extra to avoid precision problems when a fragment's distance is exactly `furthestDistance`\n\n    var farZ = furthestDistance * 1.1; // Forced to be 1000\n\n    if (this.pitch > 50) {\n      farZ = 1000;\n    } // matrix for conversion from location to GL coordinates (-1 .. 1)\n\n    var m = [];\n    mat4.perspective(m, FOV, this.width / this.height, 1, farZ);\n    this.viewGL.camera.projectionMatrix.setArray(m);\n    this.viewGL.camera.decomposeProjectionMatrix();\n    var m = mat4.identity([]);\n    var pt = this.dataToPoint(this.center); // Inverse\n\n    mat4.scale(m, m, [1, -1, 1]); // Translate to altitude\n\n    mat4.translate(m, m, [0, 0, -cameraToCenterDistance]);\n    mat4.rotateX(m, m, pitch);\n    mat4.rotateZ(m, m, -this.bearing / 180 * Math.PI); // Translate to center.\n\n    mat4.translate(m, m, [-pt[0] * this.getScale() * WORLD_SCALE, -pt[1] * this.getScale() * WORLD_SCALE, 0]);\n    this.viewGL.camera.viewMatrix.array = m;\n    var invertM = [];\n    mat4.invert(invertM, m);\n    this.viewGL.camera.worldTransform.array = invertM;\n    this.viewGL.camera.decomposeWorldTransform(); // scale vertically to meters per pixel (inverse of ground resolution):\n    // worldSize / (circumferenceOfEarth * cos(lat * π / 180))\n\n    var worldSize = TILE_SIZE * this.getScale();\n    var verticalScale;\n    if (this.altitudeExtent && !isNaN(this.boxHeight)) {\n      var range = this.altitudeExtent[1] - this.altitudeExtent[0];\n      verticalScale = this.boxHeight / range * this.getScale() / Math.pow(2, this._initialZoom - this.zoomOffset);\n    } else {\n      verticalScale = worldSize / (2 * Math.PI * 6378000 * Math.abs(Math.cos(this.center[1] * (Math.PI / 180)))) * this.altitudeScale * WORLD_SCALE;\n    } // Include scale to avoid relayout when zooming\n    // FIXME Camera scale may have problem in shadow\n\n    this.viewGL.rootNode.scale.set(this.getScale() * WORLD_SCALE, this.getScale() * WORLD_SCALE, verticalScale);\n  },\n  getScale: function () {\n    return Math.pow(2, this.zoom - this.zoomOffset);\n  },\n  projectOnTile: function (data, out) {\n    return this.projectOnTileWithScale(data, this.getScale() * TILE_SIZE, out);\n  },\n  projectOnTileWithScale: function (data, scale, out) {\n    var lng = data[0];\n    var lat = data[1];\n    var lambda2 = lng * PI / 180;\n    var phi2 = lat * PI / 180;\n    var x = scale * (lambda2 + PI) / (2 * PI);\n    var y = scale * (PI - Math.log(Math.tan(PI / 4 + phi2 * 0.5))) / (2 * PI);\n    out = out || [];\n    out[0] = x;\n    out[1] = y;\n    return out;\n  },\n  unprojectFromTile: function (point, out) {\n    return this.unprojectOnTileWithScale(point, this.getScale() * TILE_SIZE, out);\n  },\n  unprojectOnTileWithScale: function (point, scale, out) {\n    var x = point[0];\n    var y = point[1];\n    var lambda2 = x / scale * (2 * PI) - PI;\n    var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale * (2 * PI))) - PI / 4);\n    out = out || [];\n    out[0] = lambda2 * 180 / PI;\n    out[1] = phi2 * 180 / PI;\n    return out;\n  },\n  dataToPoint: function (data, out) {\n    out = this.projectOnTileWithScale(data, TILE_SIZE, out); // Add a origin to avoid precision issue in WebGL.\n\n    out[0] -= this._origin[0];\n    out[1] -= this._origin[1]; // PENDING\n\n    out[2] = !isNaN(data[2]) ? data[2] : 0;\n    if (!isNaN(data[2])) {\n      out[2] = data[2];\n      if (this.altitudeExtent) {\n        out[2] -= this.altitudeExtent[0];\n      }\n    }\n    return out;\n  }\n};\nexport default MapServiceCoordSys3D;","map":{"version":3,"names":["glmatrix","mat4","TILE_SIZE","FOV","PI","Math","WORLD_SCALE","MapServiceCoordSys3D","width","height","altitudeScale","boxHeight","altitudeExtent","bearing","pitch","center","_origin","zoom","_initialZoom","maxPitch","zoomOffset","prototype","constructor","dimensions","containPoint","setCameraOption","option","projectOnTileWithScale","updateTransform","cameraToCenterDistance","tan","max","min","halfFov","groundAngle","topHalfSurfaceDistance","sin","furthestDistance","cos","farZ","m","perspective","viewGL","camera","projectionMatrix","setArray","decomposeProjectionMatrix","identity","pt","dataToPoint","scale","translate","rotateX","rotateZ","getScale","viewMatrix","array","invertM","invert","worldTransform","decomposeWorldTransform","worldSize","verticalScale","isNaN","range","pow","abs","rootNode","set","projectOnTile","data","out","lng","lat","lambda2","phi2","x","y","log","unprojectFromTile","point","unprojectOnTileWithScale","atan","exp"],"sources":["E:/mytest/node_modules/echarts-gl/lib/coord/mapServiceCommon/MapService3D.js"],"sourcesContent":["import glmatrix from 'claygl/src/dep/glmatrix';\nvar mat4 = glmatrix.mat4;\nvar TILE_SIZE = 512;\nvar FOV = 0.6435011087932844;\nvar PI = Math.PI;\nvar WORLD_SCALE = 1 / 10;\n\nfunction MapServiceCoordSys3D() {\n  /**\n   * Width of mapbox viewport\n   */\n  this.width = 0;\n  /**\n   * Height of mapbox viewport\n   */\n\n  this.height = 0;\n  this.altitudeScale = 1; // TODO Change boxHeight won't have animation.\n\n  this.boxHeight = 'auto'; // Set by mapbox creator\n\n  this.altitudeExtent;\n  this.bearing = 0;\n  this.pitch = 0;\n  this.center = [0, 0];\n  this._origin;\n  this.zoom = 0;\n  this._initialZoom; // Some parameters for different map services.\n\n  this.maxPitch = 60;\n  this.zoomOffset = 0;\n}\n\nMapServiceCoordSys3D.prototype = {\n  constructor: MapServiceCoordSys3D,\n  dimensions: ['lng', 'lat', 'alt'],\n  containPoint: function () {},\n  setCameraOption: function (option) {\n    this.bearing = option.bearing;\n    this.pitch = option.pitch;\n    this.center = option.center;\n    this.zoom = option.zoom;\n\n    if (!this._origin) {\n      this._origin = this.projectOnTileWithScale(this.center, TILE_SIZE);\n    }\n\n    if (this._initialZoom == null) {\n      this._initialZoom = this.zoom;\n    }\n\n    this.updateTransform();\n  },\n  // https://github.com/mapbox/mapbox-gl-js/blob/master/src/geo/transform.js#L479\n  updateTransform: function () {\n    if (!this.height) {\n      return;\n    }\n\n    var cameraToCenterDistance = 0.5 / Math.tan(FOV / 2) * this.height * WORLD_SCALE; // Convert to radian.\n\n    var pitch = Math.max(Math.min(this.pitch, this.maxPitch), 0) / 180 * Math.PI; // Find the distance from the center point [width/2, height/2] to the\n    // center top point [width/2, 0] in Z units, using the law of sines.\n    // 1 Z unit is equivalent to 1 horizontal px at the center of the map\n    // (the distance between[width/2, height/2] and [width/2 + 1, height/2])\n\n    var halfFov = FOV / 2;\n    var groundAngle = Math.PI / 2 + pitch;\n    var topHalfSurfaceDistance = Math.sin(halfFov) * cameraToCenterDistance / Math.sin(Math.PI - groundAngle - halfFov); // Calculate z distance of the farthest fragment that should be rendered.\n\n    var furthestDistance = Math.cos(Math.PI / 2 - pitch) * topHalfSurfaceDistance + cameraToCenterDistance; // Add a bit extra to avoid precision problems when a fragment's distance is exactly `furthestDistance`\n\n    var farZ = furthestDistance * 1.1; // Forced to be 1000\n\n    if (this.pitch > 50) {\n      farZ = 1000;\n    } // matrix for conversion from location to GL coordinates (-1 .. 1)\n\n\n    var m = [];\n    mat4.perspective(m, FOV, this.width / this.height, 1, farZ);\n    this.viewGL.camera.projectionMatrix.setArray(m);\n    this.viewGL.camera.decomposeProjectionMatrix();\n    var m = mat4.identity([]);\n    var pt = this.dataToPoint(this.center); // Inverse\n\n    mat4.scale(m, m, [1, -1, 1]); // Translate to altitude\n\n    mat4.translate(m, m, [0, 0, -cameraToCenterDistance]);\n    mat4.rotateX(m, m, pitch);\n    mat4.rotateZ(m, m, -this.bearing / 180 * Math.PI); // Translate to center.\n\n    mat4.translate(m, m, [-pt[0] * this.getScale() * WORLD_SCALE, -pt[1] * this.getScale() * WORLD_SCALE, 0]);\n    this.viewGL.camera.viewMatrix.array = m;\n    var invertM = [];\n    mat4.invert(invertM, m);\n    this.viewGL.camera.worldTransform.array = invertM;\n    this.viewGL.camera.decomposeWorldTransform(); // scale vertically to meters per pixel (inverse of ground resolution):\n    // worldSize / (circumferenceOfEarth * cos(lat * π / 180))\n\n    var worldSize = TILE_SIZE * this.getScale();\n    var verticalScale;\n\n    if (this.altitudeExtent && !isNaN(this.boxHeight)) {\n      var range = this.altitudeExtent[1] - this.altitudeExtent[0];\n      verticalScale = this.boxHeight / range * this.getScale() / Math.pow(2, this._initialZoom - this.zoomOffset);\n    } else {\n      verticalScale = worldSize / (2 * Math.PI * 6378000 * Math.abs(Math.cos(this.center[1] * (Math.PI / 180)))) * this.altitudeScale * WORLD_SCALE;\n    } // Include scale to avoid relayout when zooming\n    // FIXME Camera scale may have problem in shadow\n\n\n    this.viewGL.rootNode.scale.set(this.getScale() * WORLD_SCALE, this.getScale() * WORLD_SCALE, verticalScale);\n  },\n  getScale: function () {\n    return Math.pow(2, this.zoom - this.zoomOffset);\n  },\n  projectOnTile: function (data, out) {\n    return this.projectOnTileWithScale(data, this.getScale() * TILE_SIZE, out);\n  },\n  projectOnTileWithScale: function (data, scale, out) {\n    var lng = data[0];\n    var lat = data[1];\n    var lambda2 = lng * PI / 180;\n    var phi2 = lat * PI / 180;\n    var x = scale * (lambda2 + PI) / (2 * PI);\n    var y = scale * (PI - Math.log(Math.tan(PI / 4 + phi2 * 0.5))) / (2 * PI);\n    out = out || [];\n    out[0] = x;\n    out[1] = y;\n    return out;\n  },\n  unprojectFromTile: function (point, out) {\n    return this.unprojectOnTileWithScale(point, this.getScale() * TILE_SIZE, out);\n  },\n  unprojectOnTileWithScale: function (point, scale, out) {\n    var x = point[0];\n    var y = point[1];\n    var lambda2 = x / scale * (2 * PI) - PI;\n    var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale * (2 * PI))) - PI / 4);\n    out = out || [];\n    out[0] = lambda2 * 180 / PI;\n    out[1] = phi2 * 180 / PI;\n    return out;\n  },\n  dataToPoint: function (data, out) {\n    out = this.projectOnTileWithScale(data, TILE_SIZE, out); // Add a origin to avoid precision issue in WebGL.\n\n    out[0] -= this._origin[0];\n    out[1] -= this._origin[1]; // PENDING\n\n    out[2] = !isNaN(data[2]) ? data[2] : 0;\n\n    if (!isNaN(data[2])) {\n      out[2] = data[2];\n\n      if (this.altitudeExtent) {\n        out[2] -= this.altitudeExtent[0];\n      }\n    }\n\n    return out;\n  }\n};\nexport default MapServiceCoordSys3D;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}