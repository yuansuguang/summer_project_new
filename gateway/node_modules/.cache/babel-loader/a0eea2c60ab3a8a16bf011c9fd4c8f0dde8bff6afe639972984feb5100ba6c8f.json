{"ast":null,"code":"// TODO Shader library\nimport Pass from './Pass';\nimport CompositorNode from './CompositorNode';\n\n// TODO curlnoise demo wrong\n\n// PENDING\n// Use topological sort ?\n\n/**\n * Filter node\n *\n * @constructor clay.compositor.FilterNode\n * @extends clay.compositor.CompositorNode\n *\n * @example\n    var node = new clay.compositor.FilterNode({\n        name: 'fxaa',\n        shader: clay.Shader.source('clay.compositor.fxaa'),\n        inputs: {\n            texture: {\n                    node: 'scene',\n                    pin: 'color'\n            }\n        },\n        // Multiple outputs is preserved for MRT support in WebGL2.0\n        outputs: {\n            color: {\n                attachment: clay.FrameBuffer.COLOR_ATTACHMENT0\n                parameters: {\n                    format: clay.Texture.RGBA,\n                    width: 512,\n                    height: 512\n                },\n                // Node will keep the RTT rendered in last frame\n                keepLastFrame: true,\n                // Force the node output the RTT rendered in last frame\n                outputLastFrame: true\n            }\n        }\n    });\n    *\n    */\nvar FilterNode = CompositorNode.extend(function () {\n  return /** @lends clay.compositor.FilterNode# */{\n    /**\n     * @type {string}\n     */\n    name: '',\n    /**\n     * @type {Object}\n     */\n    inputs: {},\n    /**\n     * @type {Object}\n     */\n    outputs: null,\n    /**\n     * @type {string}\n     */\n    shader: '',\n    /**\n     * Input links, will be updated by the graph\n     * @example:\n     *     inputName: {\n     *         node: someNode,\n     *         pin: 'xxxx'\n     *     }\n     * @type {Object}\n     */\n    inputLinks: {},\n    /**\n     * Output links, will be updated by the graph\n     * @example:\n     *     outputName: {\n     *         node: someNode,\n     *         pin: 'xxxx'\n     *     }\n     * @type {Object}\n     */\n    outputLinks: {},\n    /**\n     * @type {clay.compositor.Pass}\n     */\n    pass: null,\n    // Save the output texture of previous frame\n    // Will be used when there exist a circular reference\n    _prevOutputTextures: {},\n    _outputTextures: {},\n    // Example: { name: 2 }\n    _outputReferences: {},\n    _rendering: false,\n    // If rendered in this frame\n    _rendered: false,\n    _compositor: null\n  };\n}, function () {\n  var pass = new Pass({\n    fragment: this.shader\n  });\n  this.pass = pass;\n}, /** @lends clay.compositor.FilterNode.prototype */\n{\n  /**\n   * @param  {clay.Renderer} renderer\n   */\n  render: function (renderer, frameBuffer) {\n    this.trigger('beforerender', renderer);\n    this._rendering = true;\n    var _gl = renderer.gl;\n    for (var inputName in this.inputLinks) {\n      var link = this.inputLinks[inputName];\n      var inputTexture = link.node.getOutput(renderer, link.pin);\n      this.pass.setUniform(inputName, inputTexture);\n    }\n    // Output\n    if (!this.outputs) {\n      this.pass.outputs = null;\n      this._compositor.getFrameBuffer().unbind(renderer);\n      this.pass.render(renderer, frameBuffer);\n    } else {\n      this.pass.outputs = {};\n      var attachedTextures = {};\n      for (var name in this.outputs) {\n        var parameters = this.updateParameter(name, renderer);\n        if (isNaN(parameters.width)) {\n          this.updateParameter(name, renderer);\n        }\n        var outputInfo = this.outputs[name];\n        var texture = this._compositor.allocateTexture(parameters);\n        this._outputTextures[name] = texture;\n        var attachment = outputInfo.attachment || _gl.COLOR_ATTACHMENT0;\n        if (typeof attachment === 'string') {\n          attachment = _gl[attachment];\n        }\n        attachedTextures[attachment] = texture;\n      }\n      this._compositor.getFrameBuffer().bind(renderer);\n      for (var attachment in attachedTextures) {\n        // FIXME attachment changes in different nodes\n        this._compositor.getFrameBuffer().attach(attachedTextures[attachment], attachment);\n      }\n      this.pass.render(renderer);\n\n      // Because the data of texture is changed over time,\n      // Here update the mipmaps of texture each time after rendered;\n      this._compositor.getFrameBuffer().updateMipmap(renderer);\n    }\n    for (var inputName in this.inputLinks) {\n      var link = this.inputLinks[inputName];\n      link.node.removeReference(link.pin);\n    }\n    this._rendering = false;\n    this._rendered = true;\n    this.trigger('afterrender', renderer);\n  },\n  // TODO Remove parameter function callback\n  updateParameter: function (outputName, renderer) {\n    var outputInfo = this.outputs[outputName];\n    var parameters = outputInfo.parameters;\n    var parametersCopy = outputInfo._parametersCopy;\n    if (!parametersCopy) {\n      parametersCopy = outputInfo._parametersCopy = {};\n    }\n    if (parameters) {\n      for (var key in parameters) {\n        if (key !== 'width' && key !== 'height') {\n          parametersCopy[key] = parameters[key];\n        }\n      }\n    }\n    var width, height;\n    if (typeof parameters.width === 'function') {\n      width = parameters.width.call(this, renderer);\n    } else {\n      width = parameters.width;\n    }\n    if (typeof parameters.height === 'function') {\n      height = parameters.height.call(this, renderer);\n    } else {\n      height = parameters.height;\n    }\n    width = Math.ceil(width);\n    height = Math.ceil(height);\n    if (parametersCopy.width !== width || parametersCopy.height !== height) {\n      if (this._outputTextures[outputName]) {\n        this._outputTextures[outputName].dispose(renderer);\n      }\n    }\n    parametersCopy.width = width;\n    parametersCopy.height = height;\n    return parametersCopy;\n  },\n  /**\n   * Set parameter\n   * @param {string} name\n   * @param {} value\n   */\n  setParameter: function (name, value) {\n    this.pass.setUniform(name, value);\n  },\n  /**\n   * Get parameter value\n   * @param  {string} name\n   * @return {}\n   */\n  getParameter: function (name) {\n    return this.pass.getUniform(name);\n  },\n  /**\n   * Set parameters\n   * @param {Object} obj\n   */\n  setParameters: function (obj) {\n    for (var name in obj) {\n      this.setParameter(name, obj[name]);\n    }\n  },\n  // /**\n  //  * Set shader code\n  //  * @param {string} shaderStr\n  //  */\n  // setShader: function (shaderStr) {\n  //     var material = this.pass.material;\n  //     material.shader.setFragment(shaderStr);\n  //     material.attachShader(material.shader, true);\n  // },\n  /**\n   * Proxy of pass.material.define('fragment', xxx);\n   * @param  {string} symbol\n   * @param  {number} [val]\n   */\n  define: function (symbol, val) {\n    this.pass.material.define('fragment', symbol, val);\n  },\n  /**\n   * Proxy of pass.material.undefine('fragment', xxx)\n   * @param  {string} symbol\n   */\n  undefine: function (symbol) {\n    this.pass.material.undefine('fragment', symbol);\n  },\n  removeReference: function (outputName) {\n    this._outputReferences[outputName]--;\n    if (this._outputReferences[outputName] === 0) {\n      var outputInfo = this.outputs[outputName];\n      if (outputInfo.keepLastFrame) {\n        if (this._prevOutputTextures[outputName]) {\n          this._compositor.releaseTexture(this._prevOutputTextures[outputName]);\n        }\n        this._prevOutputTextures[outputName] = this._outputTextures[outputName];\n      } else {\n        // Output of this node have alreay been used by all other nodes\n        // Put the texture back to the pool.\n        this._compositor.releaseTexture(this._outputTextures[outputName]);\n      }\n    }\n  },\n  clear: function () {\n    CompositorNode.prototype.clear.call(this);\n\n    // Default disable all texture\n    this.pass.material.disableTexturesAll();\n  }\n});\nexport default FilterNode;","map":{"version":3,"names":["Pass","CompositorNode","FilterNode","extend","name","inputs","outputs","shader","inputLinks","outputLinks","pass","_prevOutputTextures","_outputTextures","_outputReferences","_rendering","_rendered","_compositor","fragment","render","renderer","frameBuffer","trigger","_gl","gl","inputName","link","inputTexture","node","getOutput","pin","setUniform","getFrameBuffer","unbind","attachedTextures","parameters","updateParameter","isNaN","width","outputInfo","texture","allocateTexture","attachment","COLOR_ATTACHMENT0","bind","attach","updateMipmap","removeReference","outputName","parametersCopy","_parametersCopy","key","height","call","Math","ceil","dispose","setParameter","value","getParameter","getUniform","setParameters","obj","define","symbol","val","material","undefine","keepLastFrame","releaseTexture","clear","prototype","disableTexturesAll"],"sources":["E:/QuestionairePlanet_Fronted/mytest/node_modules/claygl/src/compositor/FilterNode.js"],"sourcesContent":["// TODO Shader library\nimport Pass from './Pass';\nimport CompositorNode from './CompositorNode';\n\n// TODO curlnoise demo wrong\n\n// PENDING\n// Use topological sort ?\n\n/**\n * Filter node\n *\n * @constructor clay.compositor.FilterNode\n * @extends clay.compositor.CompositorNode\n *\n * @example\n    var node = new clay.compositor.FilterNode({\n        name: 'fxaa',\n        shader: clay.Shader.source('clay.compositor.fxaa'),\n        inputs: {\n            texture: {\n                    node: 'scene',\n                    pin: 'color'\n            }\n        },\n        // Multiple outputs is preserved for MRT support in WebGL2.0\n        outputs: {\n            color: {\n                attachment: clay.FrameBuffer.COLOR_ATTACHMENT0\n                parameters: {\n                    format: clay.Texture.RGBA,\n                    width: 512,\n                    height: 512\n                },\n                // Node will keep the RTT rendered in last frame\n                keepLastFrame: true,\n                // Force the node output the RTT rendered in last frame\n                outputLastFrame: true\n            }\n        }\n    });\n    *\n    */\nvar FilterNode = CompositorNode.extend(function () {\n    return /** @lends clay.compositor.FilterNode# */ {\n        /**\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * @type {Object}\n         */\n        inputs: {},\n\n        /**\n         * @type {Object}\n         */\n        outputs: null,\n\n        /**\n         * @type {string}\n         */\n        shader: '',\n\n        /**\n         * Input links, will be updated by the graph\n         * @example:\n         *     inputName: {\n         *         node: someNode,\n         *         pin: 'xxxx'\n         *     }\n         * @type {Object}\n         */\n        inputLinks: {},\n\n        /**\n         * Output links, will be updated by the graph\n         * @example:\n         *     outputName: {\n         *         node: someNode,\n         *         pin: 'xxxx'\n         *     }\n         * @type {Object}\n         */\n        outputLinks: {},\n\n        /**\n         * @type {clay.compositor.Pass}\n         */\n        pass: null,\n\n        // Save the output texture of previous frame\n        // Will be used when there exist a circular reference\n        _prevOutputTextures: {},\n        _outputTextures: {},\n\n        // Example: { name: 2 }\n        _outputReferences: {},\n\n        _rendering: false,\n        // If rendered in this frame\n        _rendered: false,\n\n        _compositor: null\n    };\n}, function () {\n\n    var pass = new Pass({\n        fragment: this.shader\n    });\n    this.pass = pass;\n},\n/** @lends clay.compositor.FilterNode.prototype */\n{\n    /**\n     * @param  {clay.Renderer} renderer\n     */\n    render: function (renderer, frameBuffer) {\n        this.trigger('beforerender', renderer);\n\n        this._rendering = true;\n\n        var _gl = renderer.gl;\n\n        for (var inputName in this.inputLinks) {\n            var link = this.inputLinks[inputName];\n            var inputTexture = link.node.getOutput(renderer, link.pin);\n            this.pass.setUniform(inputName, inputTexture);\n        }\n        // Output\n        if (!this.outputs) {\n            this.pass.outputs = null;\n\n            this._compositor.getFrameBuffer().unbind(renderer);\n\n            this.pass.render(renderer, frameBuffer);\n        }\n        else {\n            this.pass.outputs = {};\n\n            var attachedTextures = {};\n            for (var name in this.outputs) {\n                var parameters = this.updateParameter(name, renderer);\n                if (isNaN(parameters.width)) {\n                    this.updateParameter(name, renderer);\n                }\n                var outputInfo = this.outputs[name];\n                var texture = this._compositor.allocateTexture(parameters);\n                this._outputTextures[name] = texture;\n                var attachment = outputInfo.attachment || _gl.COLOR_ATTACHMENT0;\n                if (typeof(attachment) === 'string') {\n                    attachment = _gl[attachment];\n                }\n                attachedTextures[attachment] = texture;\n            }\n            this._compositor.getFrameBuffer().bind(renderer);\n\n            for (var attachment in attachedTextures) {\n                // FIXME attachment changes in different nodes\n                this._compositor.getFrameBuffer().attach(\n                    attachedTextures[attachment], attachment\n                );\n            }\n\n            this.pass.render(renderer);\n\n            // Because the data of texture is changed over time,\n            // Here update the mipmaps of texture each time after rendered;\n            this._compositor.getFrameBuffer().updateMipmap(renderer);\n        }\n\n        for (var inputName in this.inputLinks) {\n            var link = this.inputLinks[inputName];\n            link.node.removeReference(link.pin);\n        }\n\n        this._rendering = false;\n        this._rendered = true;\n\n        this.trigger('afterrender', renderer);\n    },\n\n    // TODO Remove parameter function callback\n    updateParameter: function (outputName, renderer) {\n        var outputInfo = this.outputs[outputName];\n        var parameters = outputInfo.parameters;\n        var parametersCopy = outputInfo._parametersCopy;\n        if (!parametersCopy) {\n            parametersCopy = outputInfo._parametersCopy = {};\n        }\n        if (parameters) {\n            for (var key in parameters) {\n                if (key !== 'width' && key !== 'height') {\n                    parametersCopy[key] = parameters[key];\n                }\n            }\n        }\n        var width, height;\n        if (typeof parameters.width === 'function') {\n            width = parameters.width.call(this, renderer);\n        }\n        else {\n            width = parameters.width;\n        }\n        if (typeof parameters.height === 'function') {\n            height = parameters.height.call(this, renderer);\n        }\n        else {\n            height = parameters.height;\n        }\n        width = Math.ceil(width);\n        height = Math.ceil(height);\n        if (\n            parametersCopy.width !== width\n            || parametersCopy.height !== height\n        ) {\n            if (this._outputTextures[outputName]) {\n                this._outputTextures[outputName].dispose(renderer);\n            }\n        }\n        parametersCopy.width = width;\n        parametersCopy.height = height;\n\n        return parametersCopy;\n    },\n\n    /**\n     * Set parameter\n     * @param {string} name\n     * @param {} value\n     */\n    setParameter: function (name, value) {\n        this.pass.setUniform(name, value);\n    },\n    /**\n     * Get parameter value\n     * @param  {string} name\n     * @return {}\n     */\n    getParameter: function (name) {\n        return this.pass.getUniform(name);\n    },\n    /**\n     * Set parameters\n     * @param {Object} obj\n     */\n    setParameters: function (obj) {\n        for (var name in obj) {\n            this.setParameter(name, obj[name]);\n        }\n    },\n    // /**\n    //  * Set shader code\n    //  * @param {string} shaderStr\n    //  */\n    // setShader: function (shaderStr) {\n    //     var material = this.pass.material;\n    //     material.shader.setFragment(shaderStr);\n    //     material.attachShader(material.shader, true);\n    // },\n    /**\n     * Proxy of pass.material.define('fragment', xxx);\n     * @param  {string} symbol\n     * @param  {number} [val]\n     */\n    define: function (symbol, val) {\n        this.pass.material.define('fragment', symbol, val);\n    },\n\n    /**\n     * Proxy of pass.material.undefine('fragment', xxx)\n     * @param  {string} symbol\n     */\n    undefine: function (symbol) {\n        this.pass.material.undefine('fragment', symbol);\n    },\n\n    removeReference: function (outputName) {\n        this._outputReferences[outputName]--;\n        if (this._outputReferences[outputName] === 0) {\n            var outputInfo = this.outputs[outputName];\n            if (outputInfo.keepLastFrame) {\n                if (this._prevOutputTextures[outputName]) {\n                    this._compositor.releaseTexture(this._prevOutputTextures[outputName]);\n                }\n                this._prevOutputTextures[outputName] = this._outputTextures[outputName];\n            }\n            else {\n                // Output of this node have alreay been used by all other nodes\n                // Put the texture back to the pool.\n                this._compositor.releaseTexture(this._outputTextures[outputName]);\n            }\n        }\n    },\n\n    clear: function () {\n        CompositorNode.prototype.clear.call(this);\n\n        // Default disable all texture\n        this.pass.material.disableTexturesAll();\n    }\n});\n\nexport default FilterNode;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}