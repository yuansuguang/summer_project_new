{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/**\n * Lines geometry\n * Use screen space projected lines lineWidth > MAX_LINE_WIDTH\n * https://mattdesl.svbtle.com/drawing-lines-is-hard\n * @module echarts-gl/util/geometry/LinesGeometry\n * @author Yi Shen(http://github.com/pissang)\n */\nimport Geometry from 'claygl/src/Geometry';\nimport * as echarts from 'echarts/lib/echarts';\nimport dynamicConvertMixin from './dynamicConvertMixin';\nimport glmatrix from 'claygl/src/dep/glmatrix';\nvar vec2 = glmatrix.vec2; // var CURVE_RECURSION_LIMIT = 8;\n// var CURVE_COLLINEAR_EPSILON = 40;\n\nvar sampleLinePoints = [[0, 0], [1, 1]];\n/**\n * @constructor\n * @alias module:echarts-gl/util/geometry/LinesGeometry\n * @extends clay.Geometry\n */\n\nvar LinesGeometry = Geometry.extend(function () {\n  return {\n    segmentScale: 4,\n    dynamic: true,\n    /**\n     * Need to use mesh to expand lines if lineWidth > MAX_LINE_WIDTH\n     */\n    useNativeLine: true,\n    attributes: {\n      position: new Geometry.Attribute('position', 'float', 2, 'POSITION'),\n      normal: new Geometry.Attribute('normal', 'float', 2),\n      offset: new Geometry.Attribute('offset', 'float', 1),\n      color: new Geometry.Attribute('color', 'float', 4, 'COLOR')\n    }\n  };\n}, /** @lends module: echarts-gl/util/geometry/LinesGeometry.prototype */\n{\n  /**\n   * Reset offset\n   */\n  resetOffset: function () {\n    this._vertexOffset = 0;\n    this._faceOffset = 0;\n    this._itemVertexOffsets = [];\n  },\n  /**\n   * @param {number} nVertex\n   */\n  setVertexCount: function (nVertex) {\n    var attributes = this.attributes;\n    if (this.vertexCount !== nVertex) {\n      attributes.position.init(nVertex);\n      attributes.color.init(nVertex);\n      if (!this.useNativeLine) {\n        attributes.offset.init(nVertex);\n        attributes.normal.init(nVertex);\n      }\n      if (nVertex > 0xffff) {\n        if (this.indices instanceof Uint16Array) {\n          this.indices = new Uint32Array(this.indices);\n        }\n      } else {\n        if (this.indices instanceof Uint32Array) {\n          this.indices = new Uint16Array(this.indices);\n        }\n      }\n    }\n  },\n  /**\n   * @param {number} nTriangle\n   */\n  setTriangleCount: function (nTriangle) {\n    if (this.triangleCount !== nTriangle) {\n      if (nTriangle === 0) {\n        this.indices = null;\n      } else {\n        this.indices = this.vertexCount > 0xffff ? new Uint32Array(nTriangle * 3) : new Uint16Array(nTriangle * 3);\n      }\n    }\n  },\n  _getCubicCurveApproxStep: function (p0, p1, p2, p3) {\n    var len = vec2.dist(p0, p1) + vec2.dist(p2, p1) + vec2.dist(p3, p2);\n    var step = 1 / (len + 1) * this.segmentScale;\n    return step;\n  },\n  /**\n   * Get vertex count of cubic curve\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} p2\n   * @param {Array.<number>} p3\n   * @return number\n   */\n  getCubicCurveVertexCount: function (p0, p1, p2, p3) {\n    var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);\n    var segCount = Math.ceil(1 / step);\n    if (!this.useNativeLine) {\n      return segCount * 2 + 2;\n    } else {\n      return segCount * 2;\n    }\n  },\n  /**\n   * Get face count of cubic curve\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} p2\n   * @param {Array.<number>} p3\n   * @return number\n   */\n  getCubicCurveTriangleCount: function (p0, p1, p2, p3) {\n    var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);\n    var segCount = Math.ceil(1 / step);\n    if (!this.useNativeLine) {\n      return segCount * 2;\n    } else {\n      return 0;\n    }\n  },\n  /**\n   * Get vertex count of line\n   * @return {number}\n   */\n  getLineVertexCount: function () {\n    return this.getPolylineVertexCount(sampleLinePoints);\n  },\n  /**\n   * Get face count of line\n   * @return {number}\n   */\n  getLineTriangleCount: function () {\n    return this.getPolylineTriangleCount(sampleLinePoints);\n  },\n  /**\n   * Get how many vertices will polyline take.\n   * @type {number|Array} points Can be a 1d/2d list of points, or a number of points amount.\n   * @return {number}\n   */\n  getPolylineVertexCount: function (points) {\n    var pointsLen;\n    if (typeof points === 'number') {\n      pointsLen = points;\n    } else {\n      var is2DArray = typeof points[0] !== 'number';\n      pointsLen = is2DArray ? points.length : points.length / 2;\n    }\n    return !this.useNativeLine ? (pointsLen - 1) * 2 + 2 : (pointsLen - 1) * 2;\n  },\n  /**\n   * Get how many triangles will polyline take.\n   * @type {number|Array} points Can be a 1d/2d list of points, or a number of points amount.\n   * @return {number}\n   */\n  getPolylineTriangleCount: function (points) {\n    var pointsLen;\n    if (typeof points === 'number') {\n      pointsLen = points;\n    } else {\n      var is2DArray = typeof points[0] !== 'number';\n      pointsLen = is2DArray ? points.length : points.length / 2;\n    }\n    return !this.useNativeLine ? (pointsLen - 1) * 2 : 0;\n  },\n  /**\n   * Add a cubic curve\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} p2\n   * @param {Array.<number>} p3\n   * @param {Array.<number>} color\n   * @param {number} [lineWidth=1]\n   */\n  addCubicCurve: function (p0, p1, p2, p3, color, lineWidth) {\n    if (lineWidth == null) {\n      lineWidth = 1;\n    } // incremental interpolation\n    // http://antigrain.com/research/bezier_interpolation/index.html#PAGE_BEZIER_INTERPOLATION\n\n    var x0 = p0[0],\n      y0 = p0[1];\n    var x1 = p1[0],\n      y1 = p1[1];\n    var x2 = p2[0],\n      y2 = p2[1];\n    var x3 = p3[0],\n      y3 = p3[1];\n    var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);\n    var step2 = step * step;\n    var step3 = step2 * step;\n    var pre1 = 3.0 * step;\n    var pre2 = 3.0 * step2;\n    var pre4 = 6.0 * step2;\n    var pre5 = 6.0 * step3;\n    var tmp1x = x0 - x1 * 2.0 + x2;\n    var tmp1y = y0 - y1 * 2.0 + y2;\n    var tmp2x = (x1 - x2) * 3.0 - x0 + x3;\n    var tmp2y = (y1 - y2) * 3.0 - y0 + y3;\n    var fx = x0;\n    var fy = y0;\n    var dfx = (x1 - x0) * pre1 + tmp1x * pre2 + tmp2x * step3;\n    var dfy = (y1 - y0) * pre1 + tmp1y * pre2 + tmp2y * step3;\n    var ddfx = tmp1x * pre4 + tmp2x * pre5;\n    var ddfy = tmp1y * pre4 + tmp2y * pre5;\n    var dddfx = tmp2x * pre5;\n    var dddfy = tmp2y * pre5;\n    var t = 0;\n    var k = 0;\n    var segCount = Math.ceil(1 / step);\n    var points = new Float32Array((segCount + 1) * 3);\n    var points = [];\n    var offset = 0;\n    for (var k = 0; k < segCount + 1; k++) {\n      points[offset++] = fx;\n      points[offset++] = fy;\n      fx += dfx;\n      fy += dfy;\n      dfx += ddfx;\n      dfy += ddfy;\n      ddfx += dddfx;\n      ddfy += dddfy;\n      t += step;\n      if (t > 1) {\n        fx = dfx > 0 ? Math.min(fx, x3) : Math.max(fx, x3);\n        fy = dfy > 0 ? Math.min(fy, y3) : Math.max(fy, y3);\n      }\n    }\n    this.addPolyline(points, color, lineWidth);\n  },\n  /**\n   * Add a straight line\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} color\n   * @param {number} [lineWidth=1]\n   */\n  addLine: function (p0, p1, color, lineWidth) {\n    this.addPolyline([p0, p1], color, lineWidth);\n  },\n  /**\n   * Add a straight line\n   * @param {Array.<Array> | Array.<number>} points\n   * @param {Array.<number> | Array.<Array>} color\n   * @param {number} [lineWidth=1]\n   * @param {number} [arrayOffset=0]\n   * @param {number} [pointsCount] Default to be amount of points in the first argument\n   */\n  addPolyline: function () {\n    var dirA = vec2.create();\n    var dirB = vec2.create();\n    var normal = vec2.create();\n    var tangent = vec2.create();\n    var point = [],\n      nextPoint = [],\n      prevPoint = [];\n    return function (points, color, lineWidth, arrayOffset, pointsCount) {\n      if (!points.length) {\n        return;\n      }\n      var is2DArray = typeof points[0] !== 'number';\n      if (pointsCount == null) {\n        pointsCount = is2DArray ? points.length : points.length / 2;\n      }\n      if (pointsCount < 2) {\n        return;\n      }\n      if (arrayOffset == null) {\n        arrayOffset = 0;\n      }\n      if (lineWidth == null) {\n        lineWidth = 1;\n      }\n      this._itemVertexOffsets.push(this._vertexOffset);\n      var notSharingColor = is2DArray ? typeof color[0] !== 'number' : color.length / 4 === pointsCount;\n      var positionAttr = this.attributes.position;\n      var colorAttr = this.attributes.color;\n      var offsetAttr = this.attributes.offset;\n      var normalAttr = this.attributes.normal;\n      var indices = this.indices;\n      var vertexOffset = this._vertexOffset;\n      var pointColor;\n      for (var k = 0; k < pointsCount; k++) {\n        if (is2DArray) {\n          point = points[k + arrayOffset];\n          if (notSharingColor) {\n            pointColor = color[k + arrayOffset];\n          } else {\n            pointColor = color;\n          }\n        } else {\n          var k2 = k * 2 + arrayOffset;\n          point = point || [];\n          point[0] = points[k2];\n          point[1] = points[k2 + 1];\n          if (notSharingColor) {\n            var k4 = k * 4 + arrayOffset;\n            pointColor = pointColor || [];\n            pointColor[0] = color[k4];\n            pointColor[1] = color[k4 + 1];\n            pointColor[2] = color[k4 + 2];\n            pointColor[3] = color[k4 + 3];\n          } else {\n            pointColor = color;\n          }\n        }\n        if (!this.useNativeLine) {\n          var offset;\n          if (k < pointsCount - 1) {\n            if (is2DArray) {\n              vec2.copy(nextPoint, points[k + 1]);\n            } else {\n              var k2 = (k + 1) * 2 + arrayOffset;\n              nextPoint = nextPoint || [];\n              nextPoint[0] = points[k2];\n              nextPoint[1] = points[k2 + 1];\n            } // TODO In case dir is (0, 0)\n            // TODO miterLimit\n\n            if (k > 0) {\n              vec2.sub(dirA, point, prevPoint);\n              vec2.sub(dirB, nextPoint, point);\n              vec2.normalize(dirA, dirA);\n              vec2.normalize(dirB, dirB);\n              vec2.add(tangent, dirA, dirB);\n              vec2.normalize(tangent, tangent);\n              var miter = lineWidth / 2 * Math.min(1 / vec2.dot(dirA, tangent), 2);\n              normal[0] = -tangent[1];\n              normal[1] = tangent[0];\n              offset = miter;\n            } else {\n              vec2.sub(dirA, nextPoint, point);\n              vec2.normalize(dirA, dirA);\n              normal[0] = -dirA[1];\n              normal[1] = dirA[0];\n              offset = lineWidth / 2;\n            }\n          } else {\n            vec2.sub(dirA, point, prevPoint);\n            vec2.normalize(dirA, dirA);\n            normal[0] = -dirA[1];\n            normal[1] = dirA[0];\n            offset = lineWidth / 2;\n          }\n          normalAttr.set(vertexOffset, normal);\n          normalAttr.set(vertexOffset + 1, normal);\n          offsetAttr.set(vertexOffset, offset);\n          offsetAttr.set(vertexOffset + 1, -offset);\n          vec2.copy(prevPoint, point);\n          positionAttr.set(vertexOffset, point);\n          positionAttr.set(vertexOffset + 1, point);\n          colorAttr.set(vertexOffset, pointColor);\n          colorAttr.set(vertexOffset + 1, pointColor);\n          vertexOffset += 2;\n        } else {\n          if (k > 1) {\n            positionAttr.copy(vertexOffset, vertexOffset - 1);\n            colorAttr.copy(vertexOffset, vertexOffset - 1);\n            vertexOffset++;\n          }\n        }\n        if (!this.useNativeLine) {\n          if (k > 0) {\n            var idx3 = this._faceOffset * 3;\n            var indices = this.indices; // 0-----2\n            // 1-----3\n            // 0->1->2, 1->3->2\n\n            indices[idx3] = vertexOffset - 4;\n            indices[idx3 + 1] = vertexOffset - 3;\n            indices[idx3 + 2] = vertexOffset - 2;\n            indices[idx3 + 3] = vertexOffset - 3;\n            indices[idx3 + 4] = vertexOffset - 1;\n            indices[idx3 + 5] = vertexOffset - 2;\n            this._faceOffset += 2;\n          }\n        } else {\n          colorAttr.set(vertexOffset, pointColor);\n          positionAttr.set(vertexOffset, point);\n          vertexOffset++;\n        }\n      }\n      this._vertexOffset = vertexOffset;\n    };\n  }(),\n  /**\n   * Set color of single line.\n   */\n  setItemColor: function (idx, color) {\n    var startOffset = this._itemVertexOffsets[idx];\n    var endOffset = idx < this._itemVertexOffsets.length - 1 ? this._itemVertexOffsets[idx + 1] : this._vertexOffset;\n    for (var i = startOffset; i < endOffset; i++) {\n      this.attributes.color.set(i, color);\n    }\n    this.dirty('color');\n  }\n});\necharts.util.defaults(LinesGeometry.prototype, dynamicConvertMixin);\nexport default LinesGeometry;","map":{"version":3,"names":["Geometry","echarts","dynamicConvertMixin","glmatrix","vec2","sampleLinePoints","LinesGeometry","extend","segmentScale","dynamic","useNativeLine","attributes","position","Attribute","normal","offset","color","resetOffset","_vertexOffset","_faceOffset","_itemVertexOffsets","setVertexCount","nVertex","vertexCount","init","indices","Uint16Array","Uint32Array","setTriangleCount","nTriangle","triangleCount","_getCubicCurveApproxStep","p0","p1","p2","p3","len","dist","step","getCubicCurveVertexCount","segCount","Math","ceil","getCubicCurveTriangleCount","getLineVertexCount","getPolylineVertexCount","getLineTriangleCount","getPolylineTriangleCount","points","pointsLen","is2DArray","length","addCubicCurve","lineWidth","x0","y0","x1","y1","x2","y2","x3","y3","step2","step3","pre1","pre2","pre4","pre5","tmp1x","tmp1y","tmp2x","tmp2y","fx","fy","dfx","dfy","ddfx","ddfy","dddfx","dddfy","t","k","Float32Array","min","max","addPolyline","addLine","dirA","create","dirB","tangent","point","nextPoint","prevPoint","arrayOffset","pointsCount","push","notSharingColor","positionAttr","colorAttr","offsetAttr","normalAttr","vertexOffset","pointColor","k2","k4","copy","sub","normalize","add","miter","dot","set","idx3","setItemColor","idx","startOffset","endOffset","i","dirty","util","defaults","prototype"],"sources":["E:/mytest/node_modules/echarts-gl/lib/util/geometry/Lines2D.js"],"sourcesContent":["/**\n * Lines geometry\n * Use screen space projected lines lineWidth > MAX_LINE_WIDTH\n * https://mattdesl.svbtle.com/drawing-lines-is-hard\n * @module echarts-gl/util/geometry/LinesGeometry\n * @author Yi Shen(http://github.com/pissang)\n */\nimport Geometry from 'claygl/src/Geometry';\nimport * as echarts from 'echarts/lib/echarts';\nimport dynamicConvertMixin from './dynamicConvertMixin';\nimport glmatrix from 'claygl/src/dep/glmatrix';\nvar vec2 = glmatrix.vec2; // var CURVE_RECURSION_LIMIT = 8;\n// var CURVE_COLLINEAR_EPSILON = 40;\n\nvar sampleLinePoints = [[0, 0], [1, 1]];\n/**\n * @constructor\n * @alias module:echarts-gl/util/geometry/LinesGeometry\n * @extends clay.Geometry\n */\n\nvar LinesGeometry = Geometry.extend(function () {\n  return {\n    segmentScale: 4,\n    dynamic: true,\n\n    /**\n     * Need to use mesh to expand lines if lineWidth > MAX_LINE_WIDTH\n     */\n    useNativeLine: true,\n    attributes: {\n      position: new Geometry.Attribute('position', 'float', 2, 'POSITION'),\n      normal: new Geometry.Attribute('normal', 'float', 2),\n      offset: new Geometry.Attribute('offset', 'float', 1),\n      color: new Geometry.Attribute('color', 'float', 4, 'COLOR')\n    }\n  };\n},\n/** @lends module: echarts-gl/util/geometry/LinesGeometry.prototype */\n{\n  /**\n   * Reset offset\n   */\n  resetOffset: function () {\n    this._vertexOffset = 0;\n    this._faceOffset = 0;\n    this._itemVertexOffsets = [];\n  },\n\n  /**\n   * @param {number} nVertex\n   */\n  setVertexCount: function (nVertex) {\n    var attributes = this.attributes;\n\n    if (this.vertexCount !== nVertex) {\n      attributes.position.init(nVertex);\n      attributes.color.init(nVertex);\n\n      if (!this.useNativeLine) {\n        attributes.offset.init(nVertex);\n        attributes.normal.init(nVertex);\n      }\n\n      if (nVertex > 0xffff) {\n        if (this.indices instanceof Uint16Array) {\n          this.indices = new Uint32Array(this.indices);\n        }\n      } else {\n        if (this.indices instanceof Uint32Array) {\n          this.indices = new Uint16Array(this.indices);\n        }\n      }\n    }\n  },\n\n  /**\n   * @param {number} nTriangle\n   */\n  setTriangleCount: function (nTriangle) {\n    if (this.triangleCount !== nTriangle) {\n      if (nTriangle === 0) {\n        this.indices = null;\n      } else {\n        this.indices = this.vertexCount > 0xffff ? new Uint32Array(nTriangle * 3) : new Uint16Array(nTriangle * 3);\n      }\n    }\n  },\n  _getCubicCurveApproxStep: function (p0, p1, p2, p3) {\n    var len = vec2.dist(p0, p1) + vec2.dist(p2, p1) + vec2.dist(p3, p2);\n    var step = 1 / (len + 1) * this.segmentScale;\n    return step;\n  },\n\n  /**\n   * Get vertex count of cubic curve\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} p2\n   * @param {Array.<number>} p3\n   * @return number\n   */\n  getCubicCurveVertexCount: function (p0, p1, p2, p3) {\n    var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);\n\n    var segCount = Math.ceil(1 / step);\n\n    if (!this.useNativeLine) {\n      return segCount * 2 + 2;\n    } else {\n      return segCount * 2;\n    }\n  },\n\n  /**\n   * Get face count of cubic curve\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} p2\n   * @param {Array.<number>} p3\n   * @return number\n   */\n  getCubicCurveTriangleCount: function (p0, p1, p2, p3) {\n    var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);\n\n    var segCount = Math.ceil(1 / step);\n\n    if (!this.useNativeLine) {\n      return segCount * 2;\n    } else {\n      return 0;\n    }\n  },\n\n  /**\n   * Get vertex count of line\n   * @return {number}\n   */\n  getLineVertexCount: function () {\n    return this.getPolylineVertexCount(sampleLinePoints);\n  },\n\n  /**\n   * Get face count of line\n   * @return {number}\n   */\n  getLineTriangleCount: function () {\n    return this.getPolylineTriangleCount(sampleLinePoints);\n  },\n\n  /**\n   * Get how many vertices will polyline take.\n   * @type {number|Array} points Can be a 1d/2d list of points, or a number of points amount.\n   * @return {number}\n   */\n  getPolylineVertexCount: function (points) {\n    var pointsLen;\n\n    if (typeof points === 'number') {\n      pointsLen = points;\n    } else {\n      var is2DArray = typeof points[0] !== 'number';\n      pointsLen = is2DArray ? points.length : points.length / 2;\n    }\n\n    return !this.useNativeLine ? (pointsLen - 1) * 2 + 2 : (pointsLen - 1) * 2;\n  },\n\n  /**\n   * Get how many triangles will polyline take.\n   * @type {number|Array} points Can be a 1d/2d list of points, or a number of points amount.\n   * @return {number}\n   */\n  getPolylineTriangleCount: function (points) {\n    var pointsLen;\n\n    if (typeof points === 'number') {\n      pointsLen = points;\n    } else {\n      var is2DArray = typeof points[0] !== 'number';\n      pointsLen = is2DArray ? points.length : points.length / 2;\n    }\n\n    return !this.useNativeLine ? (pointsLen - 1) * 2 : 0;\n  },\n\n  /**\n   * Add a cubic curve\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} p2\n   * @param {Array.<number>} p3\n   * @param {Array.<number>} color\n   * @param {number} [lineWidth=1]\n   */\n  addCubicCurve: function (p0, p1, p2, p3, color, lineWidth) {\n    if (lineWidth == null) {\n      lineWidth = 1;\n    } // incremental interpolation\n    // http://antigrain.com/research/bezier_interpolation/index.html#PAGE_BEZIER_INTERPOLATION\n\n\n    var x0 = p0[0],\n        y0 = p0[1];\n    var x1 = p1[0],\n        y1 = p1[1];\n    var x2 = p2[0],\n        y2 = p2[1];\n    var x3 = p3[0],\n        y3 = p3[1];\n\n    var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);\n\n    var step2 = step * step;\n    var step3 = step2 * step;\n    var pre1 = 3.0 * step;\n    var pre2 = 3.0 * step2;\n    var pre4 = 6.0 * step2;\n    var pre5 = 6.0 * step3;\n    var tmp1x = x0 - x1 * 2.0 + x2;\n    var tmp1y = y0 - y1 * 2.0 + y2;\n    var tmp2x = (x1 - x2) * 3.0 - x0 + x3;\n    var tmp2y = (y1 - y2) * 3.0 - y0 + y3;\n    var fx = x0;\n    var fy = y0;\n    var dfx = (x1 - x0) * pre1 + tmp1x * pre2 + tmp2x * step3;\n    var dfy = (y1 - y0) * pre1 + tmp1y * pre2 + tmp2y * step3;\n    var ddfx = tmp1x * pre4 + tmp2x * pre5;\n    var ddfy = tmp1y * pre4 + tmp2y * pre5;\n    var dddfx = tmp2x * pre5;\n    var dddfy = tmp2y * pre5;\n    var t = 0;\n    var k = 0;\n    var segCount = Math.ceil(1 / step);\n    var points = new Float32Array((segCount + 1) * 3);\n    var points = [];\n    var offset = 0;\n\n    for (var k = 0; k < segCount + 1; k++) {\n      points[offset++] = fx;\n      points[offset++] = fy;\n      fx += dfx;\n      fy += dfy;\n      dfx += ddfx;\n      dfy += ddfy;\n      ddfx += dddfx;\n      ddfy += dddfy;\n      t += step;\n\n      if (t > 1) {\n        fx = dfx > 0 ? Math.min(fx, x3) : Math.max(fx, x3);\n        fy = dfy > 0 ? Math.min(fy, y3) : Math.max(fy, y3);\n      }\n    }\n\n    this.addPolyline(points, color, lineWidth);\n  },\n\n  /**\n   * Add a straight line\n   * @param {Array.<number>} p0\n   * @param {Array.<number>} p1\n   * @param {Array.<number>} color\n   * @param {number} [lineWidth=1]\n   */\n  addLine: function (p0, p1, color, lineWidth) {\n    this.addPolyline([p0, p1], color, lineWidth);\n  },\n\n  /**\n   * Add a straight line\n   * @param {Array.<Array> | Array.<number>} points\n   * @param {Array.<number> | Array.<Array>} color\n   * @param {number} [lineWidth=1]\n   * @param {number} [arrayOffset=0]\n   * @param {number} [pointsCount] Default to be amount of points in the first argument\n   */\n  addPolyline: function () {\n    var dirA = vec2.create();\n    var dirB = vec2.create();\n    var normal = vec2.create();\n    var tangent = vec2.create();\n    var point = [],\n        nextPoint = [],\n        prevPoint = [];\n    return function (points, color, lineWidth, arrayOffset, pointsCount) {\n      if (!points.length) {\n        return;\n      }\n\n      var is2DArray = typeof points[0] !== 'number';\n\n      if (pointsCount == null) {\n        pointsCount = is2DArray ? points.length : points.length / 2;\n      }\n\n      if (pointsCount < 2) {\n        return;\n      }\n\n      if (arrayOffset == null) {\n        arrayOffset = 0;\n      }\n\n      if (lineWidth == null) {\n        lineWidth = 1;\n      }\n\n      this._itemVertexOffsets.push(this._vertexOffset);\n\n      var notSharingColor = is2DArray ? typeof color[0] !== 'number' : color.length / 4 === pointsCount;\n      var positionAttr = this.attributes.position;\n      var colorAttr = this.attributes.color;\n      var offsetAttr = this.attributes.offset;\n      var normalAttr = this.attributes.normal;\n      var indices = this.indices;\n      var vertexOffset = this._vertexOffset;\n      var pointColor;\n\n      for (var k = 0; k < pointsCount; k++) {\n        if (is2DArray) {\n          point = points[k + arrayOffset];\n\n          if (notSharingColor) {\n            pointColor = color[k + arrayOffset];\n          } else {\n            pointColor = color;\n          }\n        } else {\n          var k2 = k * 2 + arrayOffset;\n          point = point || [];\n          point[0] = points[k2];\n          point[1] = points[k2 + 1];\n\n          if (notSharingColor) {\n            var k4 = k * 4 + arrayOffset;\n            pointColor = pointColor || [];\n            pointColor[0] = color[k4];\n            pointColor[1] = color[k4 + 1];\n            pointColor[2] = color[k4 + 2];\n            pointColor[3] = color[k4 + 3];\n          } else {\n            pointColor = color;\n          }\n        }\n\n        if (!this.useNativeLine) {\n          var offset;\n\n          if (k < pointsCount - 1) {\n            if (is2DArray) {\n              vec2.copy(nextPoint, points[k + 1]);\n            } else {\n              var k2 = (k + 1) * 2 + arrayOffset;\n              nextPoint = nextPoint || [];\n              nextPoint[0] = points[k2];\n              nextPoint[1] = points[k2 + 1];\n            } // TODO In case dir is (0, 0)\n            // TODO miterLimit\n\n\n            if (k > 0) {\n              vec2.sub(dirA, point, prevPoint);\n              vec2.sub(dirB, nextPoint, point);\n              vec2.normalize(dirA, dirA);\n              vec2.normalize(dirB, dirB);\n              vec2.add(tangent, dirA, dirB);\n              vec2.normalize(tangent, tangent);\n              var miter = lineWidth / 2 * Math.min(1 / vec2.dot(dirA, tangent), 2);\n              normal[0] = -tangent[1];\n              normal[1] = tangent[0];\n              offset = miter;\n            } else {\n              vec2.sub(dirA, nextPoint, point);\n              vec2.normalize(dirA, dirA);\n              normal[0] = -dirA[1];\n              normal[1] = dirA[0];\n              offset = lineWidth / 2;\n            }\n          } else {\n            vec2.sub(dirA, point, prevPoint);\n            vec2.normalize(dirA, dirA);\n            normal[0] = -dirA[1];\n            normal[1] = dirA[0];\n            offset = lineWidth / 2;\n          }\n\n          normalAttr.set(vertexOffset, normal);\n          normalAttr.set(vertexOffset + 1, normal);\n          offsetAttr.set(vertexOffset, offset);\n          offsetAttr.set(vertexOffset + 1, -offset);\n          vec2.copy(prevPoint, point);\n          positionAttr.set(vertexOffset, point);\n          positionAttr.set(vertexOffset + 1, point);\n          colorAttr.set(vertexOffset, pointColor);\n          colorAttr.set(vertexOffset + 1, pointColor);\n          vertexOffset += 2;\n        } else {\n          if (k > 1) {\n            positionAttr.copy(vertexOffset, vertexOffset - 1);\n            colorAttr.copy(vertexOffset, vertexOffset - 1);\n            vertexOffset++;\n          }\n        }\n\n        if (!this.useNativeLine) {\n          if (k > 0) {\n            var idx3 = this._faceOffset * 3;\n            var indices = this.indices; // 0-----2\n            // 1-----3\n            // 0->1->2, 1->3->2\n\n            indices[idx3] = vertexOffset - 4;\n            indices[idx3 + 1] = vertexOffset - 3;\n            indices[idx3 + 2] = vertexOffset - 2;\n            indices[idx3 + 3] = vertexOffset - 3;\n            indices[idx3 + 4] = vertexOffset - 1;\n            indices[idx3 + 5] = vertexOffset - 2;\n            this._faceOffset += 2;\n          }\n        } else {\n          colorAttr.set(vertexOffset, pointColor);\n          positionAttr.set(vertexOffset, point);\n          vertexOffset++;\n        }\n      }\n\n      this._vertexOffset = vertexOffset;\n    };\n  }(),\n\n  /**\n   * Set color of single line.\n   */\n  setItemColor: function (idx, color) {\n    var startOffset = this._itemVertexOffsets[idx];\n    var endOffset = idx < this._itemVertexOffsets.length - 1 ? this._itemVertexOffsets[idx + 1] : this._vertexOffset;\n\n    for (var i = startOffset; i < endOffset; i++) {\n      this.attributes.color.set(i, color);\n    }\n\n    this.dirty('color');\n  }\n});\necharts.util.defaults(LinesGeometry.prototype, dynamicConvertMixin);\nexport default LinesGeometry;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}