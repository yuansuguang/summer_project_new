{"ast":null,"code":"import \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport Geometry from '../Geometry';\nimport BoundingBox from '../math/BoundingBox';\n\n/**\n * @constructor clay.geometry.Sphere\n * @extends clay.Geometry\n * @param {Object} [opt]\n * @param {number} [widthSegments]\n * @param {number} [heightSegments]\n * @param {number} [phiStart]\n * @param {number} [phiLength]\n * @param {number} [thetaStart]\n * @param {number} [thetaLength]\n * @param {number} [radius]\n */\nvar Sphere = Geometry.extend( /** @lends clay.geometry.Sphere# */{\n  dynamic: false,\n  /**\n   * @type {number}\n   */\n  widthSegments: 40,\n  /**\n   * @type {number}\n   */\n  heightSegments: 20,\n  /**\n   * @type {number}\n   */\n  phiStart: 0,\n  /**\n   * @type {number}\n   */\n  phiLength: Math.PI * 2,\n  /**\n   * @type {number}\n   */\n  thetaStart: 0,\n  /**\n   * @type {number}\n   */\n  thetaLength: Math.PI,\n  /**\n   * @type {number}\n   */\n  radius: 1\n}, function () {\n  this.build();\n}, /** @lends clay.geometry.Sphere.prototype */\n{\n  /**\n   * Build sphere geometry\n   */\n  build: function () {\n    var heightSegments = this.heightSegments;\n    var widthSegments = this.widthSegments;\n    var positionAttr = this.attributes.position;\n    var texcoordAttr = this.attributes.texcoord0;\n    var normalAttr = this.attributes.normal;\n    var vertexCount = (widthSegments + 1) * (heightSegments + 1);\n    positionAttr.init(vertexCount);\n    texcoordAttr.init(vertexCount);\n    normalAttr.init(vertexCount);\n    var IndicesCtor = vertexCount > 0xffff ? Uint32Array : Uint16Array;\n    var indices = this.indices = new IndicesCtor(widthSegments * heightSegments * 6);\n    var x, y, z, u, v, i, j;\n    var radius = this.radius;\n    var phiStart = this.phiStart;\n    var phiLength = this.phiLength;\n    var thetaStart = this.thetaStart;\n    var thetaLength = this.thetaLength;\n    var radius = this.radius;\n    var pos = [];\n    var uv = [];\n    var offset = 0;\n    var divider = 1 / radius;\n    for (j = 0; j <= heightSegments; j++) {\n      for (i = 0; i <= widthSegments; i++) {\n        u = i / widthSegments;\n        v = j / heightSegments;\n\n        // X axis is inverted so texture can be mapped from left to right\n        x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n        y = radius * Math.cos(thetaStart + v * thetaLength);\n        z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n        pos[0] = x;\n        pos[1] = y;\n        pos[2] = z;\n        uv[0] = u;\n        uv[1] = v;\n        positionAttr.set(offset, pos);\n        texcoordAttr.set(offset, uv);\n        pos[0] *= divider;\n        pos[1] *= divider;\n        pos[2] *= divider;\n        normalAttr.set(offset, pos);\n        offset++;\n      }\n    }\n    var i1, i2, i3, i4;\n    var len = widthSegments + 1;\n    var n = 0;\n    for (j = 0; j < heightSegments; j++) {\n      for (i = 0; i < widthSegments; i++) {\n        i2 = j * len + i;\n        i1 = j * len + i + 1;\n        i4 = (j + 1) * len + i + 1;\n        i3 = (j + 1) * len + i;\n        indices[n++] = i1;\n        indices[n++] = i2;\n        indices[n++] = i4;\n        indices[n++] = i2;\n        indices[n++] = i3;\n        indices[n++] = i4;\n      }\n    }\n    this.boundingBox = new BoundingBox();\n    this.boundingBox.max.set(radius, radius, radius);\n    this.boundingBox.min.set(-radius, -radius, -radius);\n  }\n});\nexport default Sphere;","map":{"version":3,"names":["Geometry","BoundingBox","Sphere","extend","dynamic","widthSegments","heightSegments","phiStart","phiLength","Math","PI","thetaStart","thetaLength","radius","build","positionAttr","attributes","position","texcoordAttr","texcoord0","normalAttr","normal","vertexCount","init","IndicesCtor","Uint32Array","Uint16Array","indices","x","y","z","u","v","i","j","pos","uv","offset","divider","cos","sin","set","i1","i2","i3","i4","len","n","boundingBox","max","min"],"sources":["E:/mytest/node_modules/claygl/src/geometry/Sphere.js"],"sourcesContent":["import Geometry from '../Geometry';\nimport BoundingBox from '../math/BoundingBox';\n\n/**\n * @constructor clay.geometry.Sphere\n * @extends clay.Geometry\n * @param {Object} [opt]\n * @param {number} [widthSegments]\n * @param {number} [heightSegments]\n * @param {number} [phiStart]\n * @param {number} [phiLength]\n * @param {number} [thetaStart]\n * @param {number} [thetaLength]\n * @param {number} [radius]\n */\nvar Sphere = Geometry.extend(/** @lends clay.geometry.Sphere# */ {\n    dynamic: false,\n    /**\n     * @type {number}\n     */\n    widthSegments: 40,\n    /**\n     * @type {number}\n     */\n    heightSegments: 20,\n\n    /**\n     * @type {number}\n     */\n    phiStart: 0,\n    /**\n     * @type {number}\n     */\n    phiLength: Math.PI * 2,\n\n    /**\n     * @type {number}\n     */\n    thetaStart: 0,\n    /**\n     * @type {number}\n     */\n    thetaLength: Math.PI,\n\n    /**\n     * @type {number}\n     */\n    radius: 1\n\n}, function() {\n    this.build();\n},\n/** @lends clay.geometry.Sphere.prototype */\n{\n    /**\n     * Build sphere geometry\n     */\n    build: function() {\n        var heightSegments = this.heightSegments;\n        var widthSegments = this.widthSegments;\n\n        var positionAttr = this.attributes.position;\n        var texcoordAttr = this.attributes.texcoord0;\n        var normalAttr = this.attributes.normal;\n\n        var vertexCount = (widthSegments + 1) * (heightSegments + 1);\n        positionAttr.init(vertexCount);\n        texcoordAttr.init(vertexCount);\n        normalAttr.init(vertexCount);\n\n        var IndicesCtor = vertexCount > 0xffff ? Uint32Array : Uint16Array;\n        var indices = this.indices = new IndicesCtor(widthSegments * heightSegments * 6);\n\n        var x, y, z,\n            u, v,\n            i, j;\n\n        var radius = this.radius;\n        var phiStart = this.phiStart;\n        var phiLength = this.phiLength;\n        var thetaStart = this.thetaStart;\n        var thetaLength = this.thetaLength;\n        var radius = this.radius;\n\n        var pos = [];\n        var uv = [];\n        var offset = 0;\n        var divider = 1 / radius;\n        for (j = 0; j <= heightSegments; j ++) {\n            for (i = 0; i <= widthSegments; i ++) {\n                u = i / widthSegments;\n                v = j / heightSegments;\n\n                // X axis is inverted so texture can be mapped from left to right\n                x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n                y = radius * Math.cos(thetaStart + v * thetaLength);\n                z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n\n                pos[0] = x; pos[1] = y; pos[2] = z;\n                uv[0] = u; uv[1] = v;\n                positionAttr.set(offset, pos);\n                texcoordAttr.set(offset, uv);\n                pos[0] *= divider;\n                pos[1] *= divider;\n                pos[2] *= divider;\n                normalAttr.set(offset, pos);\n                offset++;\n            }\n        }\n\n        var i1, i2, i3, i4;\n\n        var len = widthSegments + 1;\n\n        var n = 0;\n        for (j = 0; j < heightSegments; j ++) {\n            for (i = 0; i < widthSegments; i ++) {\n                i2 = j * len + i;\n                i1 = (j * len + i + 1);\n                i4 = (j + 1) * len + i + 1;\n                i3 = (j + 1) * len + i;\n\n                indices[n++] = i1;\n                indices[n++] = i2;\n                indices[n++] = i4;\n\n                indices[n++] = i2;\n                indices[n++] = i3;\n                indices[n++] = i4;\n            }\n        }\n\n        this.boundingBox = new BoundingBox();\n        this.boundingBox.max.set(radius, radius, radius);\n        this.boundingBox.min.set(-radius, -radius, -radius);\n    }\n});\n\nexport default Sphere;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}