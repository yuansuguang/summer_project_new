{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n// TODO Resources like shader, texture, geometry reference management\n// Trace and find out which shader, texture, geometry can be destroyed\nimport Base from './core/Base';\nimport GLInfo from './core/GLInfo';\nimport glenum from './core/glenum';\nimport vendor from './core/vendor';\nimport Material from './Material';\nimport Vector2 from './math/Vector2';\nimport ProgramManager from './gpu/ProgramManager';\n\n// Light header\nimport Shader from './Shader';\nimport prezEssl from './shader/source/prez.glsl.js';\nShader['import'](prezEssl);\nimport mat4 from './glmatrix/mat4';\nimport vec3 from './glmatrix/vec3';\nvar mat4Create = mat4.create;\nvar errorShader = {};\nfunction defaultGetMaterial(renderable) {\n  return renderable.material;\n}\nfunction defaultGetUniform(renderable, material, symbol) {\n  return material.uniforms[symbol].value;\n}\nfunction defaultIsMaterialChanged(renderabled, prevRenderable, material, prevMaterial) {\n  return material !== prevMaterial;\n}\nfunction defaultIfRender(renderable) {\n  return true;\n}\nfunction noop() {}\nvar attributeBufferTypeMap = {\n  float: glenum.FLOAT,\n  byte: glenum.BYTE,\n  ubyte: glenum.UNSIGNED_BYTE,\n  short: glenum.SHORT,\n  ushort: glenum.UNSIGNED_SHORT\n};\nfunction VertexArrayObject(availableAttributes, availableAttributeSymbols, indicesBuffer) {\n  this.availableAttributes = availableAttributes;\n  this.availableAttributeSymbols = availableAttributeSymbols;\n  this.indicesBuffer = indicesBuffer;\n  this.vao = null;\n}\nfunction PlaceHolderTexture(renderer) {\n  var blankCanvas;\n  var webglTexture;\n  this.bind = function (renderer) {\n    if (!blankCanvas) {\n      // TODO Environment not support createCanvas.\n      blankCanvas = vendor.createCanvas();\n      blankCanvas.width = blankCanvas.height = 1;\n      blankCanvas.getContext('2d');\n    }\n    var gl = renderer.gl;\n    var firstBind = !webglTexture;\n    if (firstBind) {\n      webglTexture = gl.createTexture();\n    }\n    gl.bindTexture(gl.TEXTURE_2D, webglTexture);\n    if (firstBind) {\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, blankCanvas);\n    }\n  };\n  this.unbind = function (renderer) {\n    renderer.gl.bindTexture(renderer.gl.TEXTURE_2D, null);\n  };\n  this.isRenderable = function () {\n    return true;\n  };\n}\n/**\n * @constructor clay.Renderer\n * @extends clay.core.Base\n */\nvar Renderer = Base.extend(function () {\n  return /** @lends clay.Renderer# */{\n    /**\n     * @type {HTMLCanvasElement}\n     * @readonly\n     */\n    canvas: null,\n    /**\n     * Canvas width, set by resize method\n     * @type {number}\n     * @private\n     */\n    _width: 100,\n    /**\n     * Canvas width, set by resize method\n     * @type {number}\n     * @private\n     */\n    _height: 100,\n    /**\n     * Device pixel ratio, set by setDevicePixelRatio method\n     * Specially for high defination display\n     * @see http://www.khronos.org/webgl/wiki/HandlingHighDPI\n     * @type {number}\n     * @private\n     */\n    devicePixelRatio: typeof window !== 'undefined' && window.devicePixelRatio || 1.0,\n    /**\n     * Clear color\n     * @type {number[]}\n     */\n    clearColor: [0.0, 0.0, 0.0, 0.0],\n    /**\n     * Default:\n     *     _gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT | _gl.STENCIL_BUFFER_BIT\n     * @type {number}\n     */\n    clearBit: 17664,\n    // Settings when getting context\n    // http://www.khronos.org/registry/webgl/specs/latest/#2.4\n\n    /**\n     * If enable alpha, default true\n     * @type {boolean}\n     */\n    alpha: true,\n    /**\n     * If enable depth buffer, default true\n     * @type {boolean}\n     */\n    depth: true,\n    /**\n     * If enable stencil buffer, default false\n     * @type {boolean}\n     */\n    stencil: false,\n    /**\n     * If enable antialias, default true\n     * @type {boolean}\n     */\n    antialias: true,\n    /**\n     * If enable premultiplied alpha, default true\n     * @type {boolean}\n     */\n    premultipliedAlpha: true,\n    /**\n     * If preserve drawing buffer, default false\n     * @type {boolean}\n     */\n    preserveDrawingBuffer: false,\n    /**\n     * If throw context error, usually turned on in debug mode\n     * @type {boolean}\n     */\n    throwError: true,\n    /**\n     * WebGL Context created from given canvas\n     * @type {WebGLRenderingContext}\n     */\n    gl: null,\n    /**\n     * Renderer viewport, read-only, can be set by setViewport method\n     * @type {Object}\n     */\n    viewport: {},\n    /**\n     * Max joint number\n     * @type {number}\n     */\n    maxJointNumber: 20,\n    // Set by FrameBuffer#bind\n    __currentFrameBuffer: null,\n    _viewportStack: [],\n    _clearStack: [],\n    _sceneRendering: null\n  };\n}, function () {\n  if (!this.canvas) {\n    this.canvas = vendor.createCanvas();\n  }\n  var canvas = this.canvas;\n  try {\n    var opts = {\n      alpha: this.alpha,\n      depth: this.depth,\n      stencil: this.stencil,\n      antialias: this.antialias,\n      premultipliedAlpha: this.premultipliedAlpha,\n      preserveDrawingBuffer: this.preserveDrawingBuffer\n    };\n    this.gl = canvas.getContext('webgl', opts) || canvas.getContext('experimental-webgl', opts);\n    if (!this.gl) {\n      throw new Error();\n    }\n    this._glinfo = new GLInfo(this.gl);\n    if (this.gl.targetRenderer) {\n      console.error('Already created a renderer');\n    }\n    this.gl.targetRenderer = this;\n    this.resize();\n  } catch (e) {\n    throw 'Error creating WebGL Context ' + e;\n  }\n\n  // Init managers\n  this._programMgr = new ProgramManager(this);\n  this._placeholderTexture = new PlaceHolderTexture(this);\n}, /** @lends clay.Renderer.prototype. **/\n{\n  /**\n   * Resize the canvas\n   * @param {number} width\n   * @param {number} height\n   */\n  resize: function (width, height) {\n    var canvas = this.canvas;\n    // http://www.khronos.org/webgl/wiki/HandlingHighDPI\n    // set the display size of the canvas.\n    var dpr = this.devicePixelRatio;\n    if (width != null) {\n      if (canvas.style) {\n        canvas.style.width = width + 'px';\n        canvas.style.height = height + 'px';\n      }\n      // set the size of the drawingBuffer\n      canvas.width = width * dpr;\n      canvas.height = height * dpr;\n      this._width = width;\n      this._height = height;\n    } else {\n      this._width = canvas.width / dpr;\n      this._height = canvas.height / dpr;\n    }\n    this.setViewport(0, 0, this._width, this._height);\n  },\n  /**\n   * Get renderer width\n   * @return {number}\n   */\n  getWidth: function () {\n    return this._width;\n  },\n  /**\n   * Get renderer height\n   * @return {number}\n   */\n  getHeight: function () {\n    return this._height;\n  },\n  /**\n   * Get viewport aspect,\n   * @return {number}\n   */\n  getViewportAspect: function () {\n    var viewport = this.viewport;\n    return viewport.width / viewport.height;\n  },\n  /**\n   * Set devicePixelRatio\n   * @param {number} devicePixelRatio\n   */\n  setDevicePixelRatio: function (devicePixelRatio) {\n    this.devicePixelRatio = devicePixelRatio;\n    this.resize(this._width, this._height);\n  },\n  /**\n   * Get devicePixelRatio\n   * @param {number} devicePixelRatio\n   */\n  getDevicePixelRatio: function () {\n    return this.devicePixelRatio;\n  },\n  /**\n   * Get WebGL extension\n   * @param {string} name\n   * @return {object}\n   */\n  getGLExtension: function (name) {\n    return this._glinfo.getExtension(name);\n  },\n  /**\n   * Get WebGL parameter\n   * @param {string} name\n   * @return {*}\n   */\n  getGLParameter: function (name) {\n    return this._glinfo.getParameter(name);\n  },\n  /**\n   * Set rendering viewport\n   * @param {number|Object} x\n   * @param {number} [y]\n   * @param {number} [width]\n   * @param {number} [height]\n   * @param {number} [devicePixelRatio]\n   *        Defaultly use the renderere devicePixelRatio\n   *        It needs to be 1 when setViewport is called by frameBuffer\n   *\n   * @example\n   *  setViewport(0,0,width,height,1)\n   *  setViewport({\n   *      x: 0,\n   *      y: 0,\n   *      width: width,\n   *      height: height,\n   *      devicePixelRatio: 1\n   *  })\n   */\n  setViewport: function (x, y, width, height, dpr) {\n    if (typeof x === 'object') {\n      var obj = x;\n      x = obj.x;\n      y = obj.y;\n      width = obj.width;\n      height = obj.height;\n      dpr = obj.devicePixelRatio;\n    }\n    dpr = dpr || this.devicePixelRatio;\n    this.gl.viewport(x * dpr, y * dpr, width * dpr, height * dpr);\n    // Use a fresh new object, not write property.\n    this.viewport = {\n      x: x,\n      y: y,\n      width: width,\n      height: height,\n      devicePixelRatio: dpr\n    };\n  },\n  /**\n   * Push current viewport into a stack\n   */\n  saveViewport: function () {\n    this._viewportStack.push(this.viewport);\n  },\n  /**\n   * Pop viewport from stack, restore in the renderer\n   */\n  restoreViewport: function () {\n    if (this._viewportStack.length > 0) {\n      this.setViewport(this._viewportStack.pop());\n    }\n  },\n  /**\n   * Push current clear into a stack\n   */\n  saveClear: function () {\n    this._clearStack.push({\n      clearBit: this.clearBit,\n      clearColor: this.clearColor\n    });\n  },\n  /**\n   * Pop clear from stack, restore in the renderer\n   */\n  restoreClear: function () {\n    if (this._clearStack.length > 0) {\n      var opt = this._clearStack.pop();\n      this.clearColor = opt.clearColor;\n      this.clearBit = opt.clearBit;\n    }\n  },\n  bindSceneRendering: function (scene) {\n    this._sceneRendering = scene;\n  },\n  /**\n   * Render the scene in camera to the screen or binded offline framebuffer\n   * @param  {clay.Scene}       scene\n   * @param  {clay.Camera}      camera\n   * @param  {boolean}     [notUpdateScene] If not call the scene.update methods in the rendering, default true\n   * @param  {boolean}     [preZ]           If use preZ optimization, default false\n   * @return {IRenderInfo}\n   */\n  render: function (scene, camera, notUpdateScene, preZ) {\n    var _gl = this.gl;\n    var clearColor = this.clearColor;\n    if (this.clearBit) {\n      // Must set depth and color mask true before clear\n      _gl.colorMask(true, true, true, true);\n      _gl.depthMask(true);\n      var viewport = this.viewport;\n      var needsScissor = false;\n      var viewportDpr = viewport.devicePixelRatio;\n      if (viewport.width !== this._width || viewport.height !== this._height || viewportDpr && viewportDpr !== this.devicePixelRatio || viewport.x || viewport.y) {\n        needsScissor = true;\n        // http://stackoverflow.com/questions/11544608/how-to-clear-a-rectangle-area-in-webgl\n        // Only clear the viewport\n        _gl.enable(_gl.SCISSOR_TEST);\n        _gl.scissor(viewport.x * viewportDpr, viewport.y * viewportDpr, viewport.width * viewportDpr, viewport.height * viewportDpr);\n      }\n      _gl.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);\n      _gl.clear(this.clearBit);\n      if (needsScissor) {\n        _gl.disable(_gl.SCISSOR_TEST);\n      }\n    }\n\n    // If the scene have been updated in the prepass like shadow map\n    // There is no need to update it again\n    if (!notUpdateScene) {\n      scene.update(false);\n    }\n    scene.updateLights();\n    camera = camera || scene.getMainCamera();\n    if (!camera) {\n      console.error('Can\\'t find camera in the scene.');\n      return;\n    }\n    camera.update();\n    var renderList = scene.updateRenderList(camera, true);\n    this._sceneRendering = scene;\n    var opaqueList = renderList.opaque;\n    var transparentList = renderList.transparent;\n    var sceneMaterial = scene.material;\n    scene.trigger('beforerender', this, scene, camera, renderList);\n\n    // Render pre z\n    if (preZ) {\n      this.renderPreZ(opaqueList, scene, camera);\n      _gl.depthFunc(_gl.LEQUAL);\n    } else {\n      _gl.depthFunc(_gl.LESS);\n    }\n\n    // Update the depth of transparent list.\n    var worldViewMat = mat4Create();\n    var posViewSpace = vec3.create();\n    for (var i = 0; i < transparentList.length; i++) {\n      var renderable = transparentList[i];\n      mat4.multiplyAffine(worldViewMat, camera.viewMatrix.array, renderable.worldTransform.array);\n      vec3.transformMat4(posViewSpace, renderable.position.array, worldViewMat);\n      renderable.__depth = posViewSpace[2];\n    }\n\n    // Render opaque list\n    this.renderPass(opaqueList, camera, {\n      getMaterial: function (renderable) {\n        return sceneMaterial || renderable.material;\n      },\n      sortCompare: this.opaqueSortCompare\n    });\n    this.renderPass(transparentList, camera, {\n      getMaterial: function (renderable) {\n        return sceneMaterial || renderable.material;\n      },\n      sortCompare: this.transparentSortCompare\n    });\n    scene.trigger('afterrender', this, scene, camera, renderList);\n\n    // Cleanup\n    this._sceneRendering = null;\n  },\n  getProgram: function (renderable, renderMaterial, scene) {\n    renderMaterial = renderMaterial || renderable.material;\n    return this._programMgr.getProgram(renderable, renderMaterial, scene);\n  },\n  validateProgram: function (program) {\n    if (program.__error) {\n      var errorMsg = program.__error;\n      if (errorShader[program.__uid__]) {\n        return;\n      }\n      errorShader[program.__uid__] = true;\n      if (this.throwError) {\n        throw new Error(errorMsg);\n      } else {\n        this.trigger('error', errorMsg);\n      }\n    }\n  },\n  updatePrograms: function (list, scene, passConfig) {\n    var getMaterial = passConfig && passConfig.getMaterial || defaultGetMaterial;\n    scene = scene || null;\n    for (var i = 0; i < list.length; i++) {\n      var renderable = list[i];\n      var renderMaterial = getMaterial.call(this, renderable);\n      if (i > 0) {\n        var prevRenderable = list[i - 1];\n        var prevJointsLen = prevRenderable.joints ? prevRenderable.joints.length : 0;\n        var jointsLen = renderable.joints ? renderable.joints.length : 0;\n        // Keep program not change if joints, material, lightGroup are same of two renderables.\n        if (jointsLen === prevJointsLen && renderable.material === prevRenderable.material && renderable.lightGroup === prevRenderable.lightGroup) {\n          renderable.__program = prevRenderable.__program;\n          continue;\n        }\n      }\n      var program = this._programMgr.getProgram(renderable, renderMaterial, scene);\n      this.validateProgram(program);\n      renderable.__program = program;\n    }\n  },\n  /**\n   * Render a single renderable list in camera in sequence\n   * @param {clay.Renderable[]} list List of all renderables.\n   * @param {clay.Camera} [camera] Camera provide view matrix and porjection matrix. It can be null.\n   * @param {Object} [passConfig]\n   * @param {Function} [passConfig.getMaterial] Get renderable material.\n   * @param {Function} [passConfig.getUniform] Get material uniform value.\n   * @param {Function} [passConfig.isMaterialChanged] If material changed.\n   * @param {Function} [passConfig.beforeRender] Before render each renderable.\n   * @param {Function} [passConfig.afterRender] After render each renderable\n   * @param {Function} [passConfig.ifRender] If render the renderable.\n   * @param {Function} [passConfig.sortCompare] Sort compare function.\n   * @return {IRenderInfo}\n   */\n  renderPass: function (list, camera, passConfig) {\n    this.trigger('beforerenderpass', this, list, camera, passConfig);\n    passConfig = passConfig || {};\n    passConfig.getMaterial = passConfig.getMaterial || defaultGetMaterial;\n    passConfig.getUniform = passConfig.getUniform || defaultGetUniform;\n    // PENDING Better solution?\n    passConfig.isMaterialChanged = passConfig.isMaterialChanged || defaultIsMaterialChanged;\n    passConfig.beforeRender = passConfig.beforeRender || noop;\n    passConfig.afterRender = passConfig.afterRender || noop;\n    var ifRenderObject = passConfig.ifRender || defaultIfRender;\n    this.updatePrograms(list, this._sceneRendering, passConfig);\n    if (passConfig.sortCompare) {\n      list.sort(passConfig.sortCompare);\n    }\n\n    // Some common builtin uniforms\n    var viewport = this.viewport;\n    var vDpr = viewport.devicePixelRatio;\n    var viewportUniform = [viewport.x * vDpr, viewport.y * vDpr, viewport.width * vDpr, viewport.height * vDpr];\n    var windowDpr = this.devicePixelRatio;\n    var windowSizeUniform = this.__currentFrameBuffer ? [this.__currentFrameBuffer.getTextureWidth(), this.__currentFrameBuffer.getTextureHeight()] : [this._width * windowDpr, this._height * windowDpr];\n    // DEPRECATED\n    var viewportSizeUniform = [viewportUniform[2], viewportUniform[3]];\n    var time = Date.now();\n\n    // Calculate view and projection matrix\n    if (camera) {\n      mat4.copy(matrices.VIEW, camera.viewMatrix.array);\n      mat4.copy(matrices.PROJECTION, camera.projectionMatrix.array);\n      mat4.copy(matrices.VIEWINVERSE, camera.worldTransform.array);\n    } else {\n      mat4.identity(matrices.VIEW);\n      mat4.identity(matrices.PROJECTION);\n      mat4.identity(matrices.VIEWINVERSE);\n    }\n    mat4.multiply(matrices.VIEWPROJECTION, matrices.PROJECTION, matrices.VIEW);\n    mat4.invert(matrices.PROJECTIONINVERSE, matrices.PROJECTION);\n    mat4.invert(matrices.VIEWPROJECTIONINVERSE, matrices.VIEWPROJECTION);\n    var _gl = this.gl;\n    var scene = this._sceneRendering;\n    var prevMaterial;\n    var prevProgram;\n    var prevRenderable;\n\n    // Status\n    var depthTest, depthMask;\n    var culling, cullFace, frontFace;\n    var transparent;\n    var drawID;\n    var currentVAO;\n    var materialTakesTextureSlot;\n\n    // var vaoExt = this.getGLExtension('OES_vertex_array_object');\n    // not use vaoExt, some platforms may mess it up.\n    var vaoExt = null;\n    for (var i = 0; i < list.length; i++) {\n      var renderable = list[i];\n      var isSceneNode = renderable.worldTransform != null;\n      var worldM;\n      if (!ifRenderObject(renderable)) {\n        continue;\n      }\n\n      // Skinned mesh will transformed to joint space. Ignore the mesh transform\n      if (isSceneNode) {\n        worldM = renderable.isSkinnedMesh && renderable.isSkinnedMesh()\n        // TODO\n        ? renderable.offsetMatrix ? renderable.offsetMatrix.array : matrices.IDENTITY : renderable.worldTransform.array;\n      }\n      var geometry = renderable.geometry;\n      var material = passConfig.getMaterial.call(this, renderable);\n      var program = renderable.__program;\n      var shader = material.shader;\n      var currentDrawID = geometry.__uid__ + '-' + program.__uid__;\n      var drawIDChanged = currentDrawID !== drawID;\n      drawID = currentDrawID;\n      if (drawIDChanged && vaoExt) {\n        // TODO Seems need to be bound to null immediately (or before bind another program?) if vao is changed\n        vaoExt.bindVertexArrayOES(null);\n      }\n      if (isSceneNode) {\n        mat4.copy(matrices.WORLD, worldM);\n        mat4.multiply(matrices.WORLDVIEWPROJECTION, matrices.VIEWPROJECTION, worldM);\n        mat4.multiplyAffine(matrices.WORLDVIEW, matrices.VIEW, worldM);\n        if (shader.matrixSemantics.WORLDINVERSE || shader.matrixSemantics.WORLDINVERSETRANSPOSE) {\n          mat4.invert(matrices.WORLDINVERSE, worldM);\n        }\n        if (shader.matrixSemantics.WORLDVIEWINVERSE || shader.matrixSemantics.WORLDVIEWINVERSETRANSPOSE) {\n          mat4.invert(matrices.WORLDVIEWINVERSE, matrices.WORLDVIEW);\n        }\n        if (shader.matrixSemantics.WORLDVIEWPROJECTIONINVERSE || shader.matrixSemantics.WORLDVIEWPROJECTIONINVERSETRANSPOSE) {\n          mat4.invert(matrices.WORLDVIEWPROJECTIONINVERSE, matrices.WORLDVIEWPROJECTION);\n        }\n      }\n\n      // Before render hook\n      renderable.beforeRender && renderable.beforeRender(this);\n      passConfig.beforeRender.call(this, renderable, material, prevMaterial);\n      var programChanged = program !== prevProgram;\n      if (programChanged) {\n        // Set lights number\n        program.bind(this);\n        // Set some common uniforms\n        program.setUniformOfSemantic(_gl, 'VIEWPORT', viewportUniform);\n        program.setUniformOfSemantic(_gl, 'WINDOW_SIZE', windowSizeUniform);\n        if (camera) {\n          program.setUniformOfSemantic(_gl, 'NEAR', camera.near);\n          program.setUniformOfSemantic(_gl, 'FAR', camera.far);\n        }\n        program.setUniformOfSemantic(_gl, 'DEVICEPIXELRATIO', vDpr);\n        program.setUniformOfSemantic(_gl, 'TIME', time);\n        // DEPRECATED\n        program.setUniformOfSemantic(_gl, 'VIEWPORT_SIZE', viewportSizeUniform);\n\n        // Set lights uniforms\n        // TODO needs optimized\n        if (scene) {\n          scene.setLightUniforms(program, renderable.lightGroup, this);\n        }\n      } else {\n        program = prevProgram;\n      }\n\n      // Program changes also needs reset the materials.\n      if (programChanged || passConfig.isMaterialChanged(renderable, prevRenderable, material, prevMaterial)) {\n        if (material.depthTest !== depthTest) {\n          material.depthTest ? _gl.enable(_gl.DEPTH_TEST) : _gl.disable(_gl.DEPTH_TEST);\n          depthTest = material.depthTest;\n        }\n        if (material.depthMask !== depthMask) {\n          _gl.depthMask(material.depthMask);\n          depthMask = material.depthMask;\n        }\n        if (material.transparent !== transparent) {\n          material.transparent ? _gl.enable(_gl.BLEND) : _gl.disable(_gl.BLEND);\n          transparent = material.transparent;\n        }\n        // TODO cache blending\n        if (material.transparent) {\n          if (material.blend) {\n            material.blend(_gl);\n          } else {\n            // Default blend function\n            _gl.blendEquationSeparate(_gl.FUNC_ADD, _gl.FUNC_ADD);\n            _gl.blendFuncSeparate(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA);\n          }\n        }\n        materialTakesTextureSlot = this._bindMaterial(renderable, material, program, prevRenderable || null, prevMaterial || null, prevProgram || null, passConfig.getUniform);\n        prevMaterial = material;\n      }\n      var matrixSemanticKeys = shader.matrixSemanticKeys;\n      if (isSceneNode) {\n        for (var k = 0; k < matrixSemanticKeys.length; k++) {\n          var semantic = matrixSemanticKeys[k];\n          var semanticInfo = shader.matrixSemantics[semantic];\n          var matrix = matrices[semantic];\n          if (semanticInfo.isTranspose) {\n            var matrixNoTranspose = matrices[semanticInfo.semanticNoTranspose];\n            mat4.transpose(matrix, matrixNoTranspose);\n          }\n          program.setUniform(_gl, semanticInfo.type, semanticInfo.symbol, matrix);\n        }\n      }\n      if (renderable.cullFace !== cullFace) {\n        cullFace = renderable.cullFace;\n        _gl.cullFace(cullFace);\n      }\n      if (renderable.frontFace !== frontFace) {\n        frontFace = renderable.frontFace;\n        _gl.frontFace(frontFace);\n      }\n      if (renderable.culling !== culling) {\n        culling = renderable.culling;\n        culling ? _gl.enable(_gl.CULL_FACE) : _gl.disable(_gl.CULL_FACE);\n      }\n      // TODO Not update skeleton in each renderable.\n      this._updateSkeleton(renderable, program, materialTakesTextureSlot);\n      if (drawIDChanged) {\n        currentVAO = this._bindVAO(vaoExt, shader, geometry, program);\n      }\n      this._renderObject(renderable, currentVAO, program);\n\n      // After render hook\n      passConfig.afterRender(this, renderable);\n      renderable.afterRender && renderable.afterRender(this);\n      prevProgram = program;\n      prevRenderable = renderable;\n    }\n\n    // TODO Seems need to be bound to null immediately if vao is changed?\n    if (vaoExt) {\n      vaoExt.bindVertexArrayOES(null);\n    }\n    this.trigger('afterrenderpass', this, list, camera, passConfig);\n  },\n  getMaxJointNumber: function () {\n    return this.maxJointNumber;\n  },\n  _updateSkeleton: function (object, program, slot) {\n    var _gl = this.gl;\n    var skeleton = object.skeleton;\n    // Set pose matrices of skinned mesh\n    if (skeleton) {\n      // TODO Update before culling.\n      skeleton.update();\n      if (object.joints.length > this.getMaxJointNumber()) {\n        var skinMatricesTexture = skeleton.getSubSkinMatricesTexture(object.__uid__, object.joints);\n        program.useTextureSlot(this, skinMatricesTexture, slot);\n        program.setUniform(_gl, '1i', 'skinMatricesTexture', slot);\n        program.setUniform(_gl, '1f', 'skinMatricesTextureSize', skinMatricesTexture.width);\n      } else {\n        var skinMatricesArray = skeleton.getSubSkinMatrices(object.__uid__, object.joints);\n        program.setUniformOfSemantic(_gl, 'SKIN_MATRIX', skinMatricesArray);\n      }\n    }\n  },\n  _renderObject: function (renderable, vao, program) {\n    var _gl = this.gl;\n    var geometry = renderable.geometry;\n    var glDrawMode = renderable.mode;\n    if (glDrawMode == null) {\n      glDrawMode = 0x0004;\n    }\n    var ext = null;\n    var isInstanced = renderable.isInstancedMesh && renderable.isInstancedMesh();\n    if (isInstanced) {\n      ext = this.getGLExtension('ANGLE_instanced_arrays');\n      if (!ext) {\n        console.warn('Device not support ANGLE_instanced_arrays extension');\n        return;\n      }\n    }\n    var instancedAttrLocations;\n    if (isInstanced) {\n      instancedAttrLocations = this._bindInstancedAttributes(renderable, program, ext);\n    }\n    if (vao.indicesBuffer) {\n      var uintExt = this.getGLExtension('OES_element_index_uint');\n      var useUintExt = uintExt && geometry.indices instanceof Uint32Array;\n      var indicesType = useUintExt ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;\n      if (isInstanced) {\n        ext.drawElementsInstancedANGLE(glDrawMode, vao.indicesBuffer.count, indicesType, 0, renderable.getInstanceCount());\n      } else {\n        _gl.drawElements(glDrawMode, vao.indicesBuffer.count, indicesType, 0);\n      }\n    } else {\n      if (isInstanced) {\n        ext.drawArraysInstancedANGLE(glDrawMode, 0, geometry.vertexCount, renderable.getInstanceCount());\n      } else {\n        // FIXME Use vertex number in buffer\n        // vertexCount may get the wrong value when geometry forget to mark dirty after update\n        _gl.drawArrays(glDrawMode, 0, geometry.vertexCount);\n      }\n    }\n    if (isInstanced) {\n      for (var i = 0; i < instancedAttrLocations.length; i++) {\n        _gl.disableVertexAttribArray(instancedAttrLocations[i]);\n      }\n    }\n  },\n  _bindInstancedAttributes: function (renderable, program, ext) {\n    var _gl = this.gl;\n    var instancedBuffers = renderable.getInstancedAttributesBuffers(this);\n    var locations = [];\n    for (var i = 0; i < instancedBuffers.length; i++) {\n      var bufferObj = instancedBuffers[i];\n      var location = program.getAttribLocation(_gl, bufferObj.symbol);\n      if (location < 0) {\n        continue;\n      }\n      var glType = attributeBufferTypeMap[bufferObj.type] || _gl.FLOAT;\n      ;\n      _gl.enableVertexAttribArray(location); // TODO\n      _gl.bindBuffer(_gl.ARRAY_BUFFER, bufferObj.buffer);\n      _gl.vertexAttribPointer(location, bufferObj.size, glType, false, 0, 0);\n      ext.vertexAttribDivisorANGLE(location, bufferObj.divisor);\n      locations.push(location);\n    }\n    return locations;\n  },\n  _bindMaterial: function (renderable, material, program, prevRenderable, prevMaterial, prevProgram, getUniformValue) {\n    var _gl = this.gl;\n    // PENDING Same texture in different material take different slot?\n\n    // May use shader of other material if shader code are same\n    var sameProgram = prevProgram === program;\n    var currentTextureSlot = program.currentTextureSlot();\n    var enabledUniforms = material.getEnabledUniforms();\n    var textureUniforms = material.getTextureUniforms();\n    var placeholderTexture = this._placeholderTexture;\n    for (var u = 0; u < textureUniforms.length; u++) {\n      var symbol = textureUniforms[u];\n      var uniformValue = getUniformValue(renderable, material, symbol);\n      var uniformType = material.uniforms[symbol].type;\n      // Not use `instanceof` to determine if a value is texture in Material#bind.\n      // Use type instead, in some case texture may be in different namespaces.\n      // TODO Duck type validate.\n      if (uniformType === 't' && uniformValue) {\n        // Reset slot\n        uniformValue.__slot = -1;\n      } else if (uniformType === 'tv') {\n        for (var i = 0; i < uniformValue.length; i++) {\n          if (uniformValue[i]) {\n            uniformValue[i].__slot = -1;\n          }\n        }\n      }\n    }\n    placeholderTexture.__slot = -1;\n\n    // Set uniforms\n    for (var u = 0; u < enabledUniforms.length; u++) {\n      var symbol = enabledUniforms[u];\n      var uniform = material.uniforms[symbol];\n      var uniformValue = getUniformValue(renderable, material, symbol);\n      var uniformType = uniform.type;\n      var isTexture = uniformType === 't';\n      if (isTexture) {\n        if (!uniformValue || !uniformValue.isRenderable()) {\n          uniformValue = placeholderTexture;\n        }\n      }\n      // PENDING\n      // When binding two materials with the same shader\n      // Many uniforms will be be set twice even if they have the same value\n      // So add a evaluation to see if the uniform is really needed to be set\n      if (prevMaterial && sameProgram) {\n        var prevUniformValue = getUniformValue(prevRenderable, prevMaterial, symbol);\n        if (isTexture) {\n          if (!prevUniformValue || !prevUniformValue.isRenderable()) {\n            prevUniformValue = placeholderTexture;\n          }\n        }\n        if (prevUniformValue === uniformValue) {\n          if (isTexture) {\n            // Still take the slot to make sure same texture in different materials have same slot.\n            program.takeCurrentTextureSlot(this, null);\n          } else if (uniformType === 'tv' && uniformValue) {\n            for (var i = 0; i < uniformValue.length; i++) {\n              program.takeCurrentTextureSlot(this, null);\n            }\n          }\n          continue;\n        }\n      }\n      if (uniformValue == null) {\n        continue;\n      } else if (isTexture) {\n        if (uniformValue.__slot < 0) {\n          var slot = program.currentTextureSlot();\n          var res = program.setUniform(_gl, '1i', symbol, slot);\n          if (res) {\n            // Texture uniform is enabled\n            program.takeCurrentTextureSlot(this, uniformValue);\n            uniformValue.__slot = slot;\n          }\n        }\n        // Multiple uniform use same texture..\n        else {\n          program.setUniform(_gl, '1i', symbol, uniformValue.__slot);\n        }\n      } else if (Array.isArray(uniformValue)) {\n        if (uniformValue.length === 0) {\n          continue;\n        }\n        // Texture Array\n        if (uniformType === 'tv') {\n          if (!program.hasUniform(symbol)) {\n            continue;\n          }\n          var arr = [];\n          for (var i = 0; i < uniformValue.length; i++) {\n            var texture = uniformValue[i];\n            if (texture.__slot < 0) {\n              var slot = program.currentTextureSlot();\n              arr.push(slot);\n              program.takeCurrentTextureSlot(this, texture);\n              texture.__slot = slot;\n            } else {\n              arr.push(texture.__slot);\n            }\n          }\n          program.setUniform(_gl, '1iv', symbol, arr);\n        } else {\n          program.setUniform(_gl, uniform.type, symbol, uniformValue);\n        }\n      } else {\n        program.setUniform(_gl, uniform.type, symbol, uniformValue);\n      }\n    }\n    var newSlot = program.currentTextureSlot();\n    // Texture slot maybe used out of material.\n    program.resetTextureSlot(currentTextureSlot);\n    return newSlot;\n  },\n  _bindVAO: function (vaoExt, shader, geometry, program) {\n    var isStatic = !geometry.dynamic;\n    var _gl = this.gl;\n    var vaoId = this.__uid__ + '-' + program.__uid__;\n    var vao = geometry.__vaoCache[vaoId];\n    if (!vao) {\n      var chunks = geometry.getBufferChunks(this);\n      if (!chunks || !chunks.length) {\n        // Empty mesh\n        return;\n      }\n      var chunk = chunks[0];\n      var attributeBuffers = chunk.attributeBuffers;\n      var indicesBuffer = chunk.indicesBuffer;\n      var availableAttributes = [];\n      var availableAttributeSymbols = [];\n      for (var a = 0; a < attributeBuffers.length; a++) {\n        var attributeBufferInfo = attributeBuffers[a];\n        var name = attributeBufferInfo.name;\n        var semantic = attributeBufferInfo.semantic;\n        var symbol;\n        if (semantic) {\n          var semanticInfo = shader.attributeSemantics[semantic];\n          symbol = semanticInfo && semanticInfo.symbol;\n        } else {\n          symbol = name;\n        }\n        if (symbol && program.attributes[symbol]) {\n          availableAttributes.push(attributeBufferInfo);\n          availableAttributeSymbols.push(symbol);\n        }\n      }\n      vao = new VertexArrayObject(availableAttributes, availableAttributeSymbols, indicesBuffer);\n      if (isStatic) {\n        geometry.__vaoCache[vaoId] = vao;\n      }\n    }\n    var needsBindAttributes = true;\n\n    // Create vertex object array cost a lot\n    // So we don't use it on the dynamic object\n    if (vaoExt && isStatic) {\n      // Use vertex array object\n      // http://blog.tojicode.com/2012/10/oesvertexarrayobject-extension.html\n      if (vao.vao == null) {\n        vao.vao = vaoExt.createVertexArrayOES();\n      } else {\n        needsBindAttributes = false;\n      }\n      vaoExt.bindVertexArrayOES(vao.vao);\n    }\n    var availableAttributes = vao.availableAttributes;\n    var indicesBuffer = vao.indicesBuffer;\n    if (needsBindAttributes) {\n      var locationList = program.enableAttributes(this, vao.availableAttributeSymbols, vaoExt && isStatic && vao);\n      // Setting attributes;\n      for (var a = 0; a < availableAttributes.length; a++) {\n        var location = locationList[a];\n        if (location === -1) {\n          continue;\n        }\n        var attributeBufferInfo = availableAttributes[a];\n        var buffer = attributeBufferInfo.buffer;\n        var size = attributeBufferInfo.size;\n        var glType = attributeBufferTypeMap[attributeBufferInfo.type] || _gl.FLOAT;\n        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);\n        _gl.vertexAttribPointer(location, size, glType, false, 0, 0);\n      }\n      if (geometry.isUseIndices()) {\n        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, indicesBuffer.buffer);\n      }\n    }\n    return vao;\n  },\n  renderPreZ: function (list, scene, camera) {\n    var _gl = this.gl;\n    var preZPassMaterial = this._prezMaterial || new Material({\n      shader: new Shader(Shader.source('clay.prez.vertex'), Shader.source('clay.prez.fragment'))\n    });\n    this._prezMaterial = preZPassMaterial;\n    _gl.colorMask(false, false, false, false);\n    _gl.depthMask(true);\n\n    // Status\n    this.renderPass(list, camera, {\n      ifRender: function (renderable) {\n        return !renderable.ignorePreZ;\n      },\n      isMaterialChanged: function (renderable, prevRenderable) {\n        var matA = renderable.material;\n        var matB = prevRenderable.material;\n        return matA.get('diffuseMap') !== matB.get('diffuseMap') || (matA.get('alphaCutoff') || 0) !== (matB.get('alphaCutoff') || 0);\n      },\n      getUniform: function (renderable, depthMaterial, symbol) {\n        if (symbol === 'alphaMap') {\n          return renderable.material.get('diffuseMap');\n        } else if (symbol === 'alphaCutoff') {\n          if (renderable.material.isDefined('fragment', 'ALPHA_TEST') && renderable.material.get('diffuseMap')) {\n            var alphaCutoff = renderable.material.get('alphaCutoff');\n            return alphaCutoff || 0;\n          }\n          return 0;\n        } else if (symbol === 'uvRepeat') {\n          return renderable.material.get('uvRepeat');\n        } else if (symbol === 'uvOffset') {\n          return renderable.material.get('uvOffset');\n        } else {\n          return depthMaterial.get(symbol);\n        }\n      },\n      getMaterial: function () {\n        return preZPassMaterial;\n      },\n      sort: this.opaqueSortCompare\n    });\n    _gl.colorMask(true, true, true, true);\n    _gl.depthMask(true);\n  },\n  /**\n   * Dispose given scene, including all geometris, textures and shaders in the scene\n   * @param {clay.Scene} scene\n   */\n  disposeScene: function (scene) {\n    this.disposeNode(scene, true, true);\n    scene.dispose();\n  },\n  /**\n   * Dispose given node, including all geometries, textures and shaders attached on it or its descendant\n   * @param {clay.Node} node\n   * @param {boolean} [disposeGeometry=false] If dispose the geometries used in the descendant mesh\n   * @param {boolean} [disposeTexture=false] If dispose the textures used in the descendant mesh\n   */\n  disposeNode: function (root, disposeGeometry, disposeTexture) {\n    // Dettached from parent\n    if (root.getParent()) {\n      root.getParent().remove(root);\n    }\n    var disposedMap = {};\n    root.traverse(function (node) {\n      var material = node.material;\n      if (node.geometry && disposeGeometry) {\n        node.geometry.dispose(this);\n      }\n      if (disposeTexture && material && !disposedMap[material.__uid__]) {\n        var textureUniforms = material.getTextureUniforms();\n        for (var u = 0; u < textureUniforms.length; u++) {\n          var uniformName = textureUniforms[u];\n          var val = material.uniforms[uniformName].value;\n          var uniformType = material.uniforms[uniformName].type;\n          if (!val) {\n            continue;\n          }\n          if (uniformType === 't') {\n            val.dispose && val.dispose(this);\n          } else if (uniformType === 'tv') {\n            for (var k = 0; k < val.length; k++) {\n              if (val[k]) {\n                val[k].dispose && val[k].dispose(this);\n              }\n            }\n          }\n        }\n        disposedMap[material.__uid__] = true;\n      }\n      // Particle system and AmbientCubemap light need to dispose\n      if (node.dispose) {\n        node.dispose(this);\n      }\n    }, this);\n  },\n  /**\n   * Dispose given geometry\n   * @param {clay.Geometry} geometry\n   */\n  disposeGeometry: function (geometry) {\n    geometry.dispose(this);\n  },\n  /**\n   * Dispose given texture\n   * @param {clay.Texture} texture\n   */\n  disposeTexture: function (texture) {\n    texture.dispose(this);\n  },\n  /**\n   * Dispose given frame buffer\n   * @param {clay.FrameBuffer} frameBuffer\n   */\n  disposeFrameBuffer: function (frameBuffer) {\n    frameBuffer.dispose(this);\n  },\n  /**\n   * Dispose renderer\n   */\n  dispose: function () {},\n  /**\n   * Convert screen coords to normalized device coordinates(NDC)\n   * Screen coords can get from mouse event, it is positioned relative to canvas element\n   * NDC can be used in ray casting with Camera.prototype.castRay methods\n   *\n   * @param  {number}       x\n   * @param  {number}       y\n   * @param  {clay.Vector2} [out]\n   * @return {clay.Vector2}\n   */\n  screenToNDC: function (x, y, out) {\n    if (!out) {\n      out = new Vector2();\n    }\n    // Invert y;\n    y = this._height - y;\n    var viewport = this.viewport;\n    var arr = out.array;\n    arr[0] = (x - viewport.x) / viewport.width;\n    arr[0] = arr[0] * 2 - 1;\n    arr[1] = (y - viewport.y) / viewport.height;\n    arr[1] = arr[1] * 2 - 1;\n    return out;\n  }\n});\n\n/**\n * Opaque renderables compare function\n * @param  {clay.Renderable} x\n * @param  {clay.Renderable} y\n * @return {boolean}\n * @static\n */\nRenderer.opaqueSortCompare = Renderer.prototype.opaqueSortCompare = function (x, y) {\n  // Priority renderOrder -> program -> material -> geometry\n  if (x.renderOrder === y.renderOrder) {\n    if (x.__program === y.__program) {\n      if (x.material === y.material) {\n        return x.geometry.__uid__ - y.geometry.__uid__;\n      }\n      return x.material.__uid__ - y.material.__uid__;\n    }\n    if (x.__program && y.__program) {\n      return x.__program.__uid__ - y.__program.__uid__;\n    }\n    return 0;\n  }\n  return x.renderOrder - y.renderOrder;\n};\n\n/**\n * Transparent renderables compare function\n * @param  {clay.Renderable} a\n * @param  {clay.Renderable} b\n * @return {boolean}\n * @static\n */\nRenderer.transparentSortCompare = Renderer.prototype.transparentSortCompare = function (x, y) {\n  // Priority renderOrder -> depth -> program -> material -> geometry\n\n  if (x.renderOrder === y.renderOrder) {\n    if (x.__depth === y.__depth) {\n      if (x.__program === y.__program) {\n        if (x.material === y.material) {\n          return x.geometry.__uid__ - y.geometry.__uid__;\n        }\n        return x.material.__uid__ - y.material.__uid__;\n      }\n      if (x.__program && y.__program) {\n        return x.__program.__uid__ - y.__program.__uid__;\n      }\n      return 0;\n    }\n    // Depth is negative\n    // So farther object has smaller depth value\n    return x.__depth - y.__depth;\n  }\n  return x.renderOrder - y.renderOrder;\n};\n\n// Temporary variables\nvar matrices = {\n  IDENTITY: mat4Create(),\n  WORLD: mat4Create(),\n  VIEW: mat4Create(),\n  PROJECTION: mat4Create(),\n  WORLDVIEW: mat4Create(),\n  VIEWPROJECTION: mat4Create(),\n  WORLDVIEWPROJECTION: mat4Create(),\n  WORLDINVERSE: mat4Create(),\n  VIEWINVERSE: mat4Create(),\n  PROJECTIONINVERSE: mat4Create(),\n  WORLDVIEWINVERSE: mat4Create(),\n  VIEWPROJECTIONINVERSE: mat4Create(),\n  WORLDVIEWPROJECTIONINVERSE: mat4Create(),\n  WORLDTRANSPOSE: mat4Create(),\n  VIEWTRANSPOSE: mat4Create(),\n  PROJECTIONTRANSPOSE: mat4Create(),\n  WORLDVIEWTRANSPOSE: mat4Create(),\n  VIEWPROJECTIONTRANSPOSE: mat4Create(),\n  WORLDVIEWPROJECTIONTRANSPOSE: mat4Create(),\n  WORLDINVERSETRANSPOSE: mat4Create(),\n  VIEWINVERSETRANSPOSE: mat4Create(),\n  PROJECTIONINVERSETRANSPOSE: mat4Create(),\n  WORLDVIEWINVERSETRANSPOSE: mat4Create(),\n  VIEWPROJECTIONINVERSETRANSPOSE: mat4Create(),\n  WORLDVIEWPROJECTIONINVERSETRANSPOSE: mat4Create()\n};\n\n/**\n * @name clay.Renderer.COLOR_BUFFER_BIT\n * @type {number}\n */\nRenderer.COLOR_BUFFER_BIT = glenum.COLOR_BUFFER_BIT;\n/**\n * @name clay.Renderer.DEPTH_BUFFER_BIT\n * @type {number}\n */\nRenderer.DEPTH_BUFFER_BIT = glenum.DEPTH_BUFFER_BIT;\n/**\n * @name clay.Renderer.STENCIL_BUFFER_BIT\n * @type {number}\n */\nRenderer.STENCIL_BUFFER_BIT = glenum.STENCIL_BUFFER_BIT;\nexport default Renderer;","map":{"version":3,"names":["Base","GLInfo","glenum","vendor","Material","Vector2","ProgramManager","Shader","prezEssl","mat4","vec3","mat4Create","create","errorShader","defaultGetMaterial","renderable","material","defaultGetUniform","symbol","uniforms","value","defaultIsMaterialChanged","renderabled","prevRenderable","prevMaterial","defaultIfRender","noop","attributeBufferTypeMap","float","FLOAT","byte","BYTE","ubyte","UNSIGNED_BYTE","short","SHORT","ushort","UNSIGNED_SHORT","VertexArrayObject","availableAttributes","availableAttributeSymbols","indicesBuffer","vao","PlaceHolderTexture","renderer","blankCanvas","webglTexture","bind","createCanvas","width","height","getContext","gl","firstBind","createTexture","bindTexture","TEXTURE_2D","texImage2D","RGBA","unbind","isRenderable","Renderer","extend","canvas","_width","_height","devicePixelRatio","window","clearColor","clearBit","alpha","depth","stencil","antialias","premultipliedAlpha","preserveDrawingBuffer","throwError","viewport","maxJointNumber","__currentFrameBuffer","_viewportStack","_clearStack","_sceneRendering","opts","Error","_glinfo","targetRenderer","console","error","resize","e","_programMgr","_placeholderTexture","dpr","style","setViewport","getWidth","getHeight","getViewportAspect","setDevicePixelRatio","getDevicePixelRatio","getGLExtension","name","getExtension","getGLParameter","getParameter","x","y","obj","saveViewport","push","restoreViewport","length","pop","saveClear","restoreClear","opt","bindSceneRendering","scene","render","camera","notUpdateScene","preZ","_gl","colorMask","depthMask","needsScissor","viewportDpr","enable","SCISSOR_TEST","scissor","clear","disable","update","updateLights","getMainCamera","renderList","updateRenderList","opaqueList","opaque","transparentList","transparent","sceneMaterial","trigger","renderPreZ","depthFunc","LEQUAL","LESS","worldViewMat","posViewSpace","i","multiplyAffine","viewMatrix","array","worldTransform","transformMat4","position","__depth","renderPass","getMaterial","sortCompare","opaqueSortCompare","transparentSortCompare","getProgram","renderMaterial","validateProgram","program","__error","errorMsg","__uid__","updatePrograms","list","passConfig","call","prevJointsLen","joints","jointsLen","lightGroup","__program","getUniform","isMaterialChanged","beforeRender","afterRender","ifRenderObject","ifRender","sort","vDpr","viewportUniform","windowDpr","windowSizeUniform","getTextureWidth","getTextureHeight","viewportSizeUniform","time","Date","now","copy","matrices","VIEW","PROJECTION","projectionMatrix","VIEWINVERSE","identity","multiply","VIEWPROJECTION","invert","PROJECTIONINVERSE","VIEWPROJECTIONINVERSE","prevProgram","depthTest","culling","cullFace","frontFace","drawID","currentVAO","materialTakesTextureSlot","vaoExt","isSceneNode","worldM","isSkinnedMesh","offsetMatrix","IDENTITY","geometry","shader","currentDrawID","drawIDChanged","bindVertexArrayOES","WORLD","WORLDVIEWPROJECTION","WORLDVIEW","matrixSemantics","WORLDINVERSE","WORLDINVERSETRANSPOSE","WORLDVIEWINVERSE","WORLDVIEWINVERSETRANSPOSE","WORLDVIEWPROJECTIONINVERSE","WORLDVIEWPROJECTIONINVERSETRANSPOSE","programChanged","setUniformOfSemantic","near","far","setLightUniforms","DEPTH_TEST","BLEND","blend","blendEquationSeparate","FUNC_ADD","blendFuncSeparate","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","ONE","_bindMaterial","matrixSemanticKeys","k","semantic","semanticInfo","matrix","isTranspose","matrixNoTranspose","semanticNoTranspose","transpose","setUniform","type","CULL_FACE","_updateSkeleton","_bindVAO","_renderObject","getMaxJointNumber","object","slot","skeleton","skinMatricesTexture","getSubSkinMatricesTexture","useTextureSlot","skinMatricesArray","getSubSkinMatrices","glDrawMode","mode","ext","isInstanced","isInstancedMesh","warn","instancedAttrLocations","_bindInstancedAttributes","uintExt","useUintExt","indices","Uint32Array","indicesType","UNSIGNED_INT","drawElementsInstancedANGLE","count","getInstanceCount","drawElements","drawArraysInstancedANGLE","vertexCount","drawArrays","disableVertexAttribArray","instancedBuffers","getInstancedAttributesBuffers","locations","bufferObj","location","getAttribLocation","glType","enableVertexAttribArray","bindBuffer","ARRAY_BUFFER","buffer","vertexAttribPointer","size","vertexAttribDivisorANGLE","divisor","getUniformValue","sameProgram","currentTextureSlot","enabledUniforms","getEnabledUniforms","textureUniforms","getTextureUniforms","placeholderTexture","u","uniformValue","uniformType","__slot","uniform","isTexture","prevUniformValue","takeCurrentTextureSlot","res","Array","isArray","hasUniform","arr","texture","newSlot","resetTextureSlot","isStatic","dynamic","vaoId","__vaoCache","chunks","getBufferChunks","chunk","attributeBuffers","a","attributeBufferInfo","attributeSemantics","attributes","needsBindAttributes","createVertexArrayOES","locationList","enableAttributes","isUseIndices","ELEMENT_ARRAY_BUFFER","preZPassMaterial","_prezMaterial","source","ignorePreZ","matA","matB","get","depthMaterial","isDefined","alphaCutoff","disposeScene","disposeNode","dispose","root","disposeGeometry","disposeTexture","getParent","remove","disposedMap","traverse","node","uniformName","val","disposeFrameBuffer","frameBuffer","screenToNDC","out","prototype","renderOrder","WORLDTRANSPOSE","VIEWTRANSPOSE","PROJECTIONTRANSPOSE","WORLDVIEWTRANSPOSE","VIEWPROJECTIONTRANSPOSE","WORLDVIEWPROJECTIONTRANSPOSE","VIEWINVERSETRANSPOSE","PROJECTIONINVERSETRANSPOSE","VIEWPROJECTIONINVERSETRANSPOSE","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT"],"sources":["E:/mytest/node_modules/claygl/src/Renderer.js"],"sourcesContent":["// TODO Resources like shader, texture, geometry reference management\n// Trace and find out which shader, texture, geometry can be destroyed\nimport Base from './core/Base';\nimport GLInfo from './core/GLInfo';\nimport glenum from './core/glenum';\nimport vendor from './core/vendor';\n\nimport Material from './Material';\nimport Vector2 from './math/Vector2';\nimport ProgramManager from './gpu/ProgramManager';\n\n// Light header\nimport Shader from './Shader';\n\nimport prezEssl from './shader/source/prez.glsl.js';\nShader['import'](prezEssl);\n\nimport mat4 from './glmatrix/mat4';\nimport vec3 from './glmatrix/vec3';\n\nvar mat4Create = mat4.create;\n\nvar errorShader = {};\n\nfunction defaultGetMaterial(renderable) {\n    return renderable.material;\n}\nfunction defaultGetUniform(renderable, material, symbol) {\n    return material.uniforms[symbol].value;\n}\nfunction defaultIsMaterialChanged(renderabled, prevRenderable, material, prevMaterial) {\n    return material !== prevMaterial;\n}\nfunction defaultIfRender(renderable) {\n    return true;\n}\n\nfunction noop() {}\n\nvar attributeBufferTypeMap = {\n    float: glenum.FLOAT,\n    byte: glenum.BYTE,\n    ubyte: glenum.UNSIGNED_BYTE,\n    short: glenum.SHORT,\n    ushort: glenum.UNSIGNED_SHORT\n};\n\nfunction VertexArrayObject(availableAttributes, availableAttributeSymbols, indicesBuffer) {\n    this.availableAttributes = availableAttributes;\n    this.availableAttributeSymbols = availableAttributeSymbols;\n    this.indicesBuffer = indicesBuffer;\n\n    this.vao = null;\n}\n\nfunction PlaceHolderTexture(renderer) {\n    var blankCanvas;\n    var webglTexture;\n    this.bind = function (renderer) {\n        if (!blankCanvas) {\n            // TODO Environment not support createCanvas.\n            blankCanvas = vendor.createCanvas();\n            blankCanvas.width = blankCanvas.height = 1;\n            blankCanvas.getContext('2d');\n        }\n\n        var gl = renderer.gl;\n        var firstBind = !webglTexture;\n        if (firstBind) {\n            webglTexture = gl.createTexture();\n        }\n        gl.bindTexture(gl.TEXTURE_2D, webglTexture);\n        if (firstBind) {\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, blankCanvas);\n        }\n    };\n    this.unbind = function (renderer) {\n        renderer.gl.bindTexture(renderer.gl.TEXTURE_2D, null);\n    };\n    this.isRenderable = function () {\n        return true;\n    };\n}\n/**\n * @constructor clay.Renderer\n * @extends clay.core.Base\n */\nvar Renderer = Base.extend(function () {\n    return /** @lends clay.Renderer# */ {\n\n        /**\n         * @type {HTMLCanvasElement}\n         * @readonly\n         */\n        canvas: null,\n\n        /**\n         * Canvas width, set by resize method\n         * @type {number}\n         * @private\n         */\n        _width: 100,\n\n        /**\n         * Canvas width, set by resize method\n         * @type {number}\n         * @private\n         */\n        _height: 100,\n\n        /**\n         * Device pixel ratio, set by setDevicePixelRatio method\n         * Specially for high defination display\n         * @see http://www.khronos.org/webgl/wiki/HandlingHighDPI\n         * @type {number}\n         * @private\n         */\n        devicePixelRatio: (typeof window !== 'undefined' && window.devicePixelRatio) || 1.0,\n\n        /**\n         * Clear color\n         * @type {number[]}\n         */\n        clearColor: [0.0, 0.0, 0.0, 0.0],\n\n        /**\n         * Default:\n         *     _gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT | _gl.STENCIL_BUFFER_BIT\n         * @type {number}\n         */\n        clearBit: 17664,\n\n        // Settings when getting context\n        // http://www.khronos.org/registry/webgl/specs/latest/#2.4\n\n        /**\n         * If enable alpha, default true\n         * @type {boolean}\n         */\n        alpha: true,\n        /**\n         * If enable depth buffer, default true\n         * @type {boolean}\n         */\n        depth: true,\n        /**\n         * If enable stencil buffer, default false\n         * @type {boolean}\n         */\n        stencil: false,\n        /**\n         * If enable antialias, default true\n         * @type {boolean}\n         */\n        antialias: true,\n        /**\n         * If enable premultiplied alpha, default true\n         * @type {boolean}\n         */\n        premultipliedAlpha: true,\n        /**\n         * If preserve drawing buffer, default false\n         * @type {boolean}\n         */\n        preserveDrawingBuffer: false,\n        /**\n         * If throw context error, usually turned on in debug mode\n         * @type {boolean}\n         */\n        throwError: true,\n        /**\n         * WebGL Context created from given canvas\n         * @type {WebGLRenderingContext}\n         */\n        gl: null,\n        /**\n         * Renderer viewport, read-only, can be set by setViewport method\n         * @type {Object}\n         */\n        viewport: {},\n\n        /**\n         * Max joint number\n         * @type {number}\n         */\n        maxJointNumber: 20,\n\n        // Set by FrameBuffer#bind\n        __currentFrameBuffer: null,\n\n        _viewportStack: [],\n        _clearStack: [],\n\n        _sceneRendering: null\n    };\n}, function () {\n\n    if (!this.canvas) {\n        this.canvas = vendor.createCanvas();\n    }\n    var canvas = this.canvas;\n    try {\n        var opts = {\n            alpha: this.alpha,\n            depth: this.depth,\n            stencil: this.stencil,\n            antialias: this.antialias,\n            premultipliedAlpha: this.premultipliedAlpha,\n            preserveDrawingBuffer: this.preserveDrawingBuffer\n        };\n\n        this.gl = canvas.getContext('webgl', opts)\n            || canvas.getContext('experimental-webgl', opts);\n\n        if (!this.gl) {\n            throw new Error();\n        }\n\n        this._glinfo = new GLInfo(this.gl);\n\n        if (this.gl.targetRenderer) {\n            console.error('Already created a renderer');\n        }\n        this.gl.targetRenderer = this;\n\n        this.resize();\n    }\n    catch (e) {\n        throw 'Error creating WebGL Context ' + e;\n    }\n\n    // Init managers\n    this._programMgr = new ProgramManager(this);\n\n    this._placeholderTexture = new PlaceHolderTexture(this);\n},\n/** @lends clay.Renderer.prototype. **/\n{\n    /**\n     * Resize the canvas\n     * @param {number} width\n     * @param {number} height\n     */\n    resize: function(width, height) {\n        var canvas = this.canvas;\n        // http://www.khronos.org/webgl/wiki/HandlingHighDPI\n        // set the display size of the canvas.\n        var dpr = this.devicePixelRatio;\n        if (width != null) {\n            if (canvas.style) {\n                canvas.style.width = width + 'px';\n                canvas.style.height = height + 'px';\n            }\n            // set the size of the drawingBuffer\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n\n            this._width = width;\n            this._height = height;\n        }\n        else {\n            this._width = canvas.width / dpr;\n            this._height = canvas.height / dpr;\n        }\n\n        this.setViewport(0, 0, this._width, this._height);\n    },\n\n    /**\n     * Get renderer width\n     * @return {number}\n     */\n    getWidth: function () {\n        return this._width;\n    },\n\n    /**\n     * Get renderer height\n     * @return {number}\n     */\n    getHeight: function () {\n        return this._height;\n    },\n\n    /**\n     * Get viewport aspect,\n     * @return {number}\n     */\n    getViewportAspect: function () {\n        var viewport = this.viewport;\n        return viewport.width / viewport.height;\n    },\n\n    /**\n     * Set devicePixelRatio\n     * @param {number} devicePixelRatio\n     */\n    setDevicePixelRatio: function(devicePixelRatio) {\n        this.devicePixelRatio = devicePixelRatio;\n        this.resize(this._width, this._height);\n    },\n\n    /**\n     * Get devicePixelRatio\n     * @param {number} devicePixelRatio\n     */\n    getDevicePixelRatio: function () {\n        return this.devicePixelRatio;\n    },\n\n    /**\n     * Get WebGL extension\n     * @param {string} name\n     * @return {object}\n     */\n    getGLExtension: function (name) {\n        return this._glinfo.getExtension(name);\n    },\n\n    /**\n     * Get WebGL parameter\n     * @param {string} name\n     * @return {*}\n     */\n    getGLParameter: function (name) {\n        return this._glinfo.getParameter(name);\n    },\n\n    /**\n     * Set rendering viewport\n     * @param {number|Object} x\n     * @param {number} [y]\n     * @param {number} [width]\n     * @param {number} [height]\n     * @param {number} [devicePixelRatio]\n     *        Defaultly use the renderere devicePixelRatio\n     *        It needs to be 1 when setViewport is called by frameBuffer\n     *\n     * @example\n     *  setViewport(0,0,width,height,1)\n     *  setViewport({\n     *      x: 0,\n     *      y: 0,\n     *      width: width,\n     *      height: height,\n     *      devicePixelRatio: 1\n     *  })\n     */\n    setViewport: function (x, y, width, height, dpr) {\n\n        if (typeof x === 'object') {\n            var obj = x;\n\n            x = obj.x;\n            y = obj.y;\n            width = obj.width;\n            height = obj.height;\n            dpr = obj.devicePixelRatio;\n        }\n        dpr = dpr || this.devicePixelRatio;\n\n        this.gl.viewport(\n            x * dpr, y * dpr, width * dpr, height * dpr\n        );\n        // Use a fresh new object, not write property.\n        this.viewport = {\n            x: x,\n            y: y,\n            width: width,\n            height: height,\n            devicePixelRatio: dpr\n        };\n    },\n\n    /**\n     * Push current viewport into a stack\n     */\n    saveViewport: function () {\n        this._viewportStack.push(this.viewport);\n    },\n\n    /**\n     * Pop viewport from stack, restore in the renderer\n     */\n    restoreViewport: function () {\n        if (this._viewportStack.length > 0) {\n            this.setViewport(this._viewportStack.pop());\n        }\n    },\n\n    /**\n     * Push current clear into a stack\n     */\n    saveClear: function () {\n        this._clearStack.push({\n            clearBit: this.clearBit,\n            clearColor: this.clearColor\n        });\n    },\n\n    /**\n     * Pop clear from stack, restore in the renderer\n     */\n    restoreClear: function () {\n        if (this._clearStack.length > 0) {\n            var opt = this._clearStack.pop();\n            this.clearColor = opt.clearColor;\n            this.clearBit = opt.clearBit;\n        }\n    },\n\n    bindSceneRendering: function (scene) {\n        this._sceneRendering = scene;\n    },\n\n    /**\n     * Render the scene in camera to the screen or binded offline framebuffer\n     * @param  {clay.Scene}       scene\n     * @param  {clay.Camera}      camera\n     * @param  {boolean}     [notUpdateScene] If not call the scene.update methods in the rendering, default true\n     * @param  {boolean}     [preZ]           If use preZ optimization, default false\n     * @return {IRenderInfo}\n     */\n    render: function(scene, camera, notUpdateScene, preZ) {\n        var _gl = this.gl;\n\n        var clearColor = this.clearColor;\n\n        if (this.clearBit) {\n\n            // Must set depth and color mask true before clear\n            _gl.colorMask(true, true, true, true);\n            _gl.depthMask(true);\n            var viewport = this.viewport;\n            var needsScissor = false;\n            var viewportDpr = viewport.devicePixelRatio;\n            if (viewport.width !== this._width || viewport.height !== this._height\n                || (viewportDpr && viewportDpr !== this.devicePixelRatio)\n                || viewport.x || viewport.y\n            ) {\n                needsScissor = true;\n                // http://stackoverflow.com/questions/11544608/how-to-clear-a-rectangle-area-in-webgl\n                // Only clear the viewport\n                _gl.enable(_gl.SCISSOR_TEST);\n                _gl.scissor(viewport.x * viewportDpr, viewport.y * viewportDpr, viewport.width * viewportDpr, viewport.height * viewportDpr);\n            }\n            _gl.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);\n            _gl.clear(this.clearBit);\n            if (needsScissor) {\n                _gl.disable(_gl.SCISSOR_TEST);\n            }\n        }\n\n        // If the scene have been updated in the prepass like shadow map\n        // There is no need to update it again\n        if (!notUpdateScene) {\n            scene.update(false);\n        }\n        scene.updateLights();\n\n        camera = camera || scene.getMainCamera();\n        if (!camera) {\n            console.error('Can\\'t find camera in the scene.');\n            return;\n        }\n        camera.update();\n        var renderList = scene.updateRenderList(camera, true);\n\n        this._sceneRendering = scene;\n\n        var opaqueList = renderList.opaque;\n        var transparentList = renderList.transparent;\n        var sceneMaterial = scene.material;\n\n        scene.trigger('beforerender', this, scene, camera, renderList);\n\n        // Render pre z\n        if (preZ) {\n            this.renderPreZ(opaqueList, scene, camera);\n            _gl.depthFunc(_gl.LEQUAL);\n        }\n        else {\n            _gl.depthFunc(_gl.LESS);\n        }\n\n        // Update the depth of transparent list.\n        var worldViewMat = mat4Create();\n        var posViewSpace = vec3.create();\n        for (var i = 0; i < transparentList.length; i++) {\n            var renderable = transparentList[i];\n            mat4.multiplyAffine(worldViewMat, camera.viewMatrix.array, renderable.worldTransform.array);\n            vec3.transformMat4(posViewSpace, renderable.position.array, worldViewMat);\n            renderable.__depth = posViewSpace[2];\n        }\n\n        // Render opaque list\n        this.renderPass(opaqueList, camera, {\n            getMaterial: function (renderable) {\n                return sceneMaterial || renderable.material;\n            },\n            sortCompare: this.opaqueSortCompare\n        });\n\n        this.renderPass(transparentList, camera, {\n            getMaterial: function (renderable) {\n                return sceneMaterial || renderable.material;\n            },\n            sortCompare: this.transparentSortCompare\n        });\n\n        scene.trigger('afterrender', this, scene, camera, renderList);\n\n        // Cleanup\n        this._sceneRendering = null;\n    },\n\n    getProgram: function (renderable, renderMaterial, scene) {\n        renderMaterial = renderMaterial || renderable.material;\n        return this._programMgr.getProgram(renderable, renderMaterial, scene);\n    },\n\n    validateProgram: function (program) {\n        if (program.__error) {\n            var errorMsg = program.__error;\n            if (errorShader[program.__uid__]) {\n                return;\n            }\n            errorShader[program.__uid__] = true;\n\n            if (this.throwError) {\n                throw new Error(errorMsg);\n            }\n            else {\n                this.trigger('error', errorMsg);\n            }\n\n        }\n\n    },\n\n    updatePrograms: function (list, scene, passConfig) {\n        var getMaterial = (passConfig && passConfig.getMaterial) || defaultGetMaterial;\n        scene = scene || null;\n        for (var i = 0; i < list.length; i++) {\n            var renderable = list[i];\n            var renderMaterial = getMaterial.call(this, renderable);\n            if (i > 0) {\n                var prevRenderable = list[i - 1];\n                var prevJointsLen = prevRenderable.joints ? prevRenderable.joints.length : 0;\n                var jointsLen = renderable.joints ? renderable.joints.length : 0;\n                // Keep program not change if joints, material, lightGroup are same of two renderables.\n                if (jointsLen === prevJointsLen\n                    && renderable.material === prevRenderable.material\n                    && renderable.lightGroup === prevRenderable.lightGroup\n                ) {\n                    renderable.__program = prevRenderable.__program;\n                    continue;\n                }\n            }\n\n            var program = this._programMgr.getProgram(renderable, renderMaterial, scene);\n\n            this.validateProgram(program);\n\n            renderable.__program = program;\n        }\n    },\n\n    /**\n     * Render a single renderable list in camera in sequence\n     * @param {clay.Renderable[]} list List of all renderables.\n     * @param {clay.Camera} [camera] Camera provide view matrix and porjection matrix. It can be null.\n     * @param {Object} [passConfig]\n     * @param {Function} [passConfig.getMaterial] Get renderable material.\n     * @param {Function} [passConfig.getUniform] Get material uniform value.\n     * @param {Function} [passConfig.isMaterialChanged] If material changed.\n     * @param {Function} [passConfig.beforeRender] Before render each renderable.\n     * @param {Function} [passConfig.afterRender] After render each renderable\n     * @param {Function} [passConfig.ifRender] If render the renderable.\n     * @param {Function} [passConfig.sortCompare] Sort compare function.\n     * @return {IRenderInfo}\n     */\n    renderPass: function(list, camera, passConfig) {\n        this.trigger('beforerenderpass', this, list, camera, passConfig);\n\n        passConfig = passConfig || {};\n        passConfig.getMaterial = passConfig.getMaterial || defaultGetMaterial;\n        passConfig.getUniform = passConfig.getUniform || defaultGetUniform;\n        // PENDING Better solution?\n        passConfig.isMaterialChanged = passConfig.isMaterialChanged || defaultIsMaterialChanged;\n        passConfig.beforeRender = passConfig.beforeRender || noop;\n        passConfig.afterRender = passConfig.afterRender || noop;\n\n        var ifRenderObject = passConfig.ifRender || defaultIfRender;\n\n        this.updatePrograms(list, this._sceneRendering, passConfig);\n        if (passConfig.sortCompare) {\n            list.sort(passConfig.sortCompare);\n        }\n\n        // Some common builtin uniforms\n        var viewport = this.viewport;\n        var vDpr = viewport.devicePixelRatio;\n        var viewportUniform = [\n            viewport.x * vDpr, viewport.y * vDpr,\n            viewport.width * vDpr, viewport.height * vDpr\n        ];\n        var windowDpr = this.devicePixelRatio;\n        var windowSizeUniform = this.__currentFrameBuffer\n            ? [this.__currentFrameBuffer.getTextureWidth(), this.__currentFrameBuffer.getTextureHeight()]\n            : [this._width * windowDpr, this._height * windowDpr];\n        // DEPRECATED\n        var viewportSizeUniform = [\n            viewportUniform[2], viewportUniform[3]\n        ];\n        var time = Date.now();\n\n        // Calculate view and projection matrix\n        if (camera) {\n            mat4.copy(matrices.VIEW, camera.viewMatrix.array);\n            mat4.copy(matrices.PROJECTION, camera.projectionMatrix.array);\n            mat4.copy(matrices.VIEWINVERSE, camera.worldTransform.array);\n        }\n        else {\n            mat4.identity(matrices.VIEW);\n            mat4.identity(matrices.PROJECTION);\n            mat4.identity(matrices.VIEWINVERSE);\n        }\n        mat4.multiply(matrices.VIEWPROJECTION, matrices.PROJECTION, matrices.VIEW);\n        mat4.invert(matrices.PROJECTIONINVERSE, matrices.PROJECTION);\n        mat4.invert(matrices.VIEWPROJECTIONINVERSE, matrices.VIEWPROJECTION);\n\n        var _gl = this.gl;\n        var scene = this._sceneRendering;\n\n        var prevMaterial;\n        var prevProgram;\n        var prevRenderable;\n\n        // Status\n        var depthTest, depthMask;\n        var culling, cullFace, frontFace;\n        var transparent;\n        var drawID;\n        var currentVAO;\n        var materialTakesTextureSlot;\n\n        // var vaoExt = this.getGLExtension('OES_vertex_array_object');\n        // not use vaoExt, some platforms may mess it up.\n        var vaoExt = null;\n\n        for (var i = 0; i < list.length; i++) {\n            var renderable = list[i];\n            var isSceneNode = renderable.worldTransform != null;\n            var worldM;\n\n            if (!ifRenderObject(renderable)) {\n                continue;\n            }\n\n            // Skinned mesh will transformed to joint space. Ignore the mesh transform\n            if (isSceneNode) {\n                worldM = (renderable.isSkinnedMesh && renderable.isSkinnedMesh())\n                    // TODO\n                    ? (renderable.offsetMatrix ? renderable.offsetMatrix.array :matrices.IDENTITY)\n                    : renderable.worldTransform.array;\n            }\n            var geometry = renderable.geometry;\n            var material = passConfig.getMaterial.call(this, renderable);\n\n            var program = renderable.__program;\n            var shader = material.shader;\n\n            var currentDrawID = geometry.__uid__ + '-' + program.__uid__;\n            var drawIDChanged = currentDrawID !== drawID;\n            drawID = currentDrawID;\n            if (drawIDChanged && vaoExt) {\n                // TODO Seems need to be bound to null immediately (or before bind another program?) if vao is changed\n                vaoExt.bindVertexArrayOES(null);\n            }\n            if (isSceneNode) {\n                mat4.copy(matrices.WORLD, worldM);\n                mat4.multiply(matrices.WORLDVIEWPROJECTION, matrices.VIEWPROJECTION, worldM);\n                mat4.multiplyAffine(matrices.WORLDVIEW, matrices.VIEW, worldM);\n                if (shader.matrixSemantics.WORLDINVERSE ||\n                    shader.matrixSemantics.WORLDINVERSETRANSPOSE) {\n                    mat4.invert(matrices.WORLDINVERSE, worldM);\n                }\n                if (shader.matrixSemantics.WORLDVIEWINVERSE ||\n                    shader.matrixSemantics.WORLDVIEWINVERSETRANSPOSE) {\n                    mat4.invert(matrices.WORLDVIEWINVERSE, matrices.WORLDVIEW);\n                }\n                if (shader.matrixSemantics.WORLDVIEWPROJECTIONINVERSE ||\n                    shader.matrixSemantics.WORLDVIEWPROJECTIONINVERSETRANSPOSE) {\n                    mat4.invert(matrices.WORLDVIEWPROJECTIONINVERSE, matrices.WORLDVIEWPROJECTION);\n                }\n            }\n\n            // Before render hook\n            renderable.beforeRender && renderable.beforeRender(this);\n            passConfig.beforeRender.call(this, renderable, material, prevMaterial);\n\n            var programChanged = program !== prevProgram;\n            if (programChanged) {\n                // Set lights number\n                program.bind(this);\n                // Set some common uniforms\n                program.setUniformOfSemantic(_gl, 'VIEWPORT', viewportUniform);\n                program.setUniformOfSemantic(_gl, 'WINDOW_SIZE', windowSizeUniform);\n                if (camera) {\n                    program.setUniformOfSemantic(_gl, 'NEAR', camera.near);\n                    program.setUniformOfSemantic(_gl, 'FAR', camera.far);\n                }\n                program.setUniformOfSemantic(_gl, 'DEVICEPIXELRATIO', vDpr);\n                program.setUniformOfSemantic(_gl, 'TIME', time);\n                // DEPRECATED\n                program.setUniformOfSemantic(_gl, 'VIEWPORT_SIZE', viewportSizeUniform);\n\n                // Set lights uniforms\n                // TODO needs optimized\n                if (scene) {\n                    scene.setLightUniforms(program, renderable.lightGroup, this);\n                }\n            }\n            else {\n                program = prevProgram;\n            }\n\n            // Program changes also needs reset the materials.\n            if (programChanged || passConfig.isMaterialChanged(\n                renderable, prevRenderable, material, prevMaterial\n            )) {\n                if (material.depthTest !== depthTest) {\n                    material.depthTest ? _gl.enable(_gl.DEPTH_TEST) : _gl.disable(_gl.DEPTH_TEST);\n                    depthTest = material.depthTest;\n                }\n                if (material.depthMask !== depthMask) {\n                    _gl.depthMask(material.depthMask);\n                    depthMask = material.depthMask;\n                }\n                if (material.transparent !== transparent) {\n                    material.transparent ? _gl.enable(_gl.BLEND) : _gl.disable(_gl.BLEND);\n                    transparent = material.transparent;\n                }\n                // TODO cache blending\n                if (material.transparent) {\n                    if (material.blend) {\n                        material.blend(_gl);\n                    }\n                    else {\n                        // Default blend function\n                        _gl.blendEquationSeparate(_gl.FUNC_ADD, _gl.FUNC_ADD);\n                        _gl.blendFuncSeparate(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA);\n                    }\n                }\n\n                materialTakesTextureSlot = this._bindMaterial(\n                    renderable, material, program,\n                    prevRenderable || null, prevMaterial || null, prevProgram || null,\n                    passConfig.getUniform\n                );\n                prevMaterial = material;\n            }\n\n            var matrixSemanticKeys = shader.matrixSemanticKeys;\n\n            if (isSceneNode) {\n                for (var k = 0; k < matrixSemanticKeys.length; k++) {\n                    var semantic = matrixSemanticKeys[k];\n                    var semanticInfo = shader.matrixSemantics[semantic];\n                    var matrix = matrices[semantic];\n                    if (semanticInfo.isTranspose) {\n                        var matrixNoTranspose = matrices[semanticInfo.semanticNoTranspose];\n                        mat4.transpose(matrix, matrixNoTranspose);\n                    }\n                    program.setUniform(_gl, semanticInfo.type, semanticInfo.symbol, matrix);\n                }\n            }\n\n            if (renderable.cullFace !== cullFace) {\n                cullFace = renderable.cullFace;\n                _gl.cullFace(cullFace);\n            }\n            if (renderable.frontFace !== frontFace) {\n                frontFace = renderable.frontFace;\n                _gl.frontFace(frontFace);\n            }\n            if (renderable.culling !== culling) {\n                culling = renderable.culling;\n                culling ? _gl.enable(_gl.CULL_FACE) : _gl.disable(_gl.CULL_FACE);\n            }\n            // TODO Not update skeleton in each renderable.\n            this._updateSkeleton(renderable, program, materialTakesTextureSlot);\n            if (drawIDChanged) {\n                currentVAO = this._bindVAO(vaoExt, shader, geometry, program);\n            }\n            this._renderObject(renderable, currentVAO, program);\n\n            // After render hook\n            passConfig.afterRender(this, renderable);\n            renderable.afterRender && renderable.afterRender(this);\n\n            prevProgram = program;\n            prevRenderable = renderable;\n        }\n\n        // TODO Seems need to be bound to null immediately if vao is changed?\n        if (vaoExt) {\n            vaoExt.bindVertexArrayOES(null);\n        }\n\n        this.trigger('afterrenderpass', this, list, camera, passConfig);\n    },\n\n    getMaxJointNumber: function () {\n        return this.maxJointNumber;\n    },\n\n    _updateSkeleton: function (object, program, slot) {\n        var _gl = this.gl;\n        var skeleton = object.skeleton;\n        // Set pose matrices of skinned mesh\n        if (skeleton) {\n            // TODO Update before culling.\n            skeleton.update();\n            if (object.joints.length > this.getMaxJointNumber()) {\n                var skinMatricesTexture = skeleton.getSubSkinMatricesTexture(object.__uid__, object.joints);\n                program.useTextureSlot(this, skinMatricesTexture, slot);\n                program.setUniform(_gl, '1i', 'skinMatricesTexture', slot);\n                program.setUniform(_gl, '1f', 'skinMatricesTextureSize', skinMatricesTexture.width);\n            }\n            else {\n                var skinMatricesArray = skeleton.getSubSkinMatrices(object.__uid__, object.joints);\n                program.setUniformOfSemantic(_gl, 'SKIN_MATRIX', skinMatricesArray);\n            }\n        }\n    },\n\n    _renderObject: function (renderable, vao, program) {\n        var _gl = this.gl;\n        var geometry = renderable.geometry;\n\n        var glDrawMode = renderable.mode;\n        if (glDrawMode == null) {\n            glDrawMode = 0x0004;\n        }\n\n        var ext = null;\n        var isInstanced = renderable.isInstancedMesh && renderable.isInstancedMesh();\n        if (isInstanced) {\n            ext = this.getGLExtension('ANGLE_instanced_arrays');\n            if (!ext) {\n                console.warn('Device not support ANGLE_instanced_arrays extension');\n                return;\n            }\n        }\n\n        var instancedAttrLocations;\n        if (isInstanced) {\n            instancedAttrLocations = this._bindInstancedAttributes(renderable, program, ext);\n        }\n\n        if (vao.indicesBuffer) {\n            var uintExt = this.getGLExtension('OES_element_index_uint');\n            var useUintExt = uintExt && (geometry.indices instanceof Uint32Array);\n            var indicesType = useUintExt ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;\n\n            if (isInstanced) {\n                ext.drawElementsInstancedANGLE(\n                    glDrawMode, vao.indicesBuffer.count, indicesType, 0, renderable.getInstanceCount()\n                );\n            }\n            else {\n                _gl.drawElements(glDrawMode, vao.indicesBuffer.count, indicesType, 0);\n            }\n        }\n        else {\n            if (isInstanced) {\n                ext.drawArraysInstancedANGLE(glDrawMode, 0, geometry.vertexCount, renderable.getInstanceCount());\n            }\n            else {\n                // FIXME Use vertex number in buffer\n                // vertexCount may get the wrong value when geometry forget to mark dirty after update\n                _gl.drawArrays(glDrawMode, 0, geometry.vertexCount);\n            }\n        }\n\n        if (isInstanced) {\n            for (var i = 0; i < instancedAttrLocations.length; i++) {\n                _gl.disableVertexAttribArray(instancedAttrLocations[i]);\n            }\n        }\n    },\n\n    _bindInstancedAttributes: function (renderable, program, ext) {\n        var _gl = this.gl;\n        var instancedBuffers = renderable.getInstancedAttributesBuffers(this);\n        var locations = [];\n\n        for (var i = 0; i < instancedBuffers.length; i++) {\n            var bufferObj = instancedBuffers[i];\n            var location = program.getAttribLocation(_gl, bufferObj.symbol);\n            if (location < 0) {\n                continue;\n            }\n\n            var glType = attributeBufferTypeMap[bufferObj.type] || _gl.FLOAT;;\n            _gl.enableVertexAttribArray(location);  // TODO\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, bufferObj.buffer);\n            _gl.vertexAttribPointer(location, bufferObj.size, glType, false, 0, 0);\n            ext.vertexAttribDivisorANGLE(location, bufferObj.divisor);\n\n            locations.push(location);\n        }\n\n        return locations;\n    },\n\n    _bindMaterial: function (renderable, material, program, prevRenderable, prevMaterial, prevProgram, getUniformValue) {\n        var _gl = this.gl;\n        // PENDING Same texture in different material take different slot?\n\n        // May use shader of other material if shader code are same\n        var sameProgram = prevProgram === program;\n\n        var currentTextureSlot = program.currentTextureSlot();\n        var enabledUniforms = material.getEnabledUniforms();\n        var textureUniforms = material.getTextureUniforms();\n        var placeholderTexture = this._placeholderTexture;\n\n        for (var u = 0; u < textureUniforms.length; u++) {\n            var symbol = textureUniforms[u];\n            var uniformValue = getUniformValue(renderable, material, symbol);\n            var uniformType = material.uniforms[symbol].type;\n            // Not use `instanceof` to determine if a value is texture in Material#bind.\n            // Use type instead, in some case texture may be in different namespaces.\n            // TODO Duck type validate.\n            if (uniformType === 't' && uniformValue) {\n                // Reset slot\n                uniformValue.__slot = -1;\n            }\n            else if (uniformType === 'tv') {\n                for (var i = 0; i < uniformValue.length; i++) {\n                    if (uniformValue[i]) {\n                        uniformValue[i].__slot = -1;\n                    }\n                }\n            }\n        }\n\n        placeholderTexture.__slot = -1;\n\n        // Set uniforms\n        for (var u = 0; u < enabledUniforms.length; u++) {\n            var symbol = enabledUniforms[u];\n            var uniform = material.uniforms[symbol];\n            var uniformValue = getUniformValue(renderable, material, symbol);\n            var uniformType = uniform.type;\n            var isTexture = uniformType === 't';\n\n            if (isTexture) {\n                if (!uniformValue || !uniformValue.isRenderable()) {\n                    uniformValue = placeholderTexture;\n                }\n            }\n            // PENDING\n            // When binding two materials with the same shader\n            // Many uniforms will be be set twice even if they have the same value\n            // So add a evaluation to see if the uniform is really needed to be set\n            if (prevMaterial && sameProgram) {\n                var prevUniformValue = getUniformValue(prevRenderable, prevMaterial, symbol);\n                if (isTexture) {\n                    if (!prevUniformValue || !prevUniformValue.isRenderable()) {\n                        prevUniformValue = placeholderTexture;\n                    }\n                }\n\n                if (prevUniformValue === uniformValue) {\n                    if (isTexture) {\n                        // Still take the slot to make sure same texture in different materials have same slot.\n                        program.takeCurrentTextureSlot(this, null);\n                    }\n                    else if (uniformType === 'tv' && uniformValue) {\n                        for (var i = 0; i < uniformValue.length; i++) {\n                            program.takeCurrentTextureSlot(this, null);\n                        }\n                    }\n                    continue;\n                }\n            }\n\n            if (uniformValue == null) {\n                continue;\n            }\n            else if (isTexture) {\n                if (uniformValue.__slot < 0) {\n                    var slot = program.currentTextureSlot();\n                    var res = program.setUniform(_gl, '1i', symbol, slot);\n                    if (res) { // Texture uniform is enabled\n                        program.takeCurrentTextureSlot(this, uniformValue);\n                        uniformValue.__slot = slot;\n                    }\n                }\n                // Multiple uniform use same texture..\n                else {\n                    program.setUniform(_gl, '1i', symbol, uniformValue.__slot);\n                }\n            }\n            else if (Array.isArray(uniformValue)) {\n                if (uniformValue.length === 0) {\n                    continue;\n                }\n                // Texture Array\n                if (uniformType === 'tv') {\n                    if (!program.hasUniform(symbol)) {\n                        continue;\n                    }\n\n                    var arr = [];\n                    for (var i = 0; i < uniformValue.length; i++) {\n                        var texture = uniformValue[i];\n\n                        if (texture.__slot < 0) {\n                            var slot = program.currentTextureSlot();\n                            arr.push(slot);\n                            program.takeCurrentTextureSlot(this, texture);\n                            texture.__slot = slot;\n                        }\n                        else {\n                            arr.push(texture.__slot);\n                        }\n                    }\n\n                    program.setUniform(_gl, '1iv', symbol, arr);\n                }\n                else {\n                    program.setUniform(_gl, uniform.type, symbol, uniformValue);\n                }\n            }\n            else{\n                program.setUniform(_gl, uniform.type, symbol, uniformValue);\n            }\n        }\n        var newSlot = program.currentTextureSlot();\n        // Texture slot maybe used out of material.\n        program.resetTextureSlot(currentTextureSlot);\n        return newSlot;\n    },\n\n    _bindVAO: function (vaoExt, shader, geometry, program) {\n        var isStatic = !geometry.dynamic;\n        var _gl = this.gl;\n\n        var vaoId = this.__uid__ + '-' + program.__uid__;\n        var vao = geometry.__vaoCache[vaoId];\n        if (!vao) {\n            var chunks = geometry.getBufferChunks(this);\n            if (!chunks || !chunks.length) {  // Empty mesh\n                return;\n            }\n            var chunk = chunks[0];\n            var attributeBuffers = chunk.attributeBuffers;\n            var indicesBuffer = chunk.indicesBuffer;\n\n            var availableAttributes = [];\n            var availableAttributeSymbols = [];\n            for (var a = 0; a < attributeBuffers.length; a++) {\n                var attributeBufferInfo = attributeBuffers[a];\n                var name = attributeBufferInfo.name;\n                var semantic = attributeBufferInfo.semantic;\n                var symbol;\n                if (semantic) {\n                    var semanticInfo = shader.attributeSemantics[semantic];\n                    symbol = semanticInfo && semanticInfo.symbol;\n                }\n                else {\n                    symbol = name;\n                }\n                if (symbol && program.attributes[symbol]) {\n                    availableAttributes.push(attributeBufferInfo);\n                    availableAttributeSymbols.push(symbol);\n                }\n            }\n\n            vao = new VertexArrayObject(\n                availableAttributes,\n                availableAttributeSymbols,\n                indicesBuffer\n            );\n\n            if (isStatic) {\n                geometry.__vaoCache[vaoId] = vao;\n            }\n        }\n\n        var needsBindAttributes = true;\n\n        // Create vertex object array cost a lot\n        // So we don't use it on the dynamic object\n        if (vaoExt && isStatic) {\n            // Use vertex array object\n            // http://blog.tojicode.com/2012/10/oesvertexarrayobject-extension.html\n            if (vao.vao == null) {\n                vao.vao = vaoExt.createVertexArrayOES();\n            }\n            else {\n                needsBindAttributes = false;\n            }\n            vaoExt.bindVertexArrayOES(vao.vao);\n        }\n\n        var availableAttributes = vao.availableAttributes;\n        var indicesBuffer = vao.indicesBuffer;\n\n        if (needsBindAttributes) {\n            var locationList = program.enableAttributes(this, vao.availableAttributeSymbols, (vaoExt && isStatic && vao));\n            // Setting attributes;\n            for (var a = 0; a < availableAttributes.length; a++) {\n                var location = locationList[a];\n                if (location === -1) {\n                    continue;\n                }\n                var attributeBufferInfo = availableAttributes[a];\n                var buffer = attributeBufferInfo.buffer;\n                var size = attributeBufferInfo.size;\n                var glType = attributeBufferTypeMap[attributeBufferInfo.type] || _gl.FLOAT;\n\n                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);\n                _gl.vertexAttribPointer(location, size, glType, false, 0, 0);\n            }\n\n            if (geometry.isUseIndices()) {\n                _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, indicesBuffer.buffer);\n            }\n        }\n\n        return vao;\n    },\n\n    renderPreZ: function (list, scene, camera) {\n        var _gl = this.gl;\n        var preZPassMaterial = this._prezMaterial || new Material({\n            shader: new Shader(Shader.source('clay.prez.vertex'), Shader.source('clay.prez.fragment'))\n        });\n        this._prezMaterial = preZPassMaterial;\n\n        _gl.colorMask(false, false, false, false);\n        _gl.depthMask(true);\n\n        // Status\n        this.renderPass(list, camera, {\n            ifRender: function (renderable) {\n                return !renderable.ignorePreZ;\n            },\n            isMaterialChanged: function (renderable, prevRenderable) {\n                var matA = renderable.material;\n                var matB = prevRenderable.material;\n                return matA.get('diffuseMap') !== matB.get('diffuseMap')\n                    || (matA.get('alphaCutoff') || 0) !== (matB.get('alphaCutoff') || 0);\n            },\n            getUniform: function (renderable, depthMaterial, symbol) {\n                if (symbol === 'alphaMap') {\n                    return renderable.material.get('diffuseMap');\n                }\n                else if (symbol === 'alphaCutoff') {\n                    if (renderable.material.isDefined('fragment', 'ALPHA_TEST')\n                        && renderable.material.get('diffuseMap')\n                    ) {\n                        var alphaCutoff = renderable.material.get('alphaCutoff');\n                        return alphaCutoff || 0;\n                    }\n                    return 0;\n                }\n                else if (symbol === 'uvRepeat') {\n                    return renderable.material.get('uvRepeat');\n                }\n                else if (symbol === 'uvOffset') {\n                    return renderable.material.get('uvOffset');\n                }\n                else {\n                    return depthMaterial.get(symbol);\n                }\n            },\n            getMaterial: function () {\n                return preZPassMaterial;\n            },\n            sort: this.opaqueSortCompare\n        });\n\n        _gl.colorMask(true, true, true, true);\n        _gl.depthMask(true);\n    },\n\n    /**\n     * Dispose given scene, including all geometris, textures and shaders in the scene\n     * @param {clay.Scene} scene\n     */\n    disposeScene: function(scene) {\n        this.disposeNode(scene, true, true);\n        scene.dispose();\n    },\n\n    /**\n     * Dispose given node, including all geometries, textures and shaders attached on it or its descendant\n     * @param {clay.Node} node\n     * @param {boolean} [disposeGeometry=false] If dispose the geometries used in the descendant mesh\n     * @param {boolean} [disposeTexture=false] If dispose the textures used in the descendant mesh\n     */\n    disposeNode: function(root, disposeGeometry, disposeTexture) {\n        // Dettached from parent\n        if (root.getParent()) {\n            root.getParent().remove(root);\n        }\n        var disposedMap = {};\n        root.traverse(function(node) {\n            var material = node.material;\n            if (node.geometry && disposeGeometry) {\n                node.geometry.dispose(this);\n            }\n            if (disposeTexture && material && !disposedMap[material.__uid__]) {\n                var textureUniforms = material.getTextureUniforms();\n                for (var u = 0; u < textureUniforms.length; u++) {\n                    var uniformName = textureUniforms[u];\n                    var val = material.uniforms[uniformName].value;\n                    var uniformType = material.uniforms[uniformName].type;\n                    if (!val) {\n                        continue;\n                    }\n                    if (uniformType === 't') {\n                        val.dispose && val.dispose(this);\n                    }\n                    else if (uniformType === 'tv') {\n                        for (var k = 0; k < val.length; k++) {\n                            if (val[k]) {\n                                val[k].dispose && val[k].dispose(this);\n                            }\n                        }\n                    }\n                }\n                disposedMap[material.__uid__] = true;\n            }\n            // Particle system and AmbientCubemap light need to dispose\n            if (node.dispose) {\n                node.dispose(this);\n            }\n        }, this);\n    },\n\n    /**\n     * Dispose given geometry\n     * @param {clay.Geometry} geometry\n     */\n    disposeGeometry: function(geometry) {\n        geometry.dispose(this);\n    },\n\n    /**\n     * Dispose given texture\n     * @param {clay.Texture} texture\n     */\n    disposeTexture: function(texture) {\n        texture.dispose(this);\n    },\n\n    /**\n     * Dispose given frame buffer\n     * @param {clay.FrameBuffer} frameBuffer\n     */\n    disposeFrameBuffer: function(frameBuffer) {\n        frameBuffer.dispose(this);\n    },\n\n    /**\n     * Dispose renderer\n     */\n    dispose: function () {},\n\n    /**\n     * Convert screen coords to normalized device coordinates(NDC)\n     * Screen coords can get from mouse event, it is positioned relative to canvas element\n     * NDC can be used in ray casting with Camera.prototype.castRay methods\n     *\n     * @param  {number}       x\n     * @param  {number}       y\n     * @param  {clay.Vector2} [out]\n     * @return {clay.Vector2}\n     */\n    screenToNDC: function(x, y, out) {\n        if (!out) {\n            out = new Vector2();\n        }\n        // Invert y;\n        y = this._height - y;\n\n        var viewport = this.viewport;\n        var arr = out.array;\n        arr[0] = (x - viewport.x) / viewport.width;\n        arr[0] = arr[0] * 2 - 1;\n        arr[1] = (y - viewport.y) / viewport.height;\n        arr[1] = arr[1] * 2 - 1;\n\n        return out;\n    }\n});\n\n/**\n * Opaque renderables compare function\n * @param  {clay.Renderable} x\n * @param  {clay.Renderable} y\n * @return {boolean}\n * @static\n */\nRenderer.opaqueSortCompare = Renderer.prototype.opaqueSortCompare = function(x, y) {\n    // Priority renderOrder -> program -> material -> geometry\n    if (x.renderOrder === y.renderOrder) {\n        if (x.__program === y.__program) {\n            if (x.material === y.material) {\n                return x.geometry.__uid__ - y.geometry.__uid__;\n            }\n            return x.material.__uid__ - y.material.__uid__;\n        }\n        if (x.__program && y.__program) {\n            return x.__program.__uid__ - y.__program.__uid__;\n        }\n        return 0;\n    }\n    return x.renderOrder - y.renderOrder;\n};\n\n/**\n * Transparent renderables compare function\n * @param  {clay.Renderable} a\n * @param  {clay.Renderable} b\n * @return {boolean}\n * @static\n */\nRenderer.transparentSortCompare = Renderer.prototype.transparentSortCompare = function(x, y) {\n    // Priority renderOrder -> depth -> program -> material -> geometry\n\n    if (x.renderOrder === y.renderOrder) {\n        if (x.__depth === y.__depth) {\n            if (x.__program === y.__program) {\n                if (x.material === y.material) {\n                    return x.geometry.__uid__ - y.geometry.__uid__;\n                }\n                return x.material.__uid__ - y.material.__uid__;\n            }\n            if (x.__program  && y.__program) {\n                return x.__program.__uid__ - y.__program.__uid__;\n            }\n            return 0;\n        }\n        // Depth is negative\n        // So farther object has smaller depth value\n        return x.__depth - y.__depth;\n    }\n    return x.renderOrder - y.renderOrder;\n};\n\n// Temporary variables\nvar matrices = {\n    IDENTITY: mat4Create(),\n\n    WORLD: mat4Create(),\n    VIEW: mat4Create(),\n    PROJECTION: mat4Create(),\n    WORLDVIEW: mat4Create(),\n    VIEWPROJECTION: mat4Create(),\n    WORLDVIEWPROJECTION: mat4Create(),\n\n    WORLDINVERSE: mat4Create(),\n    VIEWINVERSE: mat4Create(),\n    PROJECTIONINVERSE: mat4Create(),\n    WORLDVIEWINVERSE: mat4Create(),\n    VIEWPROJECTIONINVERSE: mat4Create(),\n    WORLDVIEWPROJECTIONINVERSE: mat4Create(),\n\n    WORLDTRANSPOSE: mat4Create(),\n    VIEWTRANSPOSE: mat4Create(),\n    PROJECTIONTRANSPOSE: mat4Create(),\n    WORLDVIEWTRANSPOSE: mat4Create(),\n    VIEWPROJECTIONTRANSPOSE: mat4Create(),\n    WORLDVIEWPROJECTIONTRANSPOSE: mat4Create(),\n    WORLDINVERSETRANSPOSE: mat4Create(),\n    VIEWINVERSETRANSPOSE: mat4Create(),\n    PROJECTIONINVERSETRANSPOSE: mat4Create(),\n    WORLDVIEWINVERSETRANSPOSE: mat4Create(),\n    VIEWPROJECTIONINVERSETRANSPOSE: mat4Create(),\n    WORLDVIEWPROJECTIONINVERSETRANSPOSE: mat4Create()\n};\n\n/**\n * @name clay.Renderer.COLOR_BUFFER_BIT\n * @type {number}\n */\nRenderer.COLOR_BUFFER_BIT = glenum.COLOR_BUFFER_BIT;\n/**\n * @name clay.Renderer.DEPTH_BUFFER_BIT\n * @type {number}\n */\nRenderer.DEPTH_BUFFER_BIT = glenum.DEPTH_BUFFER_BIT;\n/**\n * @name clay.Renderer.STENCIL_BUFFER_BIT\n * @type {number}\n */\nRenderer.STENCIL_BUFFER_BIT = glenum.STENCIL_BUFFER_BIT;\n\nexport default Renderer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}