{"ast":null,"code":"import \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport * as echarts from 'echarts/lib/echarts';\nimport graphicGL from '../../util/graphicGL';\nimport spriteUtil from '../../util/sprite';\nimport PointsMesh from './PointsMesh';\nimport LabelsBuilder from '../../component/common/LabelsBuilder';\nimport Matrix4 from 'claygl/src/math/Matrix4';\nimport retrieve from '../../util/retrieve';\nimport { getItemVisualColor, getItemVisualOpacity } from '../../util/visual';\nimport { getVisualColor, getVisualOpacity } from '../../util/visual';\nvar SDF_RANGE = 20;\nvar Z_2D = -10;\nfunction isSymbolSizeSame(a, b) {\n  return a && b && a[0] === b[0] && a[1] === b[1];\n} // TODO gl_PointSize has max value.\n\nfunction PointsBuilder(is2D, api) {\n  this.rootNode = new graphicGL.Node();\n  /**\n   * @type {boolean}\n   */\n\n  this.is2D = is2D;\n  this._labelsBuilder = new LabelsBuilder(256, 256, api); // Give a large render order.\n\n  this._labelsBuilder.getMesh().renderOrder = 100;\n  this.rootNode.add(this._labelsBuilder.getMesh());\n  this._api = api;\n  this._spriteImageCanvas = document.createElement('canvas');\n  this._startDataIndex = 0;\n  this._endDataIndex = 0;\n  this._sizeScale = 1;\n}\nPointsBuilder.prototype = {\n  constructor: PointsBuilder,\n  /**\n   * If highlight on over\n   */\n  highlightOnMouseover: true,\n  update: function (seriesModel, ecModel, api, start, end) {\n    // Swap barMesh\n    var tmp = this._prevMesh;\n    this._prevMesh = this._mesh;\n    this._mesh = tmp;\n    var data = seriesModel.getData();\n    if (start == null) {\n      start = 0;\n    }\n    if (end == null) {\n      end = data.count();\n    }\n    this._startDataIndex = start;\n    this._endDataIndex = end - 1;\n    if (!this._mesh) {\n      var material = this._prevMesh && this._prevMesh.material;\n      this._mesh = new PointsMesh({\n        // Render after axes\n        renderOrder: 10,\n        // FIXME\n        frustumCulling: false\n      });\n      if (material) {\n        this._mesh.material = material;\n      }\n    }\n    var material = this._mesh.material;\n    var geometry = this._mesh.geometry;\n    var attributes = geometry.attributes;\n    this.rootNode.remove(this._prevMesh);\n    this.rootNode.add(this._mesh);\n    this._setPositionTextureToMesh(this._mesh, this._positionTexture);\n    var symbolInfo = this._getSymbolInfo(seriesModel, start, end);\n    var dpr = api.getDevicePixelRatio(); // TODO image symbol\n\n    var itemStyle = seriesModel.getModel('itemStyle').getItemStyle();\n    var largeMode = seriesModel.get('large');\n    var pointSizeScale = 1;\n    if (symbolInfo.maxSize > 2) {\n      pointSizeScale = this._updateSymbolSprite(seriesModel, itemStyle, symbolInfo, dpr);\n      material.enableTexture('sprite');\n    } else {\n      material.disableTexture('sprite');\n    }\n    attributes.position.init(end - start);\n    var rgbaArr = [];\n    if (largeMode) {\n      material.undefine('VERTEX_SIZE');\n      material.undefine('VERTEX_COLOR');\n      var color = getVisualColor(data);\n      var opacity = getVisualOpacity(data);\n      graphicGL.parseColor(color, rgbaArr);\n      rgbaArr[3] *= opacity;\n      material.set({\n        color: rgbaArr,\n        'u_Size': symbolInfo.maxSize * this._sizeScale\n      });\n    } else {\n      material.set({\n        color: [1, 1, 1, 1]\n      });\n      material.define('VERTEX_SIZE');\n      material.define('VERTEX_COLOR');\n      attributes.size.init(end - start);\n      attributes.color.init(end - start);\n      this._originalOpacity = new Float32Array(end - start);\n    }\n    var points = data.getLayout('points');\n    var positionArr = attributes.position.value;\n    var hasTransparentPoint = false;\n    for (var i = 0; i < end - start; i++) {\n      var i3 = i * 3;\n      var i2 = i * 2;\n      if (this.is2D) {\n        positionArr[i3] = points[i2];\n        positionArr[i3 + 1] = points[i2 + 1];\n        positionArr[i3 + 2] = Z_2D;\n      } else {\n        positionArr[i3] = points[i3];\n        positionArr[i3 + 1] = points[i3 + 1];\n        positionArr[i3 + 2] = points[i3 + 2];\n      }\n      if (!largeMode) {\n        var color = getItemVisualColor(data, i);\n        var opacity = getItemVisualOpacity(data, i);\n        graphicGL.parseColor(color, rgbaArr);\n        rgbaArr[3] *= opacity;\n        attributes.color.set(i, rgbaArr);\n        if (rgbaArr[3] < 0.99) {\n          hasTransparentPoint = true;\n        }\n        var symbolSize = data.getItemVisual(i, 'symbolSize');\n        symbolSize = symbolSize instanceof Array ? Math.max(symbolSize[0], symbolSize[1]) : symbolSize; // NaN pointSize may have strange result.\n\n        if (isNaN(symbolSize)) {\n          symbolSize = 0;\n        } // Scale point size because canvas has margin.\n\n        attributes.size.value[i] = symbolSize * pointSizeScale * this._sizeScale; // Save the original opacity for recover from fadeIn.\n\n        this._originalOpacity[i] = rgbaArr[3];\n      }\n    }\n    this._mesh.sizeScale = pointSizeScale;\n    geometry.updateBoundingBox();\n    geometry.dirty(); // Update material.\n\n    this._updateMaterial(seriesModel, itemStyle);\n    var coordSys = seriesModel.coordinateSystem;\n    if (coordSys && coordSys.viewGL) {\n      var methodName = coordSys.viewGL.isLinearSpace() ? 'define' : 'undefine';\n      material[methodName]('fragment', 'SRGB_DECODE');\n    }\n    if (!largeMode) {\n      this._updateLabelBuilder(seriesModel, start, end);\n    }\n    this._updateHandler(seriesModel, ecModel, api);\n    this._updateAnimation(seriesModel);\n    this._api = api;\n  },\n  getPointsMesh: function () {\n    return this._mesh;\n  },\n  updateLabels: function (highlightDataIndices) {\n    this._labelsBuilder.updateLabels(highlightDataIndices);\n  },\n  hideLabels: function () {\n    this.rootNode.remove(this._labelsBuilder.getMesh());\n  },\n  showLabels: function () {\n    this.rootNode.add(this._labelsBuilder.getMesh());\n  },\n  dispose: function () {\n    this._labelsBuilder.dispose();\n  },\n  _updateSymbolSprite: function (seriesModel, itemStyle, symbolInfo, dpr) {\n    symbolInfo.maxSize = Math.min(symbolInfo.maxSize * 2, 200);\n    var symbolSize = [];\n    if (symbolInfo.aspect > 1) {\n      symbolSize[0] = symbolInfo.maxSize;\n      symbolSize[1] = symbolInfo.maxSize / symbolInfo.aspect;\n    } else {\n      symbolSize[1] = symbolInfo.maxSize;\n      symbolSize[0] = symbolInfo.maxSize * symbolInfo.aspect;\n    } // In case invalid data.\n\n    symbolSize[0] = symbolSize[0] || 1;\n    symbolSize[1] = symbolSize[1] || 1;\n    if (this._symbolType !== symbolInfo.type || !isSymbolSizeSame(this._symbolSize, symbolSize) || this._lineWidth !== itemStyle.lineWidth) {\n      spriteUtil.createSymbolSprite(symbolInfo.type, symbolSize, {\n        fill: '#fff',\n        lineWidth: itemStyle.lineWidth,\n        stroke: 'transparent',\n        shadowColor: 'transparent',\n        minMargin: Math.min(symbolSize[0] / 2, 10)\n      }, this._spriteImageCanvas);\n      spriteUtil.createSDFFromCanvas(this._spriteImageCanvas, Math.min(this._spriteImageCanvas.width, 32), SDF_RANGE, this._mesh.material.get('sprite').image);\n      this._symbolType = symbolInfo.type;\n      this._symbolSize = symbolSize;\n      this._lineWidth = itemStyle.lineWidth;\n    }\n    return this._spriteImageCanvas.width / symbolInfo.maxSize * dpr;\n  },\n  _updateMaterial: function (seriesModel, itemStyle) {\n    var blendFunc = seriesModel.get('blendMode') === 'lighter' ? graphicGL.additiveBlend : null;\n    var material = this._mesh.material;\n    material.blend = blendFunc;\n    material.set('lineWidth', itemStyle.lineWidth / SDF_RANGE);\n    var strokeColor = graphicGL.parseColor(itemStyle.stroke);\n    material.set('strokeColor', strokeColor); // Because of symbol texture, we always needs it be transparent.\n\n    material.transparent = true;\n    material.depthMask = false;\n    material.depthTest = !this.is2D;\n    material.sortVertices = !this.is2D;\n  },\n  _updateLabelBuilder: function (seriesModel, start, end) {\n    var data = seriesModel.getData();\n    var geometry = this._mesh.geometry;\n    var positionArr = geometry.attributes.position.value;\n    var start = this._startDataIndex;\n    var pointSizeScale = this._mesh.sizeScale;\n    this._labelsBuilder.updateData(data, start, end);\n    this._labelsBuilder.getLabelPosition = function (dataIndex, positionDesc, distance) {\n      var idx3 = (dataIndex - start) * 3;\n      return [positionArr[idx3], positionArr[idx3 + 1], positionArr[idx3 + 2]];\n    };\n    this._labelsBuilder.getLabelDistance = function (dataIndex, positionDesc, distance) {\n      var size = geometry.attributes.size.get(dataIndex - start) / pointSizeScale;\n      return size / 2 + distance;\n    };\n    this._labelsBuilder.updateLabels();\n  },\n  _updateAnimation: function (seriesModel) {\n    graphicGL.updateVertexAnimation([['prevPosition', 'position'], ['prevSize', 'size']], this._prevMesh, this._mesh, seriesModel);\n  },\n  _updateHandler: function (seriesModel, ecModel, api) {\n    var data = seriesModel.getData();\n    var pointsMesh = this._mesh;\n    var self = this;\n    var lastDataIndex = -1;\n    var isCartesian3D = seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian3D';\n    var grid3DModel;\n    if (isCartesian3D) {\n      grid3DModel = seriesModel.coordinateSystem.model;\n    }\n    pointsMesh.seriesIndex = seriesModel.seriesIndex;\n    pointsMesh.off('mousemove');\n    pointsMesh.off('mouseout');\n    pointsMesh.on('mousemove', function (e) {\n      var dataIndex = e.vertexIndex + self._startDataIndex;\n      if (dataIndex !== lastDataIndex) {\n        if (this.highlightOnMouseover) {\n          this.downplay(data, lastDataIndex);\n          this.highlight(data, dataIndex);\n          this._labelsBuilder.updateLabels([dataIndex]);\n        }\n        if (isCartesian3D) {\n          api.dispatchAction({\n            type: 'grid3DShowAxisPointer',\n            value: [data.get(seriesModel.coordDimToDataDim('x')[0], dataIndex), data.get(seriesModel.coordDimToDataDim('y')[0], dataIndex), data.get(seriesModel.coordDimToDataDim('z')[0], dataIndex)],\n            grid3DIndex: grid3DModel.componentIndex\n          });\n        }\n      }\n      pointsMesh.dataIndex = dataIndex;\n      lastDataIndex = dataIndex;\n    }, this);\n    pointsMesh.on('mouseout', function (e) {\n      var dataIndex = e.vertexIndex + self._startDataIndex;\n      if (this.highlightOnMouseover) {\n        this.downplay(data, dataIndex);\n        this._labelsBuilder.updateLabels();\n      }\n      lastDataIndex = -1;\n      pointsMesh.dataIndex = -1;\n      if (isCartesian3D) {\n        api.dispatchAction({\n          type: 'grid3DHideAxisPointer',\n          grid3DIndex: grid3DModel.componentIndex\n        });\n      }\n    }, this);\n  },\n  updateLayout: function (seriesModel, ecModel, api) {\n    var data = seriesModel.getData();\n    if (!this._mesh) {\n      return;\n    }\n    var positionArr = this._mesh.geometry.attributes.position.value;\n    var points = data.getLayout('points');\n    if (this.is2D) {\n      for (var i = 0; i < points.length / 2; i++) {\n        var i3 = i * 3;\n        var i2 = i * 2;\n        positionArr[i3] = points[i2];\n        positionArr[i3 + 1] = points[i2 + 1];\n        positionArr[i3 + 2] = Z_2D;\n      }\n    } else {\n      for (var i = 0; i < points.length; i++) {\n        positionArr[i] = points[i];\n      }\n    }\n    this._mesh.geometry.dirty();\n    api.getZr().refresh();\n  },\n  updateView: function (camera) {\n    if (!this._mesh) {\n      return;\n    }\n    var worldViewProjection = new Matrix4();\n    Matrix4.mul(worldViewProjection, camera.viewMatrix, this._mesh.worldTransform);\n    Matrix4.mul(worldViewProjection, camera.projectionMatrix, worldViewProjection);\n    this._mesh.updateNDCPosition(worldViewProjection, this.is2D, this._api);\n  },\n  highlight: function (data, dataIndex) {\n    if (dataIndex > this._endDataIndex || dataIndex < this._startDataIndex) {\n      return;\n    }\n    var itemModel = data.getItemModel(dataIndex);\n    var emphasisItemStyleModel = itemModel.getModel('emphasis.itemStyle');\n    var emphasisColor = emphasisItemStyleModel.get('color');\n    var emphasisOpacity = emphasisItemStyleModel.get('opacity');\n    if (emphasisColor == null) {\n      var color = getItemVisualColor(data, dataIndex);\n      emphasisColor = echarts.color.lift(color, -0.4);\n    }\n    if (emphasisOpacity == null) {\n      emphasisOpacity = getItemVisualOpacity(data, dataIndex);\n    }\n    var colorArr = graphicGL.parseColor(emphasisColor);\n    colorArr[3] *= emphasisOpacity;\n    this._mesh.geometry.attributes.color.set(dataIndex - this._startDataIndex, colorArr);\n    this._mesh.geometry.dirtyAttribute('color');\n    this._api.getZr().refresh();\n  },\n  downplay: function (data, dataIndex) {\n    if (dataIndex > this._endDataIndex || dataIndex < this._startDataIndex) {\n      return;\n    }\n    var color = getItemVisualColor(data, dataIndex);\n    var opacity = getItemVisualOpacity(data, dataIndex);\n    var colorArr = graphicGL.parseColor(color);\n    colorArr[3] *= opacity;\n    this._mesh.geometry.attributes.color.set(dataIndex - this._startDataIndex, colorArr);\n    this._mesh.geometry.dirtyAttribute('color');\n    this._api.getZr().refresh();\n  },\n  fadeOutAll: function (fadeOutPercent) {\n    if (this._originalOpacity) {\n      var geo = this._mesh.geometry;\n      for (var i = 0; i < geo.vertexCount; i++) {\n        var fadeOutOpacity = this._originalOpacity[i] * fadeOutPercent;\n        geo.attributes.color.value[i * 4 + 3] = fadeOutOpacity;\n      }\n      geo.dirtyAttribute('color');\n      this._api.getZr().refresh();\n    }\n  },\n  fadeInAll: function () {\n    this.fadeOutAll(1);\n  },\n  setPositionTexture: function (texture) {\n    if (this._mesh) {\n      this._setPositionTextureToMesh(this._mesh, texture);\n    }\n    this._positionTexture = texture;\n  },\n  removePositionTexture: function () {\n    this._positionTexture = null;\n    if (this._mesh) {\n      this._setPositionTextureToMesh(this._mesh, null);\n    }\n  },\n  setSizeScale: function (sizeScale) {\n    if (sizeScale !== this._sizeScale) {\n      if (this._mesh) {\n        var originalSize = this._mesh.material.get('u_Size');\n        this._mesh.material.set('u_Size', originalSize / this._sizeScale * sizeScale);\n        var attributes = this._mesh.geometry.attributes;\n        if (attributes.size.value) {\n          for (var i = 0; i < attributes.size.value.length; i++) {\n            attributes.size.value[i] = attributes.size.value[i] / this._sizeScale * sizeScale;\n          }\n        }\n      }\n      this._sizeScale = sizeScale;\n    }\n  },\n  _setPositionTextureToMesh: function (mesh, texture) {\n    if (texture) {\n      mesh.material.set('positionTexture', texture);\n    }\n    mesh.material[texture ? 'enableTexture' : 'disableTexture']('positionTexture');\n  },\n  _getSymbolInfo: function (seriesModel, start, end) {\n    if (seriesModel.get('large')) {\n      var symbolSize = retrieve.firstNotNull(seriesModel.get('symbolSize'), 1);\n      var maxSymbolSize;\n      var symbolAspect;\n      if (symbolSize instanceof Array) {\n        maxSymbolSize = Math.max(symbolSize[0], symbolSize[1]);\n        symbolAspect = symbolSize[0] / symbolSize[1];\n      } else {\n        maxSymbolSize = symbolSize;\n        symbolAspect = 1;\n      }\n      return {\n        maxSize: symbolSize,\n        type: seriesModel.get('symbol'),\n        aspect: symbolAspect\n      };\n    }\n    var data = seriesModel.getData();\n    var symbolAspect;\n    var differentSymbolAspect = false;\n    var symbolType = data.getItemVisual(0, 'symbol') || 'circle';\n    var differentSymbolType = false;\n    var maxSymbolSize = 0;\n    for (var idx = start; idx < end; idx++) {\n      var symbolSize = data.getItemVisual(idx, 'symbolSize');\n      var currentSymbolType = data.getItemVisual(idx, 'symbol');\n      var currentSymbolAspect;\n      if (!(symbolSize instanceof Array)) {\n        // Ignore NaN value.\n        if (isNaN(symbolSize)) {\n          continue;\n        }\n        currentSymbolAspect = 1;\n        maxSymbolSize = Math.max(symbolSize, maxSymbolSize);\n      } else {\n        currentSymbolAspect = symbolSize[0] / symbolSize[1];\n        maxSymbolSize = Math.max(Math.max(symbolSize[0], symbolSize[1]), maxSymbolSize);\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        if (symbolAspect != null && Math.abs(currentSymbolAspect - symbolAspect) > 0.05) {\n          differentSymbolAspect = true;\n        }\n        if (currentSymbolType !== symbolType) {\n          differentSymbolType = true;\n        }\n      }\n      symbolType = currentSymbolType;\n      symbolAspect = currentSymbolAspect;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      if (differentSymbolAspect) {\n        console.warn('Different symbol width / height ratio will be ignored.');\n      }\n      if (differentSymbolType) {\n        console.warn('Different symbol type will be ignored.');\n      }\n    }\n    return {\n      maxSize: maxSymbolSize,\n      type: symbolType,\n      aspect: symbolAspect\n    };\n  }\n};\nexport default PointsBuilder;","map":{"version":3,"names":["echarts","graphicGL","spriteUtil","PointsMesh","LabelsBuilder","Matrix4","retrieve","getItemVisualColor","getItemVisualOpacity","getVisualColor","getVisualOpacity","SDF_RANGE","Z_2D","isSymbolSizeSame","a","b","PointsBuilder","is2D","api","rootNode","Node","_labelsBuilder","getMesh","renderOrder","add","_api","_spriteImageCanvas","document","createElement","_startDataIndex","_endDataIndex","_sizeScale","prototype","constructor","highlightOnMouseover","update","seriesModel","ecModel","start","end","tmp","_prevMesh","_mesh","data","getData","count","material","frustumCulling","geometry","attributes","remove","_setPositionTextureToMesh","_positionTexture","symbolInfo","_getSymbolInfo","dpr","getDevicePixelRatio","itemStyle","getModel","getItemStyle","largeMode","get","pointSizeScale","maxSize","_updateSymbolSprite","enableTexture","disableTexture","position","init","rgbaArr","undefine","color","opacity","parseColor","set","define","size","_originalOpacity","Float32Array","points","getLayout","positionArr","value","hasTransparentPoint","i","i3","i2","symbolSize","getItemVisual","Array","Math","max","isNaN","sizeScale","updateBoundingBox","dirty","_updateMaterial","coordSys","coordinateSystem","viewGL","methodName","isLinearSpace","_updateLabelBuilder","_updateHandler","_updateAnimation","getPointsMesh","updateLabels","highlightDataIndices","hideLabels","showLabels","dispose","min","aspect","_symbolType","type","_symbolSize","_lineWidth","lineWidth","createSymbolSprite","fill","stroke","shadowColor","minMargin","createSDFFromCanvas","width","image","blendFunc","additiveBlend","blend","strokeColor","transparent","depthMask","depthTest","sortVertices","updateData","getLabelPosition","dataIndex","positionDesc","distance","idx3","getLabelDistance","updateVertexAnimation","pointsMesh","self","lastDataIndex","isCartesian3D","grid3DModel","model","seriesIndex","off","on","e","vertexIndex","downplay","highlight","dispatchAction","coordDimToDataDim","grid3DIndex","componentIndex","updateLayout","length","getZr","refresh","updateView","camera","worldViewProjection","mul","viewMatrix","worldTransform","projectionMatrix","updateNDCPosition","itemModel","getItemModel","emphasisItemStyleModel","emphasisColor","emphasisOpacity","lift","colorArr","dirtyAttribute","fadeOutAll","fadeOutPercent","geo","vertexCount","fadeOutOpacity","fadeInAll","setPositionTexture","texture","removePositionTexture","setSizeScale","originalSize","mesh","firstNotNull","maxSymbolSize","symbolAspect","differentSymbolAspect","symbolType","differentSymbolType","idx","currentSymbolType","currentSymbolAspect","process","env","NODE_ENV","abs","console","warn"],"sources":["E:/mytest/node_modules/echarts-gl/lib/chart/common/PointsBuilder.js"],"sourcesContent":["import * as echarts from 'echarts/lib/echarts';\nimport graphicGL from '../../util/graphicGL';\nimport spriteUtil from '../../util/sprite';\nimport PointsMesh from './PointsMesh';\nimport LabelsBuilder from '../../component/common/LabelsBuilder';\nimport Matrix4 from 'claygl/src/math/Matrix4';\nimport retrieve from '../../util/retrieve';\nimport { getItemVisualColor, getItemVisualOpacity } from '../../util/visual';\nimport { getVisualColor, getVisualOpacity } from '../../util/visual';\nvar SDF_RANGE = 20;\nvar Z_2D = -10;\n\nfunction isSymbolSizeSame(a, b) {\n  return a && b && a[0] === b[0] && a[1] === b[1];\n} // TODO gl_PointSize has max value.\n\n\nfunction PointsBuilder(is2D, api) {\n  this.rootNode = new graphicGL.Node();\n  /**\n   * @type {boolean}\n   */\n\n  this.is2D = is2D;\n  this._labelsBuilder = new LabelsBuilder(256, 256, api); // Give a large render order.\n\n  this._labelsBuilder.getMesh().renderOrder = 100;\n  this.rootNode.add(this._labelsBuilder.getMesh());\n  this._api = api;\n  this._spriteImageCanvas = document.createElement('canvas');\n  this._startDataIndex = 0;\n  this._endDataIndex = 0;\n  this._sizeScale = 1;\n}\n\nPointsBuilder.prototype = {\n  constructor: PointsBuilder,\n\n  /**\n   * If highlight on over\n   */\n  highlightOnMouseover: true,\n  update: function (seriesModel, ecModel, api, start, end) {\n    // Swap barMesh\n    var tmp = this._prevMesh;\n    this._prevMesh = this._mesh;\n    this._mesh = tmp;\n    var data = seriesModel.getData();\n\n    if (start == null) {\n      start = 0;\n    }\n\n    if (end == null) {\n      end = data.count();\n    }\n\n    this._startDataIndex = start;\n    this._endDataIndex = end - 1;\n\n    if (!this._mesh) {\n      var material = this._prevMesh && this._prevMesh.material;\n      this._mesh = new PointsMesh({\n        // Render after axes\n        renderOrder: 10,\n        // FIXME\n        frustumCulling: false\n      });\n\n      if (material) {\n        this._mesh.material = material;\n      }\n    }\n\n    var material = this._mesh.material;\n    var geometry = this._mesh.geometry;\n    var attributes = geometry.attributes;\n    this.rootNode.remove(this._prevMesh);\n    this.rootNode.add(this._mesh);\n\n    this._setPositionTextureToMesh(this._mesh, this._positionTexture);\n\n    var symbolInfo = this._getSymbolInfo(seriesModel, start, end);\n\n    var dpr = api.getDevicePixelRatio(); // TODO image symbol\n\n    var itemStyle = seriesModel.getModel('itemStyle').getItemStyle();\n    var largeMode = seriesModel.get('large');\n    var pointSizeScale = 1;\n\n    if (symbolInfo.maxSize > 2) {\n      pointSizeScale = this._updateSymbolSprite(seriesModel, itemStyle, symbolInfo, dpr);\n      material.enableTexture('sprite');\n    } else {\n      material.disableTexture('sprite');\n    }\n\n    attributes.position.init(end - start);\n    var rgbaArr = [];\n\n    if (largeMode) {\n      material.undefine('VERTEX_SIZE');\n      material.undefine('VERTEX_COLOR');\n      var color = getVisualColor(data);\n      var opacity = getVisualOpacity(data);\n      graphicGL.parseColor(color, rgbaArr);\n      rgbaArr[3] *= opacity;\n      material.set({\n        color: rgbaArr,\n        'u_Size': symbolInfo.maxSize * this._sizeScale\n      });\n    } else {\n      material.set({\n        color: [1, 1, 1, 1]\n      });\n      material.define('VERTEX_SIZE');\n      material.define('VERTEX_COLOR');\n      attributes.size.init(end - start);\n      attributes.color.init(end - start);\n      this._originalOpacity = new Float32Array(end - start);\n    }\n\n    var points = data.getLayout('points');\n    var positionArr = attributes.position.value;\n    var hasTransparentPoint = false;\n\n    for (var i = 0; i < end - start; i++) {\n      var i3 = i * 3;\n      var i2 = i * 2;\n\n      if (this.is2D) {\n        positionArr[i3] = points[i2];\n        positionArr[i3 + 1] = points[i2 + 1];\n        positionArr[i3 + 2] = Z_2D;\n      } else {\n        positionArr[i3] = points[i3];\n        positionArr[i3 + 1] = points[i3 + 1];\n        positionArr[i3 + 2] = points[i3 + 2];\n      }\n\n      if (!largeMode) {\n        var color = getItemVisualColor(data, i);\n        var opacity = getItemVisualOpacity(data, i);\n        graphicGL.parseColor(color, rgbaArr);\n        rgbaArr[3] *= opacity;\n        attributes.color.set(i, rgbaArr);\n\n        if (rgbaArr[3] < 0.99) {\n          hasTransparentPoint = true;\n        }\n\n        var symbolSize = data.getItemVisual(i, 'symbolSize');\n        symbolSize = symbolSize instanceof Array ? Math.max(symbolSize[0], symbolSize[1]) : symbolSize; // NaN pointSize may have strange result.\n\n        if (isNaN(symbolSize)) {\n          symbolSize = 0;\n        } // Scale point size because canvas has margin.\n\n\n        attributes.size.value[i] = symbolSize * pointSizeScale * this._sizeScale; // Save the original opacity for recover from fadeIn.\n\n        this._originalOpacity[i] = rgbaArr[3];\n      }\n    }\n\n    this._mesh.sizeScale = pointSizeScale;\n    geometry.updateBoundingBox();\n    geometry.dirty(); // Update material.\n\n    this._updateMaterial(seriesModel, itemStyle);\n\n    var coordSys = seriesModel.coordinateSystem;\n\n    if (coordSys && coordSys.viewGL) {\n      var methodName = coordSys.viewGL.isLinearSpace() ? 'define' : 'undefine';\n      material[methodName]('fragment', 'SRGB_DECODE');\n    }\n\n    if (!largeMode) {\n      this._updateLabelBuilder(seriesModel, start, end);\n    }\n\n    this._updateHandler(seriesModel, ecModel, api);\n\n    this._updateAnimation(seriesModel);\n\n    this._api = api;\n  },\n  getPointsMesh: function () {\n    return this._mesh;\n  },\n  updateLabels: function (highlightDataIndices) {\n    this._labelsBuilder.updateLabels(highlightDataIndices);\n  },\n  hideLabels: function () {\n    this.rootNode.remove(this._labelsBuilder.getMesh());\n  },\n  showLabels: function () {\n    this.rootNode.add(this._labelsBuilder.getMesh());\n  },\n  dispose: function () {\n    this._labelsBuilder.dispose();\n  },\n  _updateSymbolSprite: function (seriesModel, itemStyle, symbolInfo, dpr) {\n    symbolInfo.maxSize = Math.min(symbolInfo.maxSize * 2, 200);\n    var symbolSize = [];\n\n    if (symbolInfo.aspect > 1) {\n      symbolSize[0] = symbolInfo.maxSize;\n      symbolSize[1] = symbolInfo.maxSize / symbolInfo.aspect;\n    } else {\n      symbolSize[1] = symbolInfo.maxSize;\n      symbolSize[0] = symbolInfo.maxSize * symbolInfo.aspect;\n    } // In case invalid data.\n\n\n    symbolSize[0] = symbolSize[0] || 1;\n    symbolSize[1] = symbolSize[1] || 1;\n\n    if (this._symbolType !== symbolInfo.type || !isSymbolSizeSame(this._symbolSize, symbolSize) || this._lineWidth !== itemStyle.lineWidth) {\n      spriteUtil.createSymbolSprite(symbolInfo.type, symbolSize, {\n        fill: '#fff',\n        lineWidth: itemStyle.lineWidth,\n        stroke: 'transparent',\n        shadowColor: 'transparent',\n        minMargin: Math.min(symbolSize[0] / 2, 10)\n      }, this._spriteImageCanvas);\n      spriteUtil.createSDFFromCanvas(this._spriteImageCanvas, Math.min(this._spriteImageCanvas.width, 32), SDF_RANGE, this._mesh.material.get('sprite').image);\n      this._symbolType = symbolInfo.type;\n      this._symbolSize = symbolSize;\n      this._lineWidth = itemStyle.lineWidth;\n    }\n\n    return this._spriteImageCanvas.width / symbolInfo.maxSize * dpr;\n  },\n  _updateMaterial: function (seriesModel, itemStyle) {\n    var blendFunc = seriesModel.get('blendMode') === 'lighter' ? graphicGL.additiveBlend : null;\n    var material = this._mesh.material;\n    material.blend = blendFunc;\n    material.set('lineWidth', itemStyle.lineWidth / SDF_RANGE);\n    var strokeColor = graphicGL.parseColor(itemStyle.stroke);\n    material.set('strokeColor', strokeColor); // Because of symbol texture, we always needs it be transparent.\n\n    material.transparent = true;\n    material.depthMask = false;\n    material.depthTest = !this.is2D;\n    material.sortVertices = !this.is2D;\n  },\n  _updateLabelBuilder: function (seriesModel, start, end) {\n    var data = seriesModel.getData();\n    var geometry = this._mesh.geometry;\n    var positionArr = geometry.attributes.position.value;\n    var start = this._startDataIndex;\n    var pointSizeScale = this._mesh.sizeScale;\n\n    this._labelsBuilder.updateData(data, start, end);\n\n    this._labelsBuilder.getLabelPosition = function (dataIndex, positionDesc, distance) {\n      var idx3 = (dataIndex - start) * 3;\n      return [positionArr[idx3], positionArr[idx3 + 1], positionArr[idx3 + 2]];\n    };\n\n    this._labelsBuilder.getLabelDistance = function (dataIndex, positionDesc, distance) {\n      var size = geometry.attributes.size.get(dataIndex - start) / pointSizeScale;\n      return size / 2 + distance;\n    };\n\n    this._labelsBuilder.updateLabels();\n  },\n  _updateAnimation: function (seriesModel) {\n    graphicGL.updateVertexAnimation([['prevPosition', 'position'], ['prevSize', 'size']], this._prevMesh, this._mesh, seriesModel);\n  },\n  _updateHandler: function (seriesModel, ecModel, api) {\n    var data = seriesModel.getData();\n    var pointsMesh = this._mesh;\n    var self = this;\n    var lastDataIndex = -1;\n    var isCartesian3D = seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian3D';\n    var grid3DModel;\n\n    if (isCartesian3D) {\n      grid3DModel = seriesModel.coordinateSystem.model;\n    }\n\n    pointsMesh.seriesIndex = seriesModel.seriesIndex;\n    pointsMesh.off('mousemove');\n    pointsMesh.off('mouseout');\n    pointsMesh.on('mousemove', function (e) {\n      var dataIndex = e.vertexIndex + self._startDataIndex;\n\n      if (dataIndex !== lastDataIndex) {\n        if (this.highlightOnMouseover) {\n          this.downplay(data, lastDataIndex);\n          this.highlight(data, dataIndex);\n\n          this._labelsBuilder.updateLabels([dataIndex]);\n        }\n\n        if (isCartesian3D) {\n          api.dispatchAction({\n            type: 'grid3DShowAxisPointer',\n            value: [data.get(seriesModel.coordDimToDataDim('x')[0], dataIndex), data.get(seriesModel.coordDimToDataDim('y')[0], dataIndex), data.get(seriesModel.coordDimToDataDim('z')[0], dataIndex)],\n            grid3DIndex: grid3DModel.componentIndex\n          });\n        }\n      }\n\n      pointsMesh.dataIndex = dataIndex;\n      lastDataIndex = dataIndex;\n    }, this);\n    pointsMesh.on('mouseout', function (e) {\n      var dataIndex = e.vertexIndex + self._startDataIndex;\n\n      if (this.highlightOnMouseover) {\n        this.downplay(data, dataIndex);\n\n        this._labelsBuilder.updateLabels();\n      }\n\n      lastDataIndex = -1;\n      pointsMesh.dataIndex = -1;\n\n      if (isCartesian3D) {\n        api.dispatchAction({\n          type: 'grid3DHideAxisPointer',\n          grid3DIndex: grid3DModel.componentIndex\n        });\n      }\n    }, this);\n  },\n  updateLayout: function (seriesModel, ecModel, api) {\n    var data = seriesModel.getData();\n\n    if (!this._mesh) {\n      return;\n    }\n\n    var positionArr = this._mesh.geometry.attributes.position.value;\n    var points = data.getLayout('points');\n\n    if (this.is2D) {\n      for (var i = 0; i < points.length / 2; i++) {\n        var i3 = i * 3;\n        var i2 = i * 2;\n        positionArr[i3] = points[i2];\n        positionArr[i3 + 1] = points[i2 + 1];\n        positionArr[i3 + 2] = Z_2D;\n      }\n    } else {\n      for (var i = 0; i < points.length; i++) {\n        positionArr[i] = points[i];\n      }\n    }\n\n    this._mesh.geometry.dirty();\n\n    api.getZr().refresh();\n  },\n  updateView: function (camera) {\n    if (!this._mesh) {\n      return;\n    }\n\n    var worldViewProjection = new Matrix4();\n    Matrix4.mul(worldViewProjection, camera.viewMatrix, this._mesh.worldTransform);\n    Matrix4.mul(worldViewProjection, camera.projectionMatrix, worldViewProjection);\n\n    this._mesh.updateNDCPosition(worldViewProjection, this.is2D, this._api);\n  },\n  highlight: function (data, dataIndex) {\n    if (dataIndex > this._endDataIndex || dataIndex < this._startDataIndex) {\n      return;\n    }\n\n    var itemModel = data.getItemModel(dataIndex);\n    var emphasisItemStyleModel = itemModel.getModel('emphasis.itemStyle');\n    var emphasisColor = emphasisItemStyleModel.get('color');\n    var emphasisOpacity = emphasisItemStyleModel.get('opacity');\n\n    if (emphasisColor == null) {\n      var color = getItemVisualColor(data, dataIndex);\n      emphasisColor = echarts.color.lift(color, -0.4);\n    }\n\n    if (emphasisOpacity == null) {\n      emphasisOpacity = getItemVisualOpacity(data, dataIndex);\n    }\n\n    var colorArr = graphicGL.parseColor(emphasisColor);\n    colorArr[3] *= emphasisOpacity;\n\n    this._mesh.geometry.attributes.color.set(dataIndex - this._startDataIndex, colorArr);\n\n    this._mesh.geometry.dirtyAttribute('color');\n\n    this._api.getZr().refresh();\n  },\n  downplay: function (data, dataIndex) {\n    if (dataIndex > this._endDataIndex || dataIndex < this._startDataIndex) {\n      return;\n    }\n\n    var color = getItemVisualColor(data, dataIndex);\n    var opacity = getItemVisualOpacity(data, dataIndex);\n    var colorArr = graphicGL.parseColor(color);\n    colorArr[3] *= opacity;\n\n    this._mesh.geometry.attributes.color.set(dataIndex - this._startDataIndex, colorArr);\n\n    this._mesh.geometry.dirtyAttribute('color');\n\n    this._api.getZr().refresh();\n  },\n  fadeOutAll: function (fadeOutPercent) {\n    if (this._originalOpacity) {\n      var geo = this._mesh.geometry;\n\n      for (var i = 0; i < geo.vertexCount; i++) {\n        var fadeOutOpacity = this._originalOpacity[i] * fadeOutPercent;\n        geo.attributes.color.value[i * 4 + 3] = fadeOutOpacity;\n      }\n\n      geo.dirtyAttribute('color');\n\n      this._api.getZr().refresh();\n    }\n  },\n  fadeInAll: function () {\n    this.fadeOutAll(1);\n  },\n  setPositionTexture: function (texture) {\n    if (this._mesh) {\n      this._setPositionTextureToMesh(this._mesh, texture);\n    }\n\n    this._positionTexture = texture;\n  },\n  removePositionTexture: function () {\n    this._positionTexture = null;\n\n    if (this._mesh) {\n      this._setPositionTextureToMesh(this._mesh, null);\n    }\n  },\n  setSizeScale: function (sizeScale) {\n    if (sizeScale !== this._sizeScale) {\n      if (this._mesh) {\n        var originalSize = this._mesh.material.get('u_Size');\n\n        this._mesh.material.set('u_Size', originalSize / this._sizeScale * sizeScale);\n\n        var attributes = this._mesh.geometry.attributes;\n\n        if (attributes.size.value) {\n          for (var i = 0; i < attributes.size.value.length; i++) {\n            attributes.size.value[i] = attributes.size.value[i] / this._sizeScale * sizeScale;\n          }\n        }\n      }\n\n      this._sizeScale = sizeScale;\n    }\n  },\n  _setPositionTextureToMesh: function (mesh, texture) {\n    if (texture) {\n      mesh.material.set('positionTexture', texture);\n    }\n\n    mesh.material[texture ? 'enableTexture' : 'disableTexture']('positionTexture');\n  },\n  _getSymbolInfo: function (seriesModel, start, end) {\n    if (seriesModel.get('large')) {\n      var symbolSize = retrieve.firstNotNull(seriesModel.get('symbolSize'), 1);\n      var maxSymbolSize;\n      var symbolAspect;\n\n      if (symbolSize instanceof Array) {\n        maxSymbolSize = Math.max(symbolSize[0], symbolSize[1]);\n        symbolAspect = symbolSize[0] / symbolSize[1];\n      } else {\n        maxSymbolSize = symbolSize;\n        symbolAspect = 1;\n      }\n\n      return {\n        maxSize: symbolSize,\n        type: seriesModel.get('symbol'),\n        aspect: symbolAspect\n      };\n    }\n\n    var data = seriesModel.getData();\n    var symbolAspect;\n    var differentSymbolAspect = false;\n    var symbolType = data.getItemVisual(0, 'symbol') || 'circle';\n    var differentSymbolType = false;\n    var maxSymbolSize = 0;\n\n    for (var idx = start; idx < end; idx++) {\n      var symbolSize = data.getItemVisual(idx, 'symbolSize');\n      var currentSymbolType = data.getItemVisual(idx, 'symbol');\n      var currentSymbolAspect;\n\n      if (!(symbolSize instanceof Array)) {\n        // Ignore NaN value.\n        if (isNaN(symbolSize)) {\n          continue;\n        }\n\n        currentSymbolAspect = 1;\n        maxSymbolSize = Math.max(symbolSize, maxSymbolSize);\n      } else {\n        currentSymbolAspect = symbolSize[0] / symbolSize[1];\n        maxSymbolSize = Math.max(Math.max(symbolSize[0], symbolSize[1]), maxSymbolSize);\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (symbolAspect != null && Math.abs(currentSymbolAspect - symbolAspect) > 0.05) {\n          differentSymbolAspect = true;\n        }\n\n        if (currentSymbolType !== symbolType) {\n          differentSymbolType = true;\n        }\n      }\n\n      symbolType = currentSymbolType;\n      symbolAspect = currentSymbolAspect;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (differentSymbolAspect) {\n        console.warn('Different symbol width / height ratio will be ignored.');\n      }\n\n      if (differentSymbolType) {\n        console.warn('Different symbol type will be ignored.');\n      }\n    }\n\n    return {\n      maxSize: maxSymbolSize,\n      type: symbolType,\n      aspect: symbolAspect\n    };\n  }\n};\nexport default PointsBuilder;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}