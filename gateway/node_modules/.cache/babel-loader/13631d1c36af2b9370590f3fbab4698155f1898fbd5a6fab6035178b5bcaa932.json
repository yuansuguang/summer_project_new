{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport GLProgram from './GLProgram';\nvar loopRegex = /for\\s*?\\(int\\s*?_idx_\\s*\\=\\s*([\\w-]+)\\;\\s*_idx_\\s*<\\s*([\\w-]+);\\s*_idx_\\s*\\+\\+\\s*\\)\\s*\\{\\{([\\s\\S]+?)(?=\\}\\})\\}\\}/g;\nfunction unrollLoop(shaderStr, defines, lightsNumbers) {\n  // Loop unroll from three.js, https://github.com/mrdoob/three.js/blob/master/src/renderers/webgl/WebGLProgram.js#L175\n  // In some case like shadowMap in loop use 'i' to index value much slower.\n\n  // Loop use _idx_ and increased with _idx_++ will be unrolled\n  // Use {{ }} to match the pair so the if statement will not be affected\n  // Write like following\n  // for (int _idx_ = 0; _idx_ < 4; _idx_++) {{\n  //     vec3 color = texture2D(textures[_idx_], uv).rgb;\n  // }}\n  function replace(match, start, end, snippet) {\n    var unroll = '';\n    // Try to treat as define\n    if (isNaN(start)) {\n      if (start in defines) {\n        start = defines[start];\n      } else {\n        start = lightNumberDefines[start];\n      }\n    }\n    if (isNaN(end)) {\n      if (end in defines) {\n        end = defines[end];\n      } else {\n        end = lightNumberDefines[end];\n      }\n    }\n    // TODO Error checking\n\n    for (var idx = parseInt(start); idx < parseInt(end); idx++) {\n      // PENDING Add scope?\n      unroll += '{' + snippet.replace(/float\\s*\\(\\s*_idx_\\s*\\)/g, idx.toFixed(1)).replace(/_idx_/g, idx) + '}';\n    }\n    return unroll;\n  }\n  var lightNumberDefines = {};\n  for (var lightType in lightsNumbers) {\n    lightNumberDefines[lightType + '_COUNT'] = lightsNumbers[lightType];\n  }\n  return shaderStr.replace(loopRegex, replace);\n}\nfunction getDefineCode(defines, lightsNumbers, enabledTextures) {\n  var defineStr = [];\n  if (lightsNumbers) {\n    for (var lightType in lightsNumbers) {\n      var count = lightsNumbers[lightType];\n      if (count > 0) {\n        defineStr.push('#define ' + lightType.toUpperCase() + '_COUNT ' + count);\n      }\n    }\n  }\n  if (enabledTextures) {\n    for (var i = 0; i < enabledTextures.length; i++) {\n      var symbol = enabledTextures[i];\n      defineStr.push('#define ' + symbol.toUpperCase() + '_ENABLED');\n    }\n  }\n  // Custom Defines\n  for (var symbol in defines) {\n    var value = defines[symbol];\n    if (value === null) {\n      defineStr.push('#define ' + symbol);\n    } else {\n      defineStr.push('#define ' + symbol + ' ' + value.toString());\n    }\n  }\n  return defineStr.join('\\n');\n}\nfunction getExtensionCode(exts) {\n  // Extension declaration must before all non-preprocessor codes\n  // TODO vertex ? extension enum ?\n  var extensionStr = [];\n  for (var i = 0; i < exts.length; i++) {\n    extensionStr.push('#extension GL_' + exts[i] + ' : enable');\n  }\n  return extensionStr.join('\\n');\n}\nfunction getPrecisionCode(precision) {\n  return ['precision', precision, 'float'].join(' ') + ';\\n' + ['precision', precision, 'int'].join(' ') + ';\\n'\n  // depth texture may have precision problem on iOS device.\n  + ['precision', precision, 'sampler2D'].join(' ') + ';\\n';\n}\nfunction ProgramManager(renderer) {\n  this._renderer = renderer;\n  this._cache = {};\n}\nProgramManager.prototype.getProgram = function (renderable, material, scene) {\n  var cache = this._cache;\n  var isSkinnedMesh = renderable.isSkinnedMesh && renderable.isSkinnedMesh();\n  var isInstancedMesh = renderable.isInstancedMesh && renderable.isInstancedMesh();\n  var key = 's' + material.shader.shaderID + 'm' + material.getProgramKey();\n  if (scene) {\n    key += 'se' + scene.getProgramKey(renderable.lightGroup);\n  }\n  if (isSkinnedMesh) {\n    key += ',sk' + renderable.joints.length;\n  }\n  if (isInstancedMesh) {\n    key += ',is';\n  }\n  var program = cache[key];\n  if (program) {\n    return program;\n  }\n  var lightsNumbers = scene ? scene.getLightsNumbers(renderable.lightGroup) : {};\n  var renderer = this._renderer;\n  var _gl = renderer.gl;\n  var enabledTextures = material.getEnabledTextures();\n  var extraDefineCode = '';\n  if (isSkinnedMesh) {\n    var skinDefines = {\n      SKINNING: null,\n      JOINT_COUNT: renderable.joints.length\n    };\n    if (renderable.joints.length > renderer.getMaxJointNumber()) {\n      skinDefines.USE_SKIN_MATRICES_TEXTURE = null;\n    }\n    // TODO Add skinning code?\n    extraDefineCode += '\\n' + getDefineCode(skinDefines) + '\\n';\n  }\n  if (isInstancedMesh) {\n    extraDefineCode += '\\n#define INSTANCING\\n';\n  }\n  // TODO Optimize key generation\n  // VERTEX\n  var vertexDefineStr = extraDefineCode + getDefineCode(material.vertexDefines, lightsNumbers, enabledTextures);\n  // FRAGMENT\n  var fragmentDefineStr = extraDefineCode + getDefineCode(material.fragmentDefines, lightsNumbers, enabledTextures);\n  var vertexCode = vertexDefineStr + '\\n' + material.shader.vertex;\n  var extensions = ['OES_standard_derivatives', 'EXT_shader_texture_lod'].filter(function (ext) {\n    return renderer.getGLExtension(ext) != null;\n  });\n  if (extensions.indexOf('EXT_shader_texture_lod') >= 0) {\n    fragmentDefineStr += '\\n#define SUPPORT_TEXTURE_LOD';\n  }\n  if (extensions.indexOf('OES_standard_derivatives') >= 0) {\n    fragmentDefineStr += '\\n#define SUPPORT_STANDARD_DERIVATIVES';\n  }\n  var fragmentCode = getExtensionCode(extensions) + '\\n' + getPrecisionCode(material.precision) + '\\n' + fragmentDefineStr + '\\n' + material.shader.fragment;\n  var finalVertexCode = unrollLoop(vertexCode, material.vertexDefines, lightsNumbers);\n  var finalFragmentCode = unrollLoop(fragmentCode, material.fragmentDefines, lightsNumbers);\n  var program = new GLProgram();\n  program.uniformSemantics = material.shader.uniformSemantics;\n  program.attributes = material.shader.attributes;\n  var errorMsg = program.buildProgram(_gl, material.shader, finalVertexCode, finalFragmentCode);\n  program.__error = errorMsg;\n  cache[key] = program;\n  return program;\n};\nexport default ProgramManager;","map":{"version":3,"names":["GLProgram","loopRegex","unrollLoop","shaderStr","defines","lightsNumbers","replace","match","start","end","snippet","unroll","isNaN","lightNumberDefines","idx","parseInt","toFixed","lightType","getDefineCode","enabledTextures","defineStr","count","push","toUpperCase","i","length","symbol","value","toString","join","getExtensionCode","exts","extensionStr","getPrecisionCode","precision","ProgramManager","renderer","_renderer","_cache","prototype","getProgram","renderable","material","scene","cache","isSkinnedMesh","isInstancedMesh","key","shader","shaderID","getProgramKey","lightGroup","joints","program","getLightsNumbers","_gl","gl","getEnabledTextures","extraDefineCode","skinDefines","SKINNING","JOINT_COUNT","getMaxJointNumber","USE_SKIN_MATRICES_TEXTURE","vertexDefineStr","vertexDefines","fragmentDefineStr","fragmentDefines","vertexCode","vertex","extensions","filter","ext","getGLExtension","indexOf","fragmentCode","fragment","finalVertexCode","finalFragmentCode","uniformSemantics","attributes","errorMsg","buildProgram","__error"],"sources":["E:/mytest/node_modules/claygl/src/gpu/ProgramManager.js"],"sourcesContent":["import GLProgram from './GLProgram';\n\nvar loopRegex = /for\\s*?\\(int\\s*?_idx_\\s*\\=\\s*([\\w-]+)\\;\\s*_idx_\\s*<\\s*([\\w-]+);\\s*_idx_\\s*\\+\\+\\s*\\)\\s*\\{\\{([\\s\\S]+?)(?=\\}\\})\\}\\}/g;\n\nfunction unrollLoop(shaderStr, defines, lightsNumbers) {\n    // Loop unroll from three.js, https://github.com/mrdoob/three.js/blob/master/src/renderers/webgl/WebGLProgram.js#L175\n    // In some case like shadowMap in loop use 'i' to index value much slower.\n\n    // Loop use _idx_ and increased with _idx_++ will be unrolled\n    // Use {{ }} to match the pair so the if statement will not be affected\n    // Write like following\n    // for (int _idx_ = 0; _idx_ < 4; _idx_++) {{\n    //     vec3 color = texture2D(textures[_idx_], uv).rgb;\n    // }}\n    function replace(match, start, end, snippet) {\n        var unroll = '';\n        // Try to treat as define\n        if (isNaN(start)) {\n            if (start in defines) {\n                start = defines[start];\n            }\n            else {\n                start = lightNumberDefines[start];\n            }\n        }\n        if (isNaN(end)) {\n            if (end in defines) {\n                end = defines[end];\n            }\n            else {\n                end = lightNumberDefines[end];\n            }\n        }\n        // TODO Error checking\n\n        for (var idx = parseInt(start); idx < parseInt(end); idx++) {\n            // PENDING Add scope?\n            unroll += '{'\n                + snippet\n                    .replace(/float\\s*\\(\\s*_idx_\\s*\\)/g, idx.toFixed(1))\n                    .replace(/_idx_/g, idx)\n            + '}';\n        }\n\n        return unroll;\n    }\n\n    var lightNumberDefines = {};\n    for (var lightType in lightsNumbers) {\n        lightNumberDefines[lightType + '_COUNT'] = lightsNumbers[lightType];\n    }\n    return shaderStr.replace(loopRegex, replace);\n}\n\nfunction getDefineCode(defines, lightsNumbers, enabledTextures) {\n    var defineStr = [];\n    if (lightsNumbers) {\n        for (var lightType in lightsNumbers) {\n            var count = lightsNumbers[lightType];\n            if (count > 0) {\n                defineStr.push('#define ' + lightType.toUpperCase() + '_COUNT ' + count);\n            }\n        }\n    }\n    if (enabledTextures) {\n        for (var i = 0; i < enabledTextures.length; i++) {\n            var symbol = enabledTextures[i];\n            defineStr.push('#define ' + symbol.toUpperCase() + '_ENABLED');\n        }\n    }\n    // Custom Defines\n    for (var symbol in defines) {\n        var value = defines[symbol];\n        if (value === null) {\n            defineStr.push('#define ' + symbol);\n        }\n        else{\n            defineStr.push('#define ' + symbol + ' ' + value.toString());\n        }\n    }\n    return defineStr.join('\\n');\n}\n\nfunction getExtensionCode(exts) {\n    // Extension declaration must before all non-preprocessor codes\n    // TODO vertex ? extension enum ?\n    var extensionStr = [];\n    for (var i = 0; i < exts.length; i++) {\n        extensionStr.push('#extension GL_' + exts[i] + ' : enable');\n    }\n    return extensionStr.join('\\n');\n}\n\nfunction getPrecisionCode(precision) {\n    return ['precision', precision, 'float'].join(' ') + ';\\n'\n        + ['precision', precision, 'int'].join(' ') + ';\\n'\n        // depth texture may have precision problem on iOS device.\n        + ['precision', precision, 'sampler2D'].join(' ') + ';\\n';\n}\n\nfunction ProgramManager(renderer) {\n    this._renderer = renderer;\n    this._cache = {};\n}\n\nProgramManager.prototype.getProgram = function (renderable, material, scene) {\n    var cache = this._cache;\n\n    var isSkinnedMesh = renderable.isSkinnedMesh && renderable.isSkinnedMesh();\n    var isInstancedMesh = renderable.isInstancedMesh && renderable.isInstancedMesh();\n    var key = 's' + material.shader.shaderID + 'm' + material.getProgramKey();\n    if (scene) {\n        key += 'se' + scene.getProgramKey(renderable.lightGroup);\n    }\n    if (isSkinnedMesh) {\n        key += ',sk' + renderable.joints.length;\n    }\n    if (isInstancedMesh) {\n        key += ',is';\n    }\n    var program = cache[key];\n\n    if (program) {\n        return program;\n    }\n\n    var lightsNumbers = scene ? scene.getLightsNumbers(renderable.lightGroup) : {};\n    var renderer = this._renderer;\n    var _gl = renderer.gl;\n    var enabledTextures = material.getEnabledTextures();\n    var extraDefineCode = '';\n    if (isSkinnedMesh) {\n        var skinDefines = {\n            SKINNING: null,\n            JOINT_COUNT: renderable.joints.length\n        };\n        if (renderable.joints.length > renderer.getMaxJointNumber()) {\n            skinDefines.USE_SKIN_MATRICES_TEXTURE = null;\n        }\n        // TODO Add skinning code?\n        extraDefineCode += '\\n' + getDefineCode(skinDefines) + '\\n';\n    }\n    if (isInstancedMesh) {\n        extraDefineCode += '\\n#define INSTANCING\\n';\n    }\n    // TODO Optimize key generation\n    // VERTEX\n    var vertexDefineStr = extraDefineCode + getDefineCode(material.vertexDefines, lightsNumbers, enabledTextures);\n    // FRAGMENT\n    var fragmentDefineStr = extraDefineCode + getDefineCode(material.fragmentDefines, lightsNumbers, enabledTextures);\n\n    var vertexCode = vertexDefineStr + '\\n' + material.shader.vertex;\n\n    var extensions = [\n        'OES_standard_derivatives',\n        'EXT_shader_texture_lod'\n    ].filter(function (ext) {\n        return renderer.getGLExtension(ext) != null;\n    });\n\n    if (extensions.indexOf('EXT_shader_texture_lod') >= 0) {\n        fragmentDefineStr += '\\n#define SUPPORT_TEXTURE_LOD';\n    }\n    if (extensions.indexOf('OES_standard_derivatives') >= 0) {\n        fragmentDefineStr += '\\n#define SUPPORT_STANDARD_DERIVATIVES';\n    }\n\n    var fragmentCode = getExtensionCode(extensions) + '\\n'\n        + getPrecisionCode(material.precision) + '\\n'\n        + fragmentDefineStr + '\\n'\n        + material.shader.fragment;\n\n    var finalVertexCode = unrollLoop(vertexCode, material.vertexDefines, lightsNumbers);\n    var finalFragmentCode = unrollLoop(fragmentCode, material.fragmentDefines, lightsNumbers);\n\n    var program = new GLProgram();\n    program.uniformSemantics = material.shader.uniformSemantics;\n    program.attributes = material.shader.attributes;\n    var errorMsg = program.buildProgram(_gl, material.shader, finalVertexCode, finalFragmentCode);\n    program.__error = errorMsg;\n\n    cache[key] = program;\n\n    return program;\n};\n\nexport default ProgramManager;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}