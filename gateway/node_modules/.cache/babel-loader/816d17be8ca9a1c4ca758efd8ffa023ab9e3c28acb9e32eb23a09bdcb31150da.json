{"ast":null,"code":"import \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport ProgressiveQuickSort from '../ProgressiveQuickSort';\nimport glmatrix from 'claygl/src/dep/glmatrix';\nvar vec3 = glmatrix.vec3;\nexport default {\n  needsSortVertices: function () {\n    return this.sortVertices;\n  },\n  needsSortVerticesProgressively: function () {\n    return this.needsSortVertices() && this.vertexCount >= 2e4;\n  },\n  doSortVertices: function (cameraPos, frame) {\n    var indices = this.indices;\n    var p = vec3.create();\n    if (!indices) {\n      indices = this.indices = this.vertexCount > 0xffff ? new Uint32Array(this.vertexCount) : new Uint16Array(this.vertexCount);\n      for (var i = 0; i < indices.length; i++) {\n        indices[i] = i;\n      }\n    } // Do progressive quick sort.\n\n    if (frame === 0) {\n      var posAttr = this.attributes.position;\n      var cameraPos = cameraPos.array;\n      var noneCount = 0;\n      if (!this._zList || this._zList.length !== this.vertexCount) {\n        this._zList = new Float32Array(this.vertexCount);\n      }\n      var firstZ;\n      for (var i = 0; i < this.vertexCount; i++) {\n        posAttr.get(i, p); // Camera position is in object space\n\n        var z = vec3.sqrDist(p, cameraPos);\n        if (isNaN(z)) {\n          // Put far away, NaN value may cause sort slow\n          z = 1e7;\n          noneCount++;\n        }\n        if (i === 0) {\n          firstZ = z;\n          z = 0;\n        } else {\n          // Only store the difference to avoid the precision issue.\n          z = z - firstZ;\n        }\n        this._zList[i] = z;\n      }\n      this._noneCount = noneCount;\n    }\n    if (this.vertexCount < 2e4) {\n      // Use simple native sort for simple geometries.\n      if (frame === 0) {\n        this._simpleSort(this._noneCount / this.vertexCount > 0.05);\n      }\n    } else {\n      for (var i = 0; i < 3; i++) {\n        this._progressiveQuickSort(frame * 3 + i);\n      }\n    }\n    this.dirtyIndices();\n  },\n  _simpleSort: function (useNativeQuickSort) {\n    var zList = this._zList;\n    var indices = this.indices;\n    function compare(a, b) {\n      // Sort from far to near. which is descending order\n      return zList[b] - zList[a];\n    } // When too much value are equal, using native quick sort with three partition..\n    // or the simple quick sort will be nearly O(n*n)\n    // http://stackoverflow.com/questions/5126586/quicksort-complexity-when-all-the-elements-are-same\n    // Otherwise simple quicksort is more effecient than v8 native quick sort when data all different.\n\n    if (useNativeQuickSort) {\n      Array.prototype.sort.call(indices, compare);\n    } else {\n      ProgressiveQuickSort.sort(indices, compare, 0, indices.length - 1);\n    }\n  },\n  _progressiveQuickSort: function (frame) {\n    var zList = this._zList;\n    var indices = this.indices;\n    this._quickSort = this._quickSort || new ProgressiveQuickSort();\n    this._quickSort.step(indices, function (a, b) {\n      return zList[b] - zList[a];\n    }, frame);\n  }\n};","map":{"version":3,"names":["ProgressiveQuickSort","glmatrix","vec3","needsSortVertices","sortVertices","needsSortVerticesProgressively","vertexCount","doSortVertices","cameraPos","frame","indices","p","create","Uint32Array","Uint16Array","i","length","posAttr","attributes","position","array","noneCount","_zList","Float32Array","firstZ","get","z","sqrDist","isNaN","_noneCount","_simpleSort","_progressiveQuickSort","dirtyIndices","useNativeQuickSort","zList","compare","a","b","Array","prototype","sort","call","_quickSort","step"],"sources":["E:/mytest/node_modules/echarts-gl/lib/util/geometry/verticesSortMixin.js"],"sourcesContent":["import ProgressiveQuickSort from '../ProgressiveQuickSort';\nimport glmatrix from 'claygl/src/dep/glmatrix';\nvar vec3 = glmatrix.vec3;\nexport default {\n  needsSortVertices: function () {\n    return this.sortVertices;\n  },\n  needsSortVerticesProgressively: function () {\n    return this.needsSortVertices() && this.vertexCount >= 2e4;\n  },\n  doSortVertices: function (cameraPos, frame) {\n    var indices = this.indices;\n    var p = vec3.create();\n\n    if (!indices) {\n      indices = this.indices = this.vertexCount > 0xffff ? new Uint32Array(this.vertexCount) : new Uint16Array(this.vertexCount);\n\n      for (var i = 0; i < indices.length; i++) {\n        indices[i] = i;\n      }\n    } // Do progressive quick sort.\n\n\n    if (frame === 0) {\n      var posAttr = this.attributes.position;\n      var cameraPos = cameraPos.array;\n      var noneCount = 0;\n\n      if (!this._zList || this._zList.length !== this.vertexCount) {\n        this._zList = new Float32Array(this.vertexCount);\n      }\n\n      var firstZ;\n\n      for (var i = 0; i < this.vertexCount; i++) {\n        posAttr.get(i, p); // Camera position is in object space\n\n        var z = vec3.sqrDist(p, cameraPos);\n\n        if (isNaN(z)) {\n          // Put far away, NaN value may cause sort slow\n          z = 1e7;\n          noneCount++;\n        }\n\n        if (i === 0) {\n          firstZ = z;\n          z = 0;\n        } else {\n          // Only store the difference to avoid the precision issue.\n          z = z - firstZ;\n        }\n\n        this._zList[i] = z;\n      }\n\n      this._noneCount = noneCount;\n    }\n\n    if (this.vertexCount < 2e4) {\n      // Use simple native sort for simple geometries.\n      if (frame === 0) {\n        this._simpleSort(this._noneCount / this.vertexCount > 0.05);\n      }\n    } else {\n      for (var i = 0; i < 3; i++) {\n        this._progressiveQuickSort(frame * 3 + i);\n      }\n    }\n\n    this.dirtyIndices();\n  },\n  _simpleSort: function (useNativeQuickSort) {\n    var zList = this._zList;\n    var indices = this.indices;\n\n    function compare(a, b) {\n      // Sort from far to near. which is descending order\n      return zList[b] - zList[a];\n    } // When too much value are equal, using native quick sort with three partition..\n    // or the simple quick sort will be nearly O(n*n)\n    // http://stackoverflow.com/questions/5126586/quicksort-complexity-when-all-the-elements-are-same\n    // Otherwise simple quicksort is more effecient than v8 native quick sort when data all different.\n\n\n    if (useNativeQuickSort) {\n      Array.prototype.sort.call(indices, compare);\n    } else {\n      ProgressiveQuickSort.sort(indices, compare, 0, indices.length - 1);\n    }\n  },\n  _progressiveQuickSort: function (frame) {\n    var zList = this._zList;\n    var indices = this.indices;\n    this._quickSort = this._quickSort || new ProgressiveQuickSort();\n\n    this._quickSort.step(indices, function (a, b) {\n      return zList[b] - zList[a];\n    }, frame);\n  }\n};"],"mappings":";;;;;;AAAA,OAAOA,oBAAoB,MAAM,yBAAyB;AAC1D,OAAOC,QAAQ,MAAM,yBAAyB;AAC9C,IAAIC,IAAI,GAAGD,QAAQ,CAACC,IAAI;AACxB,eAAe;EACbC,iBAAiB,EAAE,SAAAA,CAAA,EAAY;IAC7B,OAAO,IAAI,CAACC,YAAY;EAC1B,CAAC;EACDC,8BAA8B,EAAE,SAAAA,CAAA,EAAY;IAC1C,OAAO,IAAI,CAACF,iBAAiB,CAAC,CAAC,IAAI,IAAI,CAACG,WAAW,IAAI,GAAG;EAC5D,CAAC;EACDC,cAAc,EAAE,SAAAA,CAAUC,SAAS,EAAEC,KAAK,EAAE;IAC1C,IAAIC,OAAO,GAAG,IAAI,CAACA,OAAO;IAC1B,IAAIC,CAAC,GAAGT,IAAI,CAACU,MAAM,CAAC,CAAC;IAErB,IAAI,CAACF,OAAO,EAAE;MACZA,OAAO,GAAG,IAAI,CAACA,OAAO,GAAG,IAAI,CAACJ,WAAW,GAAG,MAAM,GAAG,IAAIO,WAAW,CAAC,IAAI,CAACP,WAAW,CAAC,GAAG,IAAIQ,WAAW,CAAC,IAAI,CAACR,WAAW,CAAC;MAE1H,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,OAAO,CAACM,MAAM,EAAED,CAAC,EAAE,EAAE;QACvCL,OAAO,CAACK,CAAC,CAAC,GAAGA,CAAC;MAChB;IACF,CAAC,CAAC;;IAGF,IAAIN,KAAK,KAAK,CAAC,EAAE;MACf,IAAIQ,OAAO,GAAG,IAAI,CAACC,UAAU,CAACC,QAAQ;MACtC,IAAIX,SAAS,GAAGA,SAAS,CAACY,KAAK;MAC/B,IAAIC,SAAS,GAAG,CAAC;MAEjB,IAAI,CAAC,IAAI,CAACC,MAAM,IAAI,IAAI,CAACA,MAAM,CAACN,MAAM,KAAK,IAAI,CAACV,WAAW,EAAE;QAC3D,IAAI,CAACgB,MAAM,GAAG,IAAIC,YAAY,CAAC,IAAI,CAACjB,WAAW,CAAC;MAClD;MAEA,IAAIkB,MAAM;MAEV,KAAK,IAAIT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACT,WAAW,EAAES,CAAC,EAAE,EAAE;QACzCE,OAAO,CAACQ,GAAG,CAACV,CAAC,EAAEJ,CAAC,CAAC,CAAC,CAAC;;QAEnB,IAAIe,CAAC,GAAGxB,IAAI,CAACyB,OAAO,CAAChB,CAAC,EAAEH,SAAS,CAAC;QAElC,IAAIoB,KAAK,CAACF,CAAC,CAAC,EAAE;UACZ;UACAA,CAAC,GAAG,GAAG;UACPL,SAAS,EAAE;QACb;QAEA,IAAIN,CAAC,KAAK,CAAC,EAAE;UACXS,MAAM,GAAGE,CAAC;UACVA,CAAC,GAAG,CAAC;QACP,CAAC,MAAM;UACL;UACAA,CAAC,GAAGA,CAAC,GAAGF,MAAM;QAChB;QAEA,IAAI,CAACF,MAAM,CAACP,CAAC,CAAC,GAAGW,CAAC;MACpB;MAEA,IAAI,CAACG,UAAU,GAAGR,SAAS;IAC7B;IAEA,IAAI,IAAI,CAACf,WAAW,GAAG,GAAG,EAAE;MAC1B;MACA,IAAIG,KAAK,KAAK,CAAC,EAAE;QACf,IAAI,CAACqB,WAAW,CAAC,IAAI,CAACD,UAAU,GAAG,IAAI,CAACvB,WAAW,GAAG,IAAI,CAAC;MAC7D;IACF,CAAC,MAAM;MACL,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QAC1B,IAAI,CAACgB,qBAAqB,CAACtB,KAAK,GAAG,CAAC,GAAGM,CAAC,CAAC;MAC3C;IACF;IAEA,IAAI,CAACiB,YAAY,CAAC,CAAC;EACrB,CAAC;EACDF,WAAW,EAAE,SAAAA,CAAUG,kBAAkB,EAAE;IACzC,IAAIC,KAAK,GAAG,IAAI,CAACZ,MAAM;IACvB,IAAIZ,OAAO,GAAG,IAAI,CAACA,OAAO;IAE1B,SAASyB,OAAOA,CAACC,CAAC,EAAEC,CAAC,EAAE;MACrB;MACA,OAAOH,KAAK,CAACG,CAAC,CAAC,GAAGH,KAAK,CAACE,CAAC,CAAC;IAC5B,CAAC,CAAC;IACF;IACA;IACA;;IAGA,IAAIH,kBAAkB,EAAE;MACtBK,KAAK,CAACC,SAAS,CAACC,IAAI,CAACC,IAAI,CAAC/B,OAAO,EAAEyB,OAAO,CAAC;IAC7C,CAAC,MAAM;MACLnC,oBAAoB,CAACwC,IAAI,CAAC9B,OAAO,EAAEyB,OAAO,EAAE,CAAC,EAAEzB,OAAO,CAACM,MAAM,GAAG,CAAC,CAAC;IACpE;EACF,CAAC;EACDe,qBAAqB,EAAE,SAAAA,CAAUtB,KAAK,EAAE;IACtC,IAAIyB,KAAK,GAAG,IAAI,CAACZ,MAAM;IACvB,IAAIZ,OAAO,GAAG,IAAI,CAACA,OAAO;IAC1B,IAAI,CAACgC,UAAU,GAAG,IAAI,CAACA,UAAU,IAAI,IAAI1C,oBAAoB,CAAC,CAAC;IAE/D,IAAI,CAAC0C,UAAU,CAACC,IAAI,CAACjC,OAAO,EAAE,UAAU0B,CAAC,EAAEC,CAAC,EAAE;MAC5C,OAAOH,KAAK,CAACG,CAAC,CAAC,GAAGH,KAAK,CAACE,CAAC,CAAC;IAC5B,CAAC,EAAE3B,KAAK,CAAC;EACX;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}