{"ast":null,"code":"import Geo3DBuilder from '../common/Geo3DBuilder';\nimport * as echarts from 'echarts/lib/echarts';\nimport graphicGL from '../../util/graphicGL';\nimport OrbitControl from '../../util/OrbitControl';\nimport SceneHelper from '../common/SceneHelper';\nexport default echarts.ComponentView.extend({\n  type: 'geo3D',\n  __ecgl__: true,\n  init: function (ecModel, api) {\n    this._geo3DBuilder = new Geo3DBuilder(api);\n    this.groupGL = new graphicGL.Node();\n    this._lightRoot = new graphicGL.Node();\n    this._sceneHelper = new SceneHelper(this._lightRoot);\n    this._sceneHelper.initLight(this._lightRoot);\n    this._control = new OrbitControl({\n      zr: api.getZr()\n    });\n    this._control.init();\n  },\n  render: function (geo3DModel, ecModel, api) {\n    this.groupGL.add(this._geo3DBuilder.rootNode);\n    var geo3D = geo3DModel.coordinateSystem;\n    if (!geo3D || !geo3D.viewGL) {\n      return;\n    } // Always have light.\n\n    geo3D.viewGL.add(this._lightRoot);\n    if (geo3DModel.get('show')) {\n      geo3D.viewGL.add(this.groupGL);\n    } else {\n      geo3D.viewGL.remove(this.groupGL);\n    }\n    var control = this._control;\n    control.setViewGL(geo3D.viewGL);\n    var viewControlModel = geo3DModel.getModel('viewControl');\n    control.setFromViewControlModel(viewControlModel, 0);\n    this._sceneHelper.setScene(geo3D.viewGL.scene);\n    this._sceneHelper.updateLight(geo3DModel); // Set post effect\n\n    geo3D.viewGL.setPostEffect(geo3DModel.getModel('postEffect'), api);\n    geo3D.viewGL.setTemporalSuperSampling(geo3DModel.getModel('temporalSuperSampling')); // Must update after geo3D.viewGL.setPostEffect\n\n    this._geo3DBuilder.update(geo3DModel, ecModel, api, 0, geo3DModel.getData().count());\n    var srgbDefineMethod = geo3D.viewGL.isLinearSpace() ? 'define' : 'undefine';\n    this._geo3DBuilder.rootNode.traverse(function (mesh) {\n      if (mesh.material) {\n        mesh.material[srgbDefineMethod]('fragment', 'SRGB_DECODE');\n      }\n    });\n    control.off('update');\n    control.on('update', function () {\n      api.dispatchAction({\n        type: 'geo3DChangeCamera',\n        alpha: control.getAlpha(),\n        beta: control.getBeta(),\n        distance: control.getDistance(),\n        center: control.getCenter(),\n        from: this.uid,\n        geo3DId: geo3DModel.id\n      });\n    });\n    control.update();\n  },\n  afterRender: function (geo3DModel, ecModel, api, layerGL) {\n    var renderer = layerGL.renderer;\n    this._sceneHelper.updateAmbientCubemap(renderer, geo3DModel, api);\n    this._sceneHelper.updateSkybox(renderer, geo3DModel, api);\n  },\n  dispose: function () {\n    this._control.dispose();\n    this._geo3DBuilder.dispose();\n  }\n});","map":{"version":3,"names":["Geo3DBuilder","echarts","graphicGL","OrbitControl","SceneHelper","ComponentView","extend","type","__ecgl__","init","ecModel","api","_geo3DBuilder","groupGL","Node","_lightRoot","_sceneHelper","initLight","_control","zr","getZr","render","geo3DModel","add","rootNode","geo3D","coordinateSystem","viewGL","get","remove","control","setViewGL","viewControlModel","getModel","setFromViewControlModel","setScene","scene","updateLight","setPostEffect","setTemporalSuperSampling","update","getData","count","srgbDefineMethod","isLinearSpace","traverse","mesh","material","off","on","dispatchAction","alpha","getAlpha","beta","getBeta","distance","getDistance","center","getCenter","from","uid","geo3DId","id","afterRender","layerGL","renderer","updateAmbientCubemap","updateSkybox","dispose"],"sources":["E:/mytest/node_modules/echarts-gl/lib/component/geo3D/Geo3DView.js"],"sourcesContent":["import Geo3DBuilder from '../common/Geo3DBuilder';\nimport * as echarts from 'echarts/lib/echarts';\nimport graphicGL from '../../util/graphicGL';\nimport OrbitControl from '../../util/OrbitControl';\nimport SceneHelper from '../common/SceneHelper';\nexport default echarts.ComponentView.extend({\n  type: 'geo3D',\n  __ecgl__: true,\n  init: function (ecModel, api) {\n    this._geo3DBuilder = new Geo3DBuilder(api);\n    this.groupGL = new graphicGL.Node();\n    this._lightRoot = new graphicGL.Node();\n    this._sceneHelper = new SceneHelper(this._lightRoot);\n\n    this._sceneHelper.initLight(this._lightRoot);\n\n    this._control = new OrbitControl({\n      zr: api.getZr()\n    });\n\n    this._control.init();\n  },\n  render: function (geo3DModel, ecModel, api) {\n    this.groupGL.add(this._geo3DBuilder.rootNode);\n    var geo3D = geo3DModel.coordinateSystem;\n\n    if (!geo3D || !geo3D.viewGL) {\n      return;\n    } // Always have light.\n\n\n    geo3D.viewGL.add(this._lightRoot);\n\n    if (geo3DModel.get('show')) {\n      geo3D.viewGL.add(this.groupGL);\n    } else {\n      geo3D.viewGL.remove(this.groupGL);\n    }\n\n    var control = this._control;\n    control.setViewGL(geo3D.viewGL);\n    var viewControlModel = geo3DModel.getModel('viewControl');\n    control.setFromViewControlModel(viewControlModel, 0);\n\n    this._sceneHelper.setScene(geo3D.viewGL.scene);\n\n    this._sceneHelper.updateLight(geo3DModel); // Set post effect\n\n\n    geo3D.viewGL.setPostEffect(geo3DModel.getModel('postEffect'), api);\n    geo3D.viewGL.setTemporalSuperSampling(geo3DModel.getModel('temporalSuperSampling')); // Must update after geo3D.viewGL.setPostEffect\n\n    this._geo3DBuilder.update(geo3DModel, ecModel, api, 0, geo3DModel.getData().count());\n\n    var srgbDefineMethod = geo3D.viewGL.isLinearSpace() ? 'define' : 'undefine';\n\n    this._geo3DBuilder.rootNode.traverse(function (mesh) {\n      if (mesh.material) {\n        mesh.material[srgbDefineMethod]('fragment', 'SRGB_DECODE');\n      }\n    });\n\n    control.off('update');\n    control.on('update', function () {\n      api.dispatchAction({\n        type: 'geo3DChangeCamera',\n        alpha: control.getAlpha(),\n        beta: control.getBeta(),\n        distance: control.getDistance(),\n        center: control.getCenter(),\n        from: this.uid,\n        geo3DId: geo3DModel.id\n      });\n    });\n    control.update();\n  },\n  afterRender: function (geo3DModel, ecModel, api, layerGL) {\n    var renderer = layerGL.renderer;\n\n    this._sceneHelper.updateAmbientCubemap(renderer, geo3DModel, api);\n\n    this._sceneHelper.updateSkybox(renderer, geo3DModel, api);\n  },\n  dispose: function () {\n    this._control.dispose();\n\n    this._geo3DBuilder.dispose();\n  }\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}