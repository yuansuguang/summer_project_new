{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * Texture Atlas for the sprites.\n * It uses zrender for 2d element management and rendering\n * @module echarts-gl/util/ZRTextureAtlasSurface\n */\n// TODO Expand.\nimport * as echarts from 'echarts/lib/echarts';\nimport Texture2D from 'claygl/src/Texture2D';\nfunction ZRTextureAtlasSurfaceNode(zr, offsetX, offsetY, width, height, gap, dpr) {\n  this._zr = zr;\n  /**\n   * Current cursor x\n   * @type {number}\n   * @private\n   */\n\n  this._x = 0;\n  /**\n   * Current cursor y\n   * @type {number}\n   */\n\n  this._y = 0;\n  this._rowHeight = 0;\n  /**\n   * width without dpr.\n   * @type {number}\n   * @private\n   */\n\n  this.width = width;\n  /**\n   * height without dpr.\n   * @type {number}\n   * @private\n   */\n\n  this.height = height;\n  /**\n   * offsetX without dpr\n   * @type {number}\n   */\n\n  this.offsetX = offsetX;\n  /**\n   * offsetY without dpr\n   * @type {number}\n   */\n\n  this.offsetY = offsetY;\n  this.dpr = dpr;\n  this.gap = gap;\n}\nZRTextureAtlasSurfaceNode.prototype = {\n  constructor: ZRTextureAtlasSurfaceNode,\n  clear: function () {\n    this._x = 0;\n    this._y = 0;\n    this._rowHeight = 0;\n  },\n  /**\n   * Add shape to atlas\n   * @param {module:zrender/graphic/Displayable} shape\n   * @param {number} width\n   * @param {number} height\n   * @return {Array}\n   */\n  add: function (el, width, height) {\n    // FIXME Text element not consider textAlign and textVerticalAlign.\n    // TODO, inner text, shadow\n    var rect = el.getBoundingRect(); // FIXME aspect ratio\n\n    if (width == null) {\n      width = rect.width;\n    }\n    if (height == null) {\n      height = rect.height;\n    }\n    width *= this.dpr;\n    height *= this.dpr;\n    this._fitElement(el, width, height); // var aspect = el.scale[1] / el.scale[0];\n    // Adjust aspect ratio to make the text more clearly\n    // FIXME If height > width, width is useless ?\n    // width = height * aspect;\n    // el.position[0] *= aspect;\n    // el.scale[0] = el.scale[1];\n\n    var x = this._x;\n    var y = this._y;\n    var canvasWidth = this.width * this.dpr;\n    var canvasHeight = this.height * this.dpr;\n    var gap = this.gap;\n    if (x + width + gap > canvasWidth) {\n      // Change a new row\n      x = this._x = 0;\n      y += this._rowHeight + gap;\n      this._y = y; // Reset row height\n\n      this._rowHeight = 0;\n    }\n    this._x += width + gap;\n    this._rowHeight = Math.max(this._rowHeight, height);\n    if (y + height + gap > canvasHeight) {\n      // There is no space anymore\n      return null;\n    } // Shift the el\n\n    el.x += this.offsetX * this.dpr + x;\n    el.y += this.offsetY * this.dpr + y;\n    this._zr.add(el);\n    var coordsOffset = [this.offsetX / this.width, this.offsetY / this.height];\n    var coords = [[x / canvasWidth + coordsOffset[0], y / canvasHeight + coordsOffset[1]], [(x + width) / canvasWidth + coordsOffset[0], (y + height) / canvasHeight + coordsOffset[1]]];\n    return coords;\n  },\n  /**\n   * Fit element size by correct its position and scaling\n   * @param {module:zrender/graphic/Displayable} el\n   * @param {number} spriteWidth\n   * @param {number} spriteHeight\n   */\n  _fitElement: function (el, spriteWidth, spriteHeight) {\n    // TODO, inner text, shadow\n    var rect = el.getBoundingRect();\n    var scaleX = spriteWidth / rect.width;\n    var scaleY = spriteHeight / rect.height;\n    el.x = -rect.x * scaleX;\n    el.y = -rect.y * scaleY;\n    el.scaleX = scaleX;\n    el.scaleY = scaleY;\n    el.update();\n  }\n};\n/**\n * constructor\n * @alias module:echarts-gl/util/ZRTextureAtlasSurface\n * @param {number} opt.width\n * @param {number} opt.height\n * @param {number} opt.devicePixelRatio\n * @param {number} opt.gap Gap for safe.\n * @param {Function} opt.onupdate\n */\n\nfunction ZRTextureAtlasSurface(opt) {\n  opt = opt || {};\n  opt.width = opt.width || 512;\n  opt.height = opt.height || 512;\n  opt.devicePixelRatio = opt.devicePixelRatio || 1;\n  opt.gap = opt.gap == null ? 2 : opt.gap;\n  var canvas = document.createElement('canvas');\n  canvas.width = opt.width * opt.devicePixelRatio;\n  canvas.height = opt.height * opt.devicePixelRatio;\n  this._canvas = canvas;\n  this._texture = new Texture2D({\n    image: canvas,\n    flipY: false\n  });\n  var self = this;\n  /**\n   * zrender instance in the Chart\n   * @type {zrender~ZRender}\n   */\n\n  this._zr = echarts.zrender.init(canvas);\n  var oldRefreshImmediately = this._zr.refreshImmediately;\n  this._zr.refreshImmediately = function () {\n    oldRefreshImmediately.call(this);\n    self._texture.dirty();\n    self.onupdate && self.onupdate();\n  };\n  this._dpr = opt.devicePixelRatio;\n  /**\n   * Texture coords map for each sprite image\n   * @type {Object}\n   */\n\n  this._coords = {};\n  this.onupdate = opt.onupdate;\n  this._gap = opt.gap; // Left sub atlas.\n\n  this._textureAtlasNodes = [new ZRTextureAtlasSurfaceNode(this._zr, 0, 0, opt.width, opt.height, this._gap, this._dpr)];\n  this._nodeWidth = opt.width;\n  this._nodeHeight = opt.height;\n  this._currentNodeIdx = 0;\n}\nZRTextureAtlasSurface.prototype = {\n  /**\n   * Clear the texture atlas\n   */\n  clear: function () {\n    for (var i = 0; i < this._textureAtlasNodes.length; i++) {\n      this._textureAtlasNodes[i].clear();\n    }\n    this._currentNodeIdx = 0;\n    this._zr.clear();\n    this._coords = {};\n  },\n  /**\n   * @return {number}\n   */\n  getWidth: function () {\n    return this._width;\n  },\n  /**\n   * @return {number}\n   */\n  getHeight: function () {\n    return this._height;\n  },\n  /**\n   * @return {number}\n   */\n  getTexture: function () {\n    return this._texture;\n  },\n  /**\n   * @return {number}\n   */\n  getDevicePixelRatio: function () {\n    return this._dpr;\n  },\n  getZr: function () {\n    return this._zr;\n  },\n  _getCurrentNode: function () {\n    return this._textureAtlasNodes[this._currentNodeIdx];\n  },\n  _expand: function () {\n    this._currentNodeIdx++;\n    if (this._textureAtlasNodes[this._currentNodeIdx]) {\n      // Use the node created previously.\n      return this._textureAtlasNodes[this._currentNodeIdx];\n    }\n    var maxSize = 4096 / this._dpr;\n    var textureAtlasNodes = this._textureAtlasNodes;\n    var nodeLen = textureAtlasNodes.length;\n    var offsetX = nodeLen * this._nodeWidth % maxSize;\n    var offsetY = Math.floor(nodeLen * this._nodeWidth / maxSize) * this._nodeHeight;\n    if (offsetY >= maxSize) {\n      // Failed if image is too large.\n      if (process.env.NODE_ENV !== 'production') {\n        console.error('Too much labels. Some will be ignored.');\n      }\n      return;\n    }\n    var width = (offsetX + this._nodeWidth) * this._dpr;\n    var height = (offsetY + this._nodeHeight) * this._dpr;\n    try {\n      // Resize will error in node.\n      this._zr.resize({\n        width: width,\n        height: height\n      });\n    } catch (e) {\n      this._canvas.width = width;\n      this._canvas.height = height;\n    }\n    var newNode = new ZRTextureAtlasSurfaceNode(this._zr, offsetX, offsetY, this._nodeWidth, this._nodeHeight, this._gap, this._dpr);\n    this._textureAtlasNodes.push(newNode);\n    return newNode;\n  },\n  add: function (el, width, height) {\n    if (this._coords[el.id]) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn('Element already been add');\n      }\n      return this._coords[el.id];\n    }\n    var coords = this._getCurrentNode().add(el, width, height);\n    if (!coords) {\n      var newNode = this._expand();\n      if (!newNode) {\n        // To maximum\n        return;\n      }\n      coords = newNode.add(el, width, height);\n    }\n    this._coords[el.id] = coords;\n    return coords;\n  },\n  /**\n   * Get coord scale after texture atlas is expanded.\n   * @return {Array.<number>}\n   */\n  getCoordsScale: function () {\n    var dpr = this._dpr;\n    return [this._nodeWidth / this._canvas.width * dpr, this._nodeHeight / this._canvas.height * dpr];\n  },\n  /**\n   * Get texture coords of sprite image\n   * @param  {string} id Image id\n   * @return {Array}\n   */\n  getCoords: function (id) {\n    return this._coords[id];\n  },\n  dispose: function () {\n    this._zr.dispose();\n  }\n};\nexport default ZRTextureAtlasSurface;","map":{"version":3,"names":["echarts","Texture2D","ZRTextureAtlasSurfaceNode","zr","offsetX","offsetY","width","height","gap","dpr","_zr","_x","_y","_rowHeight","prototype","constructor","clear","add","el","rect","getBoundingRect","_fitElement","x","y","canvasWidth","canvasHeight","Math","max","coordsOffset","coords","spriteWidth","spriteHeight","scaleX","scaleY","update","ZRTextureAtlasSurface","opt","devicePixelRatio","canvas","document","createElement","_canvas","_texture","image","flipY","self","zrender","init","oldRefreshImmediately","refreshImmediately","call","dirty","onupdate","_dpr","_coords","_gap","_textureAtlasNodes","_nodeWidth","_nodeHeight","_currentNodeIdx","i","length","getWidth","_width","getHeight","_height","getTexture","getDevicePixelRatio","getZr","_getCurrentNode","_expand","maxSize","textureAtlasNodes","nodeLen","floor","process","env","NODE_ENV","console","error","resize","e","newNode","push","id","warn","getCoordsScale","getCoords","dispose"],"sources":["E:/QuestionairePlanet_Fronted/mytest/node_modules/echarts-gl/lib/util/ZRTextureAtlasSurface.js"],"sourcesContent":["/**\n * Texture Atlas for the sprites.\n * It uses zrender for 2d element management and rendering\n * @module echarts-gl/util/ZRTextureAtlasSurface\n */\n// TODO Expand.\nimport * as echarts from 'echarts/lib/echarts';\nimport Texture2D from 'claygl/src/Texture2D';\n\nfunction ZRTextureAtlasSurfaceNode(zr, offsetX, offsetY, width, height, gap, dpr) {\n  this._zr = zr;\n  /**\n   * Current cursor x\n   * @type {number}\n   * @private\n   */\n\n  this._x = 0;\n  /**\n   * Current cursor y\n   * @type {number}\n   */\n\n  this._y = 0;\n  this._rowHeight = 0;\n  /**\n   * width without dpr.\n   * @type {number}\n   * @private\n   */\n\n  this.width = width;\n  /**\n   * height without dpr.\n   * @type {number}\n   * @private\n   */\n\n  this.height = height;\n  /**\n   * offsetX without dpr\n   * @type {number}\n   */\n\n  this.offsetX = offsetX;\n  /**\n   * offsetY without dpr\n   * @type {number}\n   */\n\n  this.offsetY = offsetY;\n  this.dpr = dpr;\n  this.gap = gap;\n}\n\nZRTextureAtlasSurfaceNode.prototype = {\n  constructor: ZRTextureAtlasSurfaceNode,\n  clear: function () {\n    this._x = 0;\n    this._y = 0;\n    this._rowHeight = 0;\n  },\n\n  /**\n   * Add shape to atlas\n   * @param {module:zrender/graphic/Displayable} shape\n   * @param {number} width\n   * @param {number} height\n   * @return {Array}\n   */\n  add: function (el, width, height) {\n    // FIXME Text element not consider textAlign and textVerticalAlign.\n    // TODO, inner text, shadow\n    var rect = el.getBoundingRect(); // FIXME aspect ratio\n\n    if (width == null) {\n      width = rect.width;\n    }\n\n    if (height == null) {\n      height = rect.height;\n    }\n\n    width *= this.dpr;\n    height *= this.dpr;\n\n    this._fitElement(el, width, height); // var aspect = el.scale[1] / el.scale[0];\n    // Adjust aspect ratio to make the text more clearly\n    // FIXME If height > width, width is useless ?\n    // width = height * aspect;\n    // el.position[0] *= aspect;\n    // el.scale[0] = el.scale[1];\n\n\n    var x = this._x;\n    var y = this._y;\n    var canvasWidth = this.width * this.dpr;\n    var canvasHeight = this.height * this.dpr;\n    var gap = this.gap;\n\n    if (x + width + gap > canvasWidth) {\n      // Change a new row\n      x = this._x = 0;\n      y += this._rowHeight + gap;\n      this._y = y; // Reset row height\n\n      this._rowHeight = 0;\n    }\n\n    this._x += width + gap;\n    this._rowHeight = Math.max(this._rowHeight, height);\n\n    if (y + height + gap > canvasHeight) {\n      // There is no space anymore\n      return null;\n    } // Shift the el\n\n\n    el.x += this.offsetX * this.dpr + x;\n    el.y += this.offsetY * this.dpr + y;\n\n    this._zr.add(el);\n\n    var coordsOffset = [this.offsetX / this.width, this.offsetY / this.height];\n    var coords = [[x / canvasWidth + coordsOffset[0], y / canvasHeight + coordsOffset[1]], [(x + width) / canvasWidth + coordsOffset[0], (y + height) / canvasHeight + coordsOffset[1]]];\n    return coords;\n  },\n\n  /**\n   * Fit element size by correct its position and scaling\n   * @param {module:zrender/graphic/Displayable} el\n   * @param {number} spriteWidth\n   * @param {number} spriteHeight\n   */\n  _fitElement: function (el, spriteWidth, spriteHeight) {\n    // TODO, inner text, shadow\n    var rect = el.getBoundingRect();\n    var scaleX = spriteWidth / rect.width;\n    var scaleY = spriteHeight / rect.height;\n    el.x = -rect.x * scaleX;\n    el.y = -rect.y * scaleY;\n    el.scaleX = scaleX;\n    el.scaleY = scaleY;\n    el.update();\n  }\n};\n/**\n * constructor\n * @alias module:echarts-gl/util/ZRTextureAtlasSurface\n * @param {number} opt.width\n * @param {number} opt.height\n * @param {number} opt.devicePixelRatio\n * @param {number} opt.gap Gap for safe.\n * @param {Function} opt.onupdate\n */\n\nfunction ZRTextureAtlasSurface(opt) {\n  opt = opt || {};\n  opt.width = opt.width || 512;\n  opt.height = opt.height || 512;\n  opt.devicePixelRatio = opt.devicePixelRatio || 1;\n  opt.gap = opt.gap == null ? 2 : opt.gap;\n  var canvas = document.createElement('canvas');\n  canvas.width = opt.width * opt.devicePixelRatio;\n  canvas.height = opt.height * opt.devicePixelRatio;\n  this._canvas = canvas;\n  this._texture = new Texture2D({\n    image: canvas,\n    flipY: false\n  });\n  var self = this;\n  /**\n   * zrender instance in the Chart\n   * @type {zrender~ZRender}\n   */\n\n  this._zr = echarts.zrender.init(canvas);\n  var oldRefreshImmediately = this._zr.refreshImmediately;\n\n  this._zr.refreshImmediately = function () {\n    oldRefreshImmediately.call(this);\n\n    self._texture.dirty();\n\n    self.onupdate && self.onupdate();\n  };\n\n  this._dpr = opt.devicePixelRatio;\n  /**\n   * Texture coords map for each sprite image\n   * @type {Object}\n   */\n\n  this._coords = {};\n  this.onupdate = opt.onupdate;\n  this._gap = opt.gap; // Left sub atlas.\n\n  this._textureAtlasNodes = [new ZRTextureAtlasSurfaceNode(this._zr, 0, 0, opt.width, opt.height, this._gap, this._dpr)];\n  this._nodeWidth = opt.width;\n  this._nodeHeight = opt.height;\n  this._currentNodeIdx = 0;\n}\n\nZRTextureAtlasSurface.prototype = {\n  /**\n   * Clear the texture atlas\n   */\n  clear: function () {\n    for (var i = 0; i < this._textureAtlasNodes.length; i++) {\n      this._textureAtlasNodes[i].clear();\n    }\n\n    this._currentNodeIdx = 0;\n\n    this._zr.clear();\n\n    this._coords = {};\n  },\n\n  /**\n   * @return {number}\n   */\n  getWidth: function () {\n    return this._width;\n  },\n\n  /**\n   * @return {number}\n   */\n  getHeight: function () {\n    return this._height;\n  },\n\n  /**\n   * @return {number}\n   */\n  getTexture: function () {\n    return this._texture;\n  },\n\n  /**\n   * @return {number}\n   */\n  getDevicePixelRatio: function () {\n    return this._dpr;\n  },\n  getZr: function () {\n    return this._zr;\n  },\n  _getCurrentNode: function () {\n    return this._textureAtlasNodes[this._currentNodeIdx];\n  },\n  _expand: function () {\n    this._currentNodeIdx++;\n\n    if (this._textureAtlasNodes[this._currentNodeIdx]) {\n      // Use the node created previously.\n      return this._textureAtlasNodes[this._currentNodeIdx];\n    }\n\n    var maxSize = 4096 / this._dpr;\n    var textureAtlasNodes = this._textureAtlasNodes;\n    var nodeLen = textureAtlasNodes.length;\n    var offsetX = nodeLen * this._nodeWidth % maxSize;\n\n    var offsetY = Math.floor(nodeLen * this._nodeWidth / maxSize) * this._nodeHeight;\n\n    if (offsetY >= maxSize) {\n      // Failed if image is too large.\n      if (process.env.NODE_ENV !== 'production') {\n        console.error('Too much labels. Some will be ignored.');\n      }\n\n      return;\n    }\n\n    var width = (offsetX + this._nodeWidth) * this._dpr;\n    var height = (offsetY + this._nodeHeight) * this._dpr;\n\n    try {\n      // Resize will error in node.\n      this._zr.resize({\n        width: width,\n        height: height\n      });\n    } catch (e) {\n      this._canvas.width = width;\n      this._canvas.height = height;\n    }\n\n    var newNode = new ZRTextureAtlasSurfaceNode(this._zr, offsetX, offsetY, this._nodeWidth, this._nodeHeight, this._gap, this._dpr);\n\n    this._textureAtlasNodes.push(newNode);\n\n    return newNode;\n  },\n  add: function (el, width, height) {\n    if (this._coords[el.id]) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn('Element already been add');\n      }\n\n      return this._coords[el.id];\n    }\n\n    var coords = this._getCurrentNode().add(el, width, height);\n\n    if (!coords) {\n      var newNode = this._expand();\n\n      if (!newNode) {\n        // To maximum\n        return;\n      }\n\n      coords = newNode.add(el, width, height);\n    }\n\n    this._coords[el.id] = coords;\n    return coords;\n  },\n\n  /**\n   * Get coord scale after texture atlas is expanded.\n   * @return {Array.<number>}\n   */\n  getCoordsScale: function () {\n    var dpr = this._dpr;\n    return [this._nodeWidth / this._canvas.width * dpr, this._nodeHeight / this._canvas.height * dpr];\n  },\n\n  /**\n   * Get texture coords of sprite image\n   * @param  {string} id Image id\n   * @return {Array}\n   */\n  getCoords: function (id) {\n    return this._coords[id];\n  },\n  dispose: function () {\n    this._zr.dispose();\n  }\n};\nexport default ZRTextureAtlasSurface;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}