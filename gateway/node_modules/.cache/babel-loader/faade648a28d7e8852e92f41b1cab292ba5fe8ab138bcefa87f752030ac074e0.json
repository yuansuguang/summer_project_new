{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * Mainly do the parse and compile of shader string\n * Support shader code chunk import and export\n * Support shader semantics\n * http://www.nvidia.com/object/using_sas.html\n * https://github.com/KhronosGroup/collada2json/issues/45\n */\nimport util from './core/util';\nimport vendor from './core/vendor';\nvar uniformRegex = /uniform\\s+(bool|float|int|vec2|vec3|vec4|ivec2|ivec3|ivec4|mat2|mat3|mat4|sampler2D|samplerCube)\\s+([\\s\\S]*?);/g;\nvar attributeRegex = /attribute\\s+(float|int|vec2|vec3|vec4)\\s+([\\s\\S]*?);/g;\n// Only parse number define.\nvar defineRegex = /#define\\s+(\\w+)?(\\s+[\\d-.]+)?\\s*;?\\s*\\n/g;\nvar uniformTypeMap = {\n  'bool': '1i',\n  'int': '1i',\n  'sampler2D': 't',\n  'samplerCube': 't',\n  'float': '1f',\n  'vec2': '2f',\n  'vec3': '3f',\n  'vec4': '4f',\n  'ivec2': '2i',\n  'ivec3': '3i',\n  'ivec4': '4i',\n  'mat2': 'm2',\n  'mat3': 'm3',\n  'mat4': 'm4'\n};\nfunction createZeroArray(len) {\n  var arr = [];\n  for (var i = 0; i < len; i++) {\n    arr[i] = 0;\n  }\n  return arr;\n}\nvar uniformValueConstructor = {\n  'bool': function () {\n    return true;\n  },\n  'int': function () {\n    return 0;\n  },\n  'float': function () {\n    return 0;\n  },\n  'sampler2D': function () {\n    return null;\n  },\n  'samplerCube': function () {\n    return null;\n  },\n  'vec2': function () {\n    return createZeroArray(2);\n  },\n  'vec3': function () {\n    return createZeroArray(3);\n  },\n  'vec4': function () {\n    return createZeroArray(4);\n  },\n  'ivec2': function () {\n    return createZeroArray(2);\n  },\n  'ivec3': function () {\n    return createZeroArray(3);\n  },\n  'ivec4': function () {\n    return createZeroArray(4);\n  },\n  'mat2': function () {\n    return createZeroArray(4);\n  },\n  'mat3': function () {\n    return createZeroArray(9);\n  },\n  'mat4': function () {\n    return createZeroArray(16);\n  },\n  'array': function () {\n    return [];\n  }\n};\nvar attributeSemantics = ['POSITION', 'NORMAL', 'BINORMAL', 'TANGENT', 'TEXCOORD', 'TEXCOORD_0', 'TEXCOORD_1', 'COLOR',\n// Skinning\n// https://github.com/KhronosGroup/glTF/blob/master/specification/README.md#semantics\n'JOINT', 'WEIGHT'];\nvar uniformSemantics = ['SKIN_MATRIX',\n// Information about viewport\n'VIEWPORT_SIZE', 'VIEWPORT', 'DEVICEPIXELRATIO',\n// Window size for window relative coordinate\n// https://www.opengl.org/sdk/docs/man/html/gl_FragCoord.xhtml\n'WINDOW_SIZE',\n// Infomation about camera\n'NEAR', 'FAR',\n// Time\n'TIME'];\nvar matrixSemantics = ['WORLD', 'VIEW', 'PROJECTION', 'WORLDVIEW', 'VIEWPROJECTION', 'WORLDVIEWPROJECTION', 'WORLDINVERSE', 'VIEWINVERSE', 'PROJECTIONINVERSE', 'WORLDVIEWINVERSE', 'VIEWPROJECTIONINVERSE', 'WORLDVIEWPROJECTIONINVERSE', 'WORLDTRANSPOSE', 'VIEWTRANSPOSE', 'PROJECTIONTRANSPOSE', 'WORLDVIEWTRANSPOSE', 'VIEWPROJECTIONTRANSPOSE', 'WORLDVIEWPROJECTIONTRANSPOSE', 'WORLDINVERSETRANSPOSE', 'VIEWINVERSETRANSPOSE', 'PROJECTIONINVERSETRANSPOSE', 'WORLDVIEWINVERSETRANSPOSE', 'VIEWPROJECTIONINVERSETRANSPOSE', 'WORLDVIEWPROJECTIONINVERSETRANSPOSE'];\nvar attributeSizeMap = {\n  // WebGL does not support integer attributes\n  'vec4': 4,\n  'vec3': 3,\n  'vec2': 2,\n  'float': 1\n};\nvar shaderIDCache = {};\nvar shaderCodeCache = {};\nfunction getShaderID(vertex, fragment) {\n  var key = 'vertex:' + vertex + 'fragment:' + fragment;\n  if (shaderIDCache[key]) {\n    return shaderIDCache[key];\n  }\n  var id = util.genGUID();\n  shaderIDCache[key] = id;\n  shaderCodeCache[id] = {\n    vertex: vertex,\n    fragment: fragment\n  };\n  return id;\n}\nfunction removeComment(code) {\n  return code.replace(/[ \\t]*\\/\\/.*\\n/g, '') // remove //\n  .replace(/[ \\t]*\\/\\*[\\s\\S]*?\\*\\//g, ''); // remove /* */\n}\nfunction logSyntaxError() {\n  console.error('Wrong uniform/attributes syntax');\n}\nfunction parseDeclarations(type, line) {\n  var speratorsRegexp = /[,=\\(\\):]/;\n  var tokens = line\n  // Convert `symbol: [1,2,3]` to `symbol: vec3(1,2,3)`\n  .replace(/:\\s*\\[\\s*(.*)\\s*\\]/g, '=' + type + '($1)').replace(/\\s+/g, '').split(/(?=[,=\\(\\):])/g);\n  var newTokens = [];\n  for (var i = 0; i < tokens.length; i++) {\n    if (tokens[i].match(speratorsRegexp)) {\n      newTokens.push(tokens[i].charAt(0), tokens[i].slice(1));\n    } else {\n      newTokens.push(tokens[i]);\n    }\n  }\n  tokens = newTokens;\n  var TYPE_SYMBOL = 0;\n  var TYPE_ASSIGN = 1;\n  var TYPE_VEC = 2;\n  var TYPE_ARR = 3;\n  var TYPE_SEMANTIC = 4;\n  var TYPE_NORMAL = 5;\n  var opType = TYPE_SYMBOL;\n  var declarations = {};\n  var declarationValue = null;\n  var currentDeclaration;\n  addSymbol(tokens[0]);\n  function addSymbol(symbol) {\n    if (!symbol) {\n      logSyntaxError();\n    }\n    var arrResult = symbol.match(/\\[(.*?)\\]/);\n    currentDeclaration = symbol.replace(/\\[(.*?)\\]/, '');\n    declarations[currentDeclaration] = {};\n    if (arrResult) {\n      declarations[currentDeclaration].isArray = true;\n      declarations[currentDeclaration].arraySize = arrResult[1];\n    }\n  }\n  for (var i = 1; i < tokens.length; i++) {\n    var token = tokens[i];\n    if (!token) {\n      // Empty token;\n      continue;\n    }\n    if (token === '=') {\n      if (opType !== TYPE_SYMBOL && opType !== TYPE_ARR) {\n        logSyntaxError();\n        break;\n      }\n      opType = TYPE_ASSIGN;\n      continue;\n    } else if (token === ':') {\n      opType = TYPE_SEMANTIC;\n      continue;\n    } else if (token === ',') {\n      if (opType === TYPE_VEC) {\n        if (!(declarationValue instanceof Array)) {\n          logSyntaxError();\n          break;\n        }\n        declarationValue.push(+tokens[++i]);\n      } else {\n        opType = TYPE_NORMAL;\n      }\n      continue;\n    } else if (token === ')') {\n      declarations[currentDeclaration].value = new vendor.Float32Array(declarationValue);\n      declarationValue = null;\n      opType = TYPE_NORMAL;\n      continue;\n    } else if (token === '(') {\n      if (opType !== TYPE_VEC) {\n        logSyntaxError();\n        break;\n      }\n      if (!(declarationValue instanceof Array)) {\n        logSyntaxError();\n        break;\n      }\n      declarationValue.push(+tokens[++i]);\n      continue;\n    } else if (token.indexOf('vec') >= 0) {\n      if (opType !== TYPE_ASSIGN\n      // Compatitable with old syntax `symbol: [1,2,3]`\n      && opType !== TYPE_SEMANTIC) {\n        logSyntaxError();\n        break;\n      }\n      opType = TYPE_VEC;\n      declarationValue = [];\n      continue;\n    } else if (opType === TYPE_ASSIGN) {\n      if (type === 'bool') {\n        declarations[currentDeclaration].value = token === 'true';\n      } else {\n        declarations[currentDeclaration].value = parseFloat(token);\n      }\n      declarationValue = null;\n      continue;\n    } else if (opType === TYPE_SEMANTIC) {\n      var semantic = token;\n      if (attributeSemantics.indexOf(semantic) >= 0 || uniformSemantics.indexOf(semantic) >= 0 || matrixSemantics.indexOf(semantic) >= 0) {\n        declarations[currentDeclaration].semantic = semantic;\n      } else if (semantic === 'ignore' || semantic === 'unconfigurable') {\n        declarations[currentDeclaration].ignore = true;\n      } else {\n        // Try to parse as a default tvalue.\n        if (type === 'bool') {\n          declarations[currentDeclaration].value = semantic === 'true';\n        } else {\n          declarations[currentDeclaration].value = parseFloat(semantic);\n        }\n      }\n      continue;\n    }\n\n    // treat as symbol.\n    addSymbol(token);\n    opType = TYPE_SYMBOL;\n  }\n  return declarations;\n}\n\n/**\n * @constructor\n * @extends clay.core.Base\n * @alias clay.Shader\n * @param {string} vertex\n * @param {string} fragment\n * @example\n * // Create a phong shader\n * var shader = new clay.Shader(\n *      clay.Shader.source('clay.standard.vertex'),\n *      clay.Shader.source('clay.standard.fragment')\n * );\n */\nfunction Shader(vertex, fragment) {\n  // First argument can be { vertex, fragment }\n  if (typeof vertex === 'object') {\n    fragment = vertex.fragment;\n    vertex = vertex.vertex;\n  }\n  vertex = removeComment(vertex);\n  fragment = removeComment(fragment);\n  this._shaderID = getShaderID(vertex, fragment);\n  this._vertexCode = Shader.parseImport(vertex);\n  this._fragmentCode = Shader.parseImport(fragment);\n\n  /**\n   * @readOnly\n   */\n  this.attributeSemantics = {};\n  /**\n   * @readOnly\n   */\n  this.matrixSemantics = {};\n  /**\n   * @readOnly\n   */\n  this.uniformSemantics = {};\n  /**\n   * @readOnly\n   */\n  this.matrixSemanticKeys = [];\n  /**\n   * @readOnly\n   */\n  this.uniformTemplates = {};\n  /**\n   * @readOnly\n   */\n  this.attributes = {};\n  /**\n   * @readOnly\n   */\n  this.textures = {};\n  /**\n   * @readOnly\n   */\n  this.vertexDefines = {};\n  /**\n   * @readOnly\n   */\n  this.fragmentDefines = {};\n  this._parseAttributes();\n  this._parseUniforms();\n  this._parseDefines();\n}\nShader.prototype = {\n  constructor: Shader,\n  // Create a new uniform instance for material\n  createUniforms: function () {\n    var uniforms = {};\n    for (var symbol in this.uniformTemplates) {\n      var uniformTpl = this.uniformTemplates[symbol];\n      uniforms[symbol] = {\n        type: uniformTpl.type,\n        value: uniformTpl.value()\n      };\n    }\n    return uniforms;\n  },\n  _parseImport: function () {\n    this._vertexCode = Shader.parseImport(this.vertex);\n    this._fragmentCode = Shader.parseImport(this.fragment);\n  },\n  _addSemanticUniform: function (symbol, uniformType, semantic) {\n    // This case is only for SKIN_MATRIX\n    // TODO\n    if (attributeSemantics.indexOf(semantic) >= 0) {\n      this.attributeSemantics[semantic] = {\n        symbol: symbol,\n        type: uniformType\n      };\n    } else if (matrixSemantics.indexOf(semantic) >= 0) {\n      var isTranspose = false;\n      var semanticNoTranspose = semantic;\n      if (semantic.match(/TRANSPOSE$/)) {\n        isTranspose = true;\n        semanticNoTranspose = semantic.slice(0, -9);\n      }\n      this.matrixSemantics[semantic] = {\n        symbol: symbol,\n        type: uniformType,\n        isTranspose: isTranspose,\n        semanticNoTranspose: semanticNoTranspose\n      };\n    } else if (uniformSemantics.indexOf(semantic) >= 0) {\n      this.uniformSemantics[semantic] = {\n        symbol: symbol,\n        type: uniformType\n      };\n    }\n  },\n  _addMaterialUniform: function (symbol, type, uniformType, defaultValueFunc, isArray, materialUniforms) {\n    materialUniforms[symbol] = {\n      type: uniformType,\n      value: isArray ? uniformValueConstructor['array'] : defaultValueFunc || uniformValueConstructor[type],\n      semantic: null\n    };\n  },\n  _parseUniforms: function () {\n    var uniforms = {};\n    var self = this;\n    var shaderType = 'vertex';\n    this._uniformList = [];\n    this._vertexCode = this._vertexCode.replace(uniformRegex, _uniformParser);\n    shaderType = 'fragment';\n    this._fragmentCode = this._fragmentCode.replace(uniformRegex, _uniformParser);\n    self.matrixSemanticKeys = Object.keys(this.matrixSemantics);\n    function makeDefaultValueFunc(value) {\n      return value != null ? function () {\n        return value;\n      } : null;\n    }\n    function _uniformParser(str, type, content) {\n      var declaredUniforms = parseDeclarations(type, content);\n      var uniformMainStr = [];\n      for (var symbol in declaredUniforms) {\n        var uniformInfo = declaredUniforms[symbol];\n        var semantic = uniformInfo.semantic;\n        var tmpStr = symbol;\n        var uniformType = uniformTypeMap[type];\n        var defaultValueFunc = makeDefaultValueFunc(declaredUniforms[symbol].value);\n        if (declaredUniforms[symbol].isArray) {\n          tmpStr += '[' + declaredUniforms[symbol].arraySize + ']';\n          uniformType += 'v';\n        }\n        uniformMainStr.push(tmpStr);\n        self._uniformList.push(symbol);\n        if (!uniformInfo.ignore) {\n          if (type === 'sampler2D' || type === 'samplerCube') {\n            // Texture is default disabled\n            self.textures[symbol] = {\n              shaderType: shaderType,\n              type: type\n            };\n          }\n          if (semantic) {\n            // TODO Should not declare multiple symbols if have semantic.\n            self._addSemanticUniform(symbol, uniformType, semantic);\n          } else {\n            self._addMaterialUniform(symbol, type, uniformType, defaultValueFunc, declaredUniforms[symbol].isArray, uniforms);\n          }\n        }\n      }\n      return uniformMainStr.length > 0 ? 'uniform ' + type + ' ' + uniformMainStr.join(',') + ';\\n' : '';\n    }\n    this.uniformTemplates = uniforms;\n  },\n  _parseAttributes: function () {\n    var attributes = {};\n    var self = this;\n    this._vertexCode = this._vertexCode.replace(attributeRegex, _attributeParser);\n    function _attributeParser(str, type, content) {\n      var declaredAttributes = parseDeclarations(type, content);\n      var size = attributeSizeMap[type] || 1;\n      var attributeMainStr = [];\n      for (var symbol in declaredAttributes) {\n        var semantic = declaredAttributes[symbol].semantic;\n        attributes[symbol] = {\n          // TODO Can only be float\n          type: 'float',\n          size: size,\n          semantic: semantic || null\n        };\n        // TODO Should not declare multiple symbols if have semantic.\n        if (semantic) {\n          if (attributeSemantics.indexOf(semantic) < 0) {\n            throw new Error('Unkown semantic \"' + semantic + '\"');\n          } else {\n            self.attributeSemantics[semantic] = {\n              symbol: symbol,\n              type: type\n            };\n          }\n        }\n        attributeMainStr.push(symbol);\n      }\n      return 'attribute ' + type + ' ' + attributeMainStr.join(',') + ';\\n';\n    }\n    this.attributes = attributes;\n  },\n  _parseDefines: function () {\n    var self = this;\n    var shaderType = 'vertex';\n    this._vertexCode = this._vertexCode.replace(defineRegex, _defineParser);\n    shaderType = 'fragment';\n    this._fragmentCode = this._fragmentCode.replace(defineRegex, _defineParser);\n    function _defineParser(str, symbol, value) {\n      var defines = shaderType === 'vertex' ? self.vertexDefines : self.fragmentDefines;\n      if (!defines[symbol]) {\n        // Haven't been defined by user\n        if (value === 'false') {\n          defines[symbol] = false;\n        } else if (value === 'true') {\n          defines[symbol] = true;\n        } else {\n          defines[symbol] = value\n          // If can parse to float\n          ? isNaN(parseFloat(value)) ? value.trim() : parseFloat(value) : null;\n        }\n      }\n      return '';\n    }\n  },\n  /**\n   * Clone a new shader\n   * @return {clay.Shader}\n   */\n  clone: function () {\n    var code = shaderCodeCache[this._shaderID];\n    var shader = new Shader(code.vertex, code.fragment);\n    return shader;\n  }\n};\nif (Object.defineProperty) {\n  Object.defineProperty(Shader.prototype, 'shaderID', {\n    get: function () {\n      return this._shaderID;\n    }\n  });\n  Object.defineProperty(Shader.prototype, 'vertex', {\n    get: function () {\n      return this._vertexCode;\n    }\n  });\n  Object.defineProperty(Shader.prototype, 'fragment', {\n    get: function () {\n      return this._fragmentCode;\n    }\n  });\n  Object.defineProperty(Shader.prototype, 'uniforms', {\n    get: function () {\n      return this._uniformList;\n    }\n  });\n}\nvar importRegex = /(@import)\\s*([0-9a-zA-Z_\\-\\.]*)/g;\nShader.parseImport = function (shaderStr) {\n  shaderStr = shaderStr.replace(importRegex, function (str, importSymbol, importName) {\n    var str = Shader.source(importName);\n    if (str) {\n      // Recursively parse\n      return Shader.parseImport(str);\n    } else {\n      console.error('Shader chunk \"' + importName + '\" not existed in library');\n      return '';\n    }\n  });\n  return shaderStr;\n};\nvar exportRegex = /(@export)\\s*([0-9a-zA-Z_\\-\\.]*)\\s*\\n([\\s\\S]*?)@end/g;\n\n/**\n * Import shader source\n * @param  {string} shaderStr\n * @memberOf clay.Shader\n */\nShader['import'] = function (shaderStr) {\n  shaderStr.replace(exportRegex, function (str, exportSymbol, exportName, code) {\n    var code = code.replace(/(^[\\s\\t\\xa0\\u3000]+)|([\\u3000\\xa0\\s\\t]+\\x24)/g, '');\n    if (code) {\n      var parts = exportName.split('.');\n      var obj = Shader.codes;\n      var i = 0;\n      var key;\n      while (i < parts.length - 1) {\n        key = parts[i++];\n        if (!obj[key]) {\n          obj[key] = {};\n        }\n        obj = obj[key];\n      }\n      key = parts[i];\n      obj[key] = code;\n    }\n    return code;\n  });\n};\n\n/**\n * Library to store all the loaded shader codes\n * @type {Object}\n * @readOnly\n * @memberOf clay.Shader\n */\nShader.codes = {};\n\n/**\n * Get shader source\n * @param  {string} name\n * @return {string}\n */\nShader.source = function (name) {\n  var parts = name.split('.');\n  var obj = Shader.codes;\n  var i = 0;\n  while (obj && i < parts.length) {\n    var key = parts[i++];\n    obj = obj[key];\n  }\n  if (typeof obj !== 'string') {\n    // FIXME Use default instead\n    console.error('Shader \"' + name + '\" not existed in library');\n    return '';\n  }\n  return obj;\n};\nexport default Shader;","map":{"version":3,"names":["util","vendor","uniformRegex","attributeRegex","defineRegex","uniformTypeMap","createZeroArray","len","arr","i","uniformValueConstructor","bool","int","float","sampler2D","samplerCube","vec2","vec3","vec4","ivec2","ivec3","ivec4","mat2","mat3","mat4","array","attributeSemantics","uniformSemantics","matrixSemantics","attributeSizeMap","shaderIDCache","shaderCodeCache","getShaderID","vertex","fragment","key","id","genGUID","removeComment","code","replace","logSyntaxError","console","error","parseDeclarations","type","line","speratorsRegexp","tokens","split","newTokens","length","match","push","charAt","slice","TYPE_SYMBOL","TYPE_ASSIGN","TYPE_VEC","TYPE_ARR","TYPE_SEMANTIC","TYPE_NORMAL","opType","declarations","declarationValue","currentDeclaration","addSymbol","symbol","arrResult","isArray","arraySize","token","Array","value","Float32Array","indexOf","parseFloat","semantic","ignore","Shader","_shaderID","_vertexCode","parseImport","_fragmentCode","matrixSemanticKeys","uniformTemplates","attributes","textures","vertexDefines","fragmentDefines","_parseAttributes","_parseUniforms","_parseDefines","prototype","constructor","createUniforms","uniforms","uniformTpl","_parseImport","_addSemanticUniform","uniformType","isTranspose","semanticNoTranspose","_addMaterialUniform","defaultValueFunc","materialUniforms","self","shaderType","_uniformList","_uniformParser","Object","keys","makeDefaultValueFunc","str","content","declaredUniforms","uniformMainStr","uniformInfo","tmpStr","join","_attributeParser","declaredAttributes","size","attributeMainStr","Error","_defineParser","defines","isNaN","trim","clone","shader","defineProperty","get","importRegex","shaderStr","importSymbol","importName","source","exportRegex","exportSymbol","exportName","parts","obj","codes","name"],"sources":["E:/QuestionairePlanet_Fronted/mytest/node_modules/claygl/src/Shader.js"],"sourcesContent":["/**\n * Mainly do the parse and compile of shader string\n * Support shader code chunk import and export\n * Support shader semantics\n * http://www.nvidia.com/object/using_sas.html\n * https://github.com/KhronosGroup/collada2json/issues/45\n */\nimport util from './core/util';\nimport vendor from './core/vendor';\n\nvar uniformRegex = /uniform\\s+(bool|float|int|vec2|vec3|vec4|ivec2|ivec3|ivec4|mat2|mat3|mat4|sampler2D|samplerCube)\\s+([\\s\\S]*?);/g;\nvar attributeRegex = /attribute\\s+(float|int|vec2|vec3|vec4)\\s+([\\s\\S]*?);/g;\n// Only parse number define.\nvar defineRegex = /#define\\s+(\\w+)?(\\s+[\\d-.]+)?\\s*;?\\s*\\n/g;\n\nvar uniformTypeMap = {\n    'bool': '1i',\n    'int': '1i',\n    'sampler2D': 't',\n    'samplerCube': 't',\n    'float': '1f',\n    'vec2': '2f',\n    'vec3': '3f',\n    'vec4': '4f',\n    'ivec2': '2i',\n    'ivec3': '3i',\n    'ivec4': '4i',\n    'mat2': 'm2',\n    'mat3': 'm3',\n    'mat4': 'm4'\n};\n\nfunction createZeroArray(len) {\n    var arr = [];\n    for (var i = 0; i < len; i++) {\n        arr[i] = 0;\n    }\n    return arr;\n}\n\nvar uniformValueConstructor = {\n    'bool': function () { return true; },\n    'int': function () { return 0; },\n    'float': function () { return 0; },\n    'sampler2D': function () { return null; },\n    'samplerCube': function () { return null; },\n\n    'vec2': function () { return createZeroArray(2); },\n    'vec3': function () { return createZeroArray(3); },\n    'vec4': function () { return createZeroArray(4); },\n\n    'ivec2': function () { return createZeroArray(2); },\n    'ivec3': function () { return createZeroArray(3); },\n    'ivec4': function () { return createZeroArray(4); },\n\n    'mat2': function () { return createZeroArray(4); },\n    'mat3': function () { return createZeroArray(9); },\n    'mat4': function () { return createZeroArray(16); },\n\n    'array': function () { return []; }\n};\n\nvar attributeSemantics = [\n    'POSITION',\n    'NORMAL',\n    'BINORMAL',\n    'TANGENT',\n    'TEXCOORD',\n    'TEXCOORD_0',\n    'TEXCOORD_1',\n    'COLOR',\n    // Skinning\n    // https://github.com/KhronosGroup/glTF/blob/master/specification/README.md#semantics\n    'JOINT',\n    'WEIGHT'\n];\nvar uniformSemantics = [\n    'SKIN_MATRIX',\n    // Information about viewport\n    'VIEWPORT_SIZE',\n    'VIEWPORT',\n    'DEVICEPIXELRATIO',\n    // Window size for window relative coordinate\n    // https://www.opengl.org/sdk/docs/man/html/gl_FragCoord.xhtml\n    'WINDOW_SIZE',\n    // Infomation about camera\n    'NEAR',\n    'FAR',\n    // Time\n    'TIME'\n];\nvar matrixSemantics = [\n    'WORLD',\n    'VIEW',\n    'PROJECTION',\n    'WORLDVIEW',\n    'VIEWPROJECTION',\n    'WORLDVIEWPROJECTION',\n    'WORLDINVERSE',\n    'VIEWINVERSE',\n    'PROJECTIONINVERSE',\n    'WORLDVIEWINVERSE',\n    'VIEWPROJECTIONINVERSE',\n    'WORLDVIEWPROJECTIONINVERSE',\n    'WORLDTRANSPOSE',\n    'VIEWTRANSPOSE',\n    'PROJECTIONTRANSPOSE',\n    'WORLDVIEWTRANSPOSE',\n    'VIEWPROJECTIONTRANSPOSE',\n    'WORLDVIEWPROJECTIONTRANSPOSE',\n    'WORLDINVERSETRANSPOSE',\n    'VIEWINVERSETRANSPOSE',\n    'PROJECTIONINVERSETRANSPOSE',\n    'WORLDVIEWINVERSETRANSPOSE',\n    'VIEWPROJECTIONINVERSETRANSPOSE',\n    'WORLDVIEWPROJECTIONINVERSETRANSPOSE'\n];\n\nvar attributeSizeMap = {\n    // WebGL does not support integer attributes\n    'vec4': 4,\n    'vec3': 3,\n    'vec2': 2,\n    'float': 1\n};\n\n\nvar shaderIDCache = {};\nvar shaderCodeCache = {};\n\nfunction getShaderID(vertex, fragment) {\n    var key = 'vertex:' + vertex + 'fragment:' + fragment;\n    if (shaderIDCache[key]) {\n        return shaderIDCache[key];\n    }\n    var id = util.genGUID();\n    shaderIDCache[key] = id;\n\n    shaderCodeCache[id] = {\n        vertex: vertex,\n        fragment: fragment\n    };\n\n    return id;\n}\n\nfunction removeComment(code) {\n    return code.replace(/[ \\t]*\\/\\/.*\\n/g, '' )   // remove //\n        .replace(/[ \\t]*\\/\\*[\\s\\S]*?\\*\\//g, '' ); // remove /* */\n}\n\nfunction logSyntaxError() {\n    console.error('Wrong uniform/attributes syntax');\n}\n\nfunction parseDeclarations(type, line) {\n    var speratorsRegexp = /[,=\\(\\):]/;\n    var tokens = line\n        // Convert `symbol: [1,2,3]` to `symbol: vec3(1,2,3)`\n        .replace(/:\\s*\\[\\s*(.*)\\s*\\]/g, '=' + type + '($1)')\n        .replace(/\\s+/g, '')\n        .split(/(?=[,=\\(\\):])/g);\n\n    var newTokens = [];\n    for (var i = 0; i < tokens.length; i++) {\n        if (tokens[i].match(speratorsRegexp)) {\n            newTokens.push(\n                tokens[i].charAt(0),\n                tokens[i].slice(1)\n            );\n        }\n        else {\n            newTokens.push(tokens[i]);\n        }\n    }\n    tokens = newTokens;\n\n    var TYPE_SYMBOL = 0;\n    var TYPE_ASSIGN = 1;\n    var TYPE_VEC = 2;\n    var TYPE_ARR = 3;\n    var TYPE_SEMANTIC = 4;\n    var TYPE_NORMAL = 5;\n\n    var opType = TYPE_SYMBOL;\n    var declarations = {};\n    var declarationValue = null;\n    var currentDeclaration;\n\n    addSymbol(tokens[0]);\n\n    function addSymbol(symbol) {\n        if (!symbol) {\n            logSyntaxError();\n        }\n        var arrResult = symbol.match(/\\[(.*?)\\]/);\n        currentDeclaration = symbol.replace(/\\[(.*?)\\]/, '');\n        declarations[currentDeclaration] = {};\n        if (arrResult) {\n            declarations[currentDeclaration].isArray = true;\n            declarations[currentDeclaration].arraySize = arrResult[1];\n        }\n    }\n\n    for (var i = 1; i < tokens.length; i++) {\n        var token = tokens[i];\n        if (!token) {   // Empty token;\n            continue;\n        }\n        if (token === '=') {\n            if (opType !== TYPE_SYMBOL\n            && opType !== TYPE_ARR) {\n                logSyntaxError();\n                break;\n            }\n            opType = TYPE_ASSIGN;\n\n            continue;\n        }\n        else if (token === ':') {\n            opType = TYPE_SEMANTIC;\n\n            continue;\n        }\n        else if (token === ',') {\n            if (opType === TYPE_VEC) {\n                if (!(declarationValue instanceof Array)) {\n                    logSyntaxError();\n                    break;\n                }\n                declarationValue.push(+tokens[++i]);\n            }\n            else {\n                opType = TYPE_NORMAL;\n            }\n\n            continue;\n        }\n        else if (token === ')') {\n            declarations[currentDeclaration].value = new vendor.Float32Array(declarationValue);\n            declarationValue = null;\n            opType = TYPE_NORMAL;\n            continue;\n        }\n        else if (token === '(') {\n            if (opType !== TYPE_VEC) {\n                logSyntaxError();\n                break;\n            }\n            if (!(declarationValue instanceof Array)) {\n                logSyntaxError();\n                break;\n            }\n            declarationValue.push(+tokens[++i]);\n            continue;\n        }\n        else if (token.indexOf('vec') >= 0) {\n            if (opType !== TYPE_ASSIGN\n            // Compatitable with old syntax `symbol: [1,2,3]`\n            && opType !== TYPE_SEMANTIC) {\n                logSyntaxError();\n                break;\n            }\n            opType = TYPE_VEC;\n            declarationValue = [];\n            continue;\n        }\n        else if (opType === TYPE_ASSIGN) {\n            if (type === 'bool') {\n                declarations[currentDeclaration].value = token === 'true';\n            }\n            else {\n                declarations[currentDeclaration].value = parseFloat(token);\n            }\n            declarationValue = null;\n            continue;\n        }\n        else if (opType === TYPE_SEMANTIC) {\n            var semantic = token;\n            if (attributeSemantics.indexOf(semantic) >= 0\n                || uniformSemantics.indexOf(semantic) >= 0\n                || matrixSemantics.indexOf(semantic) >= 0\n            ) {\n                declarations[currentDeclaration].semantic = semantic;\n            }\n            else if (semantic === 'ignore' || semantic === 'unconfigurable') {\n                declarations[currentDeclaration].ignore = true;\n            }\n            else {\n                // Try to parse as a default tvalue.\n                if (type === 'bool') {\n                    declarations[currentDeclaration].value = semantic === 'true';\n                }\n                else {\n                    declarations[currentDeclaration].value = parseFloat(semantic);\n                }\n            }\n            continue;\n        }\n\n        // treat as symbol.\n        addSymbol(token);\n        opType = TYPE_SYMBOL;\n    }\n\n    return declarations;\n}\n\n\n/**\n * @constructor\n * @extends clay.core.Base\n * @alias clay.Shader\n * @param {string} vertex\n * @param {string} fragment\n * @example\n * // Create a phong shader\n * var shader = new clay.Shader(\n *      clay.Shader.source('clay.standard.vertex'),\n *      clay.Shader.source('clay.standard.fragment')\n * );\n */\nfunction Shader(vertex, fragment) {\n    // First argument can be { vertex, fragment }\n    if (typeof vertex === 'object') {\n        fragment = vertex.fragment;\n        vertex = vertex.vertex;\n    }\n\n    vertex = removeComment(vertex);\n    fragment = removeComment(fragment);\n\n    this._shaderID = getShaderID(vertex, fragment);\n\n    this._vertexCode = Shader.parseImport(vertex);\n    this._fragmentCode = Shader.parseImport(fragment);\n\n    /**\n     * @readOnly\n     */\n    this.attributeSemantics = {};\n    /**\n     * @readOnly\n     */\n    this.matrixSemantics = {};\n    /**\n     * @readOnly\n     */\n    this.uniformSemantics = {};\n    /**\n     * @readOnly\n     */\n    this.matrixSemanticKeys = [];\n    /**\n     * @readOnly\n     */\n    this.uniformTemplates = {};\n    /**\n     * @readOnly\n     */\n    this.attributes = {};\n    /**\n     * @readOnly\n     */\n    this.textures = {};\n    /**\n     * @readOnly\n     */\n    this.vertexDefines = {};\n    /**\n     * @readOnly\n     */\n    this.fragmentDefines = {};\n\n    this._parseAttributes();\n    this._parseUniforms();\n    this._parseDefines();\n}\n\nShader.prototype = {\n\n    constructor: Shader,\n\n    // Create a new uniform instance for material\n    createUniforms: function () {\n        var uniforms = {};\n\n        for (var symbol in this.uniformTemplates){\n            var uniformTpl = this.uniformTemplates[symbol];\n            uniforms[symbol] = {\n                type: uniformTpl.type,\n                value: uniformTpl.value()\n            };\n        }\n\n        return uniforms;\n    },\n\n    _parseImport: function () {\n        this._vertexCode = Shader.parseImport(this.vertex);\n        this._fragmentCode = Shader.parseImport(this.fragment);\n    },\n\n    _addSemanticUniform: function (symbol, uniformType, semantic) {\n        // This case is only for SKIN_MATRIX\n        // TODO\n        if (attributeSemantics.indexOf(semantic) >= 0) {\n            this.attributeSemantics[semantic] = {\n                symbol: symbol,\n                type: uniformType\n            };\n        }\n        else if (matrixSemantics.indexOf(semantic) >= 0) {\n            var isTranspose = false;\n            var semanticNoTranspose = semantic;\n            if (semantic.match(/TRANSPOSE$/)) {\n                isTranspose = true;\n                semanticNoTranspose = semantic.slice(0, -9);\n            }\n            this.matrixSemantics[semantic] = {\n                symbol: symbol,\n                type: uniformType,\n                isTranspose: isTranspose,\n                semanticNoTranspose: semanticNoTranspose\n            };\n        }\n        else if (uniformSemantics.indexOf(semantic) >= 0) {\n            this.uniformSemantics[semantic] = {\n                symbol: symbol,\n                type: uniformType\n            };\n        }\n    },\n\n    _addMaterialUniform: function (symbol, type, uniformType, defaultValueFunc, isArray, materialUniforms) {\n        materialUniforms[symbol] = {\n            type: uniformType,\n            value: isArray ? uniformValueConstructor['array'] : (defaultValueFunc || uniformValueConstructor[type]),\n            semantic: null\n        };\n    },\n\n    _parseUniforms: function () {\n        var uniforms = {};\n        var self = this;\n        var shaderType = 'vertex';\n        this._uniformList = [];\n\n        this._vertexCode = this._vertexCode.replace(uniformRegex, _uniformParser);\n        shaderType = 'fragment';\n        this._fragmentCode = this._fragmentCode.replace(uniformRegex, _uniformParser);\n\n        self.matrixSemanticKeys = Object.keys(this.matrixSemantics);\n\n        function makeDefaultValueFunc(value) {\n            return value != null ? function () { return value; } : null;\n        }\n\n        function _uniformParser(str, type, content) {\n            var declaredUniforms = parseDeclarations(type, content);\n            var uniformMainStr = [];\n            for (var symbol in declaredUniforms) {\n\n                var uniformInfo = declaredUniforms[symbol];\n                var semantic = uniformInfo.semantic;\n                var tmpStr = symbol;\n                var uniformType = uniformTypeMap[type];\n                var defaultValueFunc = makeDefaultValueFunc(declaredUniforms[symbol].value);\n                if (declaredUniforms[symbol].isArray) {\n                    tmpStr += '[' + declaredUniforms[symbol].arraySize + ']';\n                    uniformType += 'v';\n                }\n\n                uniformMainStr.push(tmpStr);\n\n                self._uniformList.push(symbol);\n\n                if (!uniformInfo.ignore) {\n                    if (type === 'sampler2D' || type === 'samplerCube') {\n                        // Texture is default disabled\n                        self.textures[symbol] = {\n                            shaderType: shaderType,\n                            type: type\n                        };\n                    }\n\n                    if (semantic) {\n                        // TODO Should not declare multiple symbols if have semantic.\n                        self._addSemanticUniform(symbol, uniformType, semantic);\n                    }\n                    else {\n                        self._addMaterialUniform(\n                            symbol, type, uniformType, defaultValueFunc,\n                            declaredUniforms[symbol].isArray, uniforms\n                        );\n                    }\n                }\n            }\n            return uniformMainStr.length > 0\n                ? 'uniform ' + type + ' ' + uniformMainStr.join(',') + ';\\n' : '';\n        }\n\n        this.uniformTemplates = uniforms;\n    },\n\n    _parseAttributes: function () {\n        var attributes = {};\n        var self = this;\n        this._vertexCode = this._vertexCode.replace(attributeRegex, _attributeParser);\n\n        function _attributeParser(str, type, content) {\n            var declaredAttributes = parseDeclarations(type, content);\n\n            var size = attributeSizeMap[type] || 1;\n            var attributeMainStr = [];\n            for (var symbol in declaredAttributes) {\n                var semantic = declaredAttributes[symbol].semantic;\n                attributes[symbol] = {\n                    // TODO Can only be float\n                    type: 'float',\n                    size: size,\n                    semantic: semantic || null\n                };\n                // TODO Should not declare multiple symbols if have semantic.\n                if (semantic) {\n                    if (attributeSemantics.indexOf(semantic) < 0) {\n                        throw new Error('Unkown semantic \"' + semantic + '\"');\n                    }\n                    else {\n                        self.attributeSemantics[semantic] = {\n                            symbol: symbol,\n                            type: type\n                        };\n                    }\n                }\n                attributeMainStr.push(symbol);\n            }\n\n            return 'attribute ' + type + ' ' + attributeMainStr.join(',') + ';\\n';\n        }\n\n        this.attributes = attributes;\n    },\n\n    _parseDefines: function () {\n        var self = this;\n        var shaderType = 'vertex';\n        this._vertexCode = this._vertexCode.replace(defineRegex, _defineParser);\n        shaderType = 'fragment';\n        this._fragmentCode = this._fragmentCode.replace(defineRegex, _defineParser);\n\n        function _defineParser(str, symbol, value) {\n            var defines = shaderType === 'vertex' ? self.vertexDefines : self.fragmentDefines;\n            if (!defines[symbol]) { // Haven't been defined by user\n                if (value === 'false') {\n                    defines[symbol] = false;\n                }\n                else if (value === 'true') {\n                    defines[symbol] = true;\n                }\n                else {\n                    defines[symbol] = value\n                        // If can parse to float\n                        ? (isNaN(parseFloat(value)) ? value.trim() : parseFloat(value))\n                        : null;\n                }\n            }\n            return '';\n        }\n    },\n\n    /**\n     * Clone a new shader\n     * @return {clay.Shader}\n     */\n    clone: function () {\n        var code = shaderCodeCache[this._shaderID];\n        var shader = new Shader(code.vertex, code.fragment);\n        return shader;\n    }\n};\n\nif (Object.defineProperty) {\n    Object.defineProperty(Shader.prototype, 'shaderID', {\n        get: function () {\n            return this._shaderID;\n        }\n    });\n    Object.defineProperty(Shader.prototype, 'vertex', {\n        get: function () {\n            return this._vertexCode;\n        }\n    });\n    Object.defineProperty(Shader.prototype, 'fragment', {\n        get: function () {\n            return this._fragmentCode;\n        }\n    });\n    Object.defineProperty(Shader.prototype, 'uniforms', {\n        get: function () {\n            return this._uniformList;\n        }\n    });\n}\n\nvar importRegex = /(@import)\\s*([0-9a-zA-Z_\\-\\.]*)/g;\nShader.parseImport = function (shaderStr) {\n    shaderStr = shaderStr.replace(importRegex, function (str, importSymbol, importName) {\n        var str = Shader.source(importName);\n        if (str) {\n            // Recursively parse\n            return Shader.parseImport(str);\n        }\n        else {\n            console.error('Shader chunk \"' + importName + '\" not existed in library');\n            return '';\n        }\n    });\n    return shaderStr;\n};\n\nvar exportRegex = /(@export)\\s*([0-9a-zA-Z_\\-\\.]*)\\s*\\n([\\s\\S]*?)@end/g;\n\n/**\n * Import shader source\n * @param  {string} shaderStr\n * @memberOf clay.Shader\n */\nShader['import'] = function (shaderStr) {\n    shaderStr.replace(exportRegex, function (str, exportSymbol, exportName, code) {\n        var code = code.replace(/(^[\\s\\t\\xa0\\u3000]+)|([\\u3000\\xa0\\s\\t]+\\x24)/g, '');\n        if (code) {\n            var parts = exportName.split('.');\n            var obj = Shader.codes;\n            var i = 0;\n            var key;\n            while (i < parts.length - 1) {\n                key = parts[i++];\n                if (!obj[key]) {\n                    obj[key] = {};\n                }\n                obj = obj[key];\n            }\n            key = parts[i];\n            obj[key] = code;\n        }\n        return code;\n    });\n};\n\n/**\n * Library to store all the loaded shader codes\n * @type {Object}\n * @readOnly\n * @memberOf clay.Shader\n */\nShader.codes = {};\n\n/**\n * Get shader source\n * @param  {string} name\n * @return {string}\n */\nShader.source = function (name) {\n    var parts = name.split('.');\n    var obj = Shader.codes;\n    var i = 0;\n    while (obj && i < parts.length) {\n        var key = parts[i++];\n        obj = obj[key];\n    }\n    if (typeof obj !== 'string') {\n        // FIXME Use default instead\n        console.error('Shader \"' + name + '\" not existed in library');\n        return '';\n    }\n    return obj;\n};\n\nexport default Shader;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}