{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Node from './Node';\nimport Light from './Light';\nimport Camera from './Camera';\nimport BoundingBox from './math/BoundingBox';\nimport util from './core/util';\nimport mat4 from './glmatrix/mat4';\nimport LRUCache from './core/LRU';\nimport Matrix4 from './math/Matrix4';\nvar IDENTITY = mat4.create();\nvar WORLDVIEW = mat4.create();\nvar programKeyCache = {};\nfunction getProgramKey(lightNumbers) {\n  var defineStr = [];\n  var lightTypes = Object.keys(lightNumbers);\n  lightTypes.sort();\n  for (var i = 0; i < lightTypes.length; i++) {\n    var lightType = lightTypes[i];\n    defineStr.push(lightType + ' ' + lightNumbers[lightType]);\n  }\n  var key = defineStr.join('\\n');\n  if (programKeyCache[key]) {\n    return programKeyCache[key];\n  }\n  var id = util.genGUID();\n  programKeyCache[key] = id;\n  return id;\n}\nfunction RenderList() {\n  this.opaque = [];\n  this.transparent = [];\n  this._opaqueCount = 0;\n  this._transparentCount = 0;\n}\nRenderList.prototype.startCount = function () {\n  this._opaqueCount = 0;\n  this._transparentCount = 0;\n};\nRenderList.prototype.add = function (object, isTransparent) {\n  if (isTransparent) {\n    this.transparent[this._transparentCount++] = object;\n  } else {\n    this.opaque[this._opaqueCount++] = object;\n  }\n};\nRenderList.prototype.endCount = function () {\n  this.transparent.length = this._transparentCount;\n  this.opaque.length = this._opaqueCount;\n};\n\n/**\n * @typedef {Object} clay.Scene.RenderList\n * @property {Array.<clay.Renderable>} opaque\n * @property {Array.<clay.Renderable>} transparent\n */\n\n/**\n * @constructor clay.Scene\n * @extends clay.Node\n */\nvar Scene = Node.extend(function () {\n  return /** @lends clay.Scene# */{\n    /**\n     * Global material of scene\n     * @type {clay.Material}\n     */\n    material: null,\n    lights: [],\n    /**\n     * Scene bounding box in view space.\n     * Used when camera needs to adujst the near and far plane automatically\n     * so that the view frustum contains the visible objects as tightly as possible.\n     * Notice:\n     *  It is updated after rendering (in the step of frustum culling passingly). So may be not so accurate, but saves a lot of calculation\n     *\n     * @type {clay.BoundingBox}\n     */\n    viewBoundingBoxLastFrame: new BoundingBox(),\n    // Uniforms for shadow map.\n    shadowUniforms: {},\n    _cameraList: [],\n    // Properties to save the light information in the scene\n    // Will be set in the render function\n    _lightUniforms: {},\n    _previousLightNumber: {},\n    _lightNumber: {\n      // groupId: {\n      // POINT_LIGHT: 0,\n      // DIRECTIONAL_LIGHT: 0,\n      // SPOT_LIGHT: 0,\n      // AMBIENT_LIGHT: 0,\n      // AMBIENT_SH_LIGHT: 0\n      // }\n    },\n    _lightProgramKeys: {},\n    _nodeRepository: {},\n    _renderLists: new LRUCache(20)\n  };\n}, function () {\n  this._scene = this;\n}, /** @lends clay.Scene.prototype. */\n{\n  // Add node to scene\n  addToScene: function (node) {\n    if (node instanceof Camera) {\n      if (this._cameraList.length > 0) {\n        console.warn('Found multiple camera in one scene. Use the fist one.');\n      }\n      this._cameraList.push(node);\n    } else if (node instanceof Light) {\n      this.lights.push(node);\n    }\n    if (node.name) {\n      this._nodeRepository[node.name] = node;\n    }\n  },\n  // Remove node from scene\n  removeFromScene: function (node) {\n    var idx;\n    if (node instanceof Camera) {\n      idx = this._cameraList.indexOf(node);\n      if (idx >= 0) {\n        this._cameraList.splice(idx, 1);\n      }\n    } else if (node instanceof Light) {\n      idx = this.lights.indexOf(node);\n      if (idx >= 0) {\n        this.lights.splice(idx, 1);\n      }\n    }\n    if (node.name) {\n      delete this._nodeRepository[node.name];\n    }\n  },\n  /**\n   * Get node by name\n   * @param  {string} name\n   * @return {Node}\n   * @DEPRECATED\n   */\n  getNode: function (name) {\n    return this._nodeRepository[name];\n  },\n  /**\n   * Set main camera of the scene.\n   * @param {claygl.Camera} camera\n   */\n  setMainCamera: function (camera) {\n    var idx = this._cameraList.indexOf(camera);\n    if (idx >= 0) {\n      this._cameraList.splice(idx, 1);\n    }\n    this._cameraList.unshift(camera);\n  },\n  /**\n   * Get main camera of the scene.\n   */\n  getMainCamera: function () {\n    return this._cameraList[0];\n  },\n  getLights: function () {\n    return this.lights;\n  },\n  updateLights: function () {\n    var lights = this.lights;\n    this._previousLightNumber = this._lightNumber;\n    var lightNumber = {};\n    for (var i = 0; i < lights.length; i++) {\n      var light = lights[i];\n      if (light.invisible) {\n        continue;\n      }\n      var group = light.group;\n      if (!lightNumber[group]) {\n        lightNumber[group] = {};\n      }\n      // User can use any type of light\n      lightNumber[group][light.type] = lightNumber[group][light.type] || 0;\n      lightNumber[group][light.type]++;\n    }\n    this._lightNumber = lightNumber;\n    for (var groupId in lightNumber) {\n      this._lightProgramKeys[groupId] = getProgramKey(lightNumber[groupId]);\n    }\n    this._updateLightUniforms();\n  },\n  /**\n   * Clone a node and it's children, including mesh, camera, light, etc.\n   * Unlike using `Node#clone`. It will clone skeleton and remap the joints. Material will also be cloned.\n   *\n   * @param {clay.Node} node\n   * @return {clay.Node}\n   */\n  cloneNode: function (node) {\n    var newNode = node.clone();\n    var clonedNodesMap = {};\n    function buildNodesMap(sNode, tNode) {\n      clonedNodesMap[sNode.__uid__] = tNode;\n      for (var i = 0; i < sNode._children.length; i++) {\n        var sChild = sNode._children[i];\n        var tChild = tNode._children[i];\n        buildNodesMap(sChild, tChild);\n      }\n    }\n    buildNodesMap(node, newNode);\n    newNode.traverse(function (newChild) {\n      if (newChild.skeleton) {\n        newChild.skeleton = newChild.skeleton.clone(clonedNodesMap);\n      }\n      if (newChild.material) {\n        newChild.material = newChild.material.clone();\n      }\n    });\n    return newNode;\n  },\n  /**\n   * Traverse the scene and add the renderable object to the render list.\n   * It needs camera for the frustum culling.\n   *\n   * @param {clay.Camera} camera\n   * @param {boolean} updateSceneBoundingBox\n   * @return {clay.Scene.RenderList}\n   */\n  updateRenderList: function (camera, updateSceneBoundingBox) {\n    var id = camera.__uid__;\n    var renderList = this._renderLists.get(id);\n    if (!renderList) {\n      renderList = new RenderList();\n      this._renderLists.put(id, renderList);\n    }\n    renderList.startCount();\n    if (updateSceneBoundingBox) {\n      this.viewBoundingBoxLastFrame.min.set(Infinity, Infinity, Infinity);\n      this.viewBoundingBoxLastFrame.max.set(-Infinity, -Infinity, -Infinity);\n    }\n    var sceneMaterialTransparent = this.material && this.material.transparent || false;\n    this._doUpdateRenderList(this, camera, sceneMaterialTransparent, renderList, updateSceneBoundingBox);\n    renderList.endCount();\n    return renderList;\n  },\n  /**\n   * Get render list. Used after {@link clay.Scene#updateRenderList}\n   * @param {clay.Camera} camera\n   * @return {clay.Scene.RenderList}\n   */\n  getRenderList: function (camera) {\n    return this._renderLists.get(camera.__uid__);\n  },\n  _doUpdateRenderList: function (parent, camera, sceneMaterialTransparent, renderList, updateSceneBoundingBox) {\n    if (parent.invisible) {\n      return;\n    }\n    // TODO Optimize\n    for (var i = 0; i < parent._children.length; i++) {\n      var child = parent._children[i];\n      if (child.isRenderable()) {\n        // Frustum culling\n        var worldM = child.isSkinnedMesh() ? IDENTITY : child.worldTransform.array;\n        var geometry = child.geometry;\n        mat4.multiplyAffine(WORLDVIEW, camera.viewMatrix.array, worldM);\n        if (updateSceneBoundingBox && !geometry.boundingBox || !this.isFrustumCulled(child, camera, WORLDVIEW)) {\n          renderList.add(child, child.material.transparent || sceneMaterialTransparent);\n        }\n      }\n      if (child._children.length > 0) {\n        this._doUpdateRenderList(child, camera, sceneMaterialTransparent, renderList, updateSceneBoundingBox);\n      }\n    }\n  },\n  /**\n   * If an scene object is culled by camera frustum\n   *\n   * Object can be a renderable or a light\n   *\n   * @param {clay.Node} object\n   * @param {clay.Camera} camera\n   * @param {Array.<number>} worldViewMat represented with array\n   * @param {Array.<number>} projectionMat represented with array\n   */\n  isFrustumCulled: function () {\n    // Frustum culling\n    // http://www.cse.chalmers.se/~uffe/vfc_bbox.pdf\n    var cullingBoundingBox = new BoundingBox();\n    var cullingMatrix = new Matrix4();\n    return function (object, camera, worldViewMat) {\n      // Bounding box can be a property of object(like light) or renderable.geometry\n      // PENDING\n      var geoBBox = object.boundingBox;\n      if (!geoBBox) {\n        if (object.skeleton && object.skeleton.boundingBox) {\n          geoBBox = object.skeleton.boundingBox;\n        } else {\n          geoBBox = object.geometry.boundingBox;\n        }\n      }\n      if (!geoBBox) {\n        return false;\n      }\n      cullingMatrix.array = worldViewMat;\n      cullingBoundingBox.transformFrom(geoBBox, cullingMatrix);\n\n      // Passingly update the scene bounding box\n      // FIXME exclude very large mesh like ground plane or terrain ?\n      // FIXME Only rendererable which cast shadow ?\n\n      // FIXME boundingBox becomes much larger after transformd.\n      if (object.castShadow) {\n        this.viewBoundingBoxLastFrame.union(cullingBoundingBox);\n      }\n      // Ignore frustum culling if object is skinned mesh.\n      if (object.frustumCulling) {\n        if (!cullingBoundingBox.intersectBoundingBox(camera.frustum.boundingBox)) {\n          return true;\n        }\n        cullingMatrix.array = camera.projectionMatrix.array;\n        if (cullingBoundingBox.max.array[2] > 0 && cullingBoundingBox.min.array[2] < 0) {\n          // Clip in the near plane\n          cullingBoundingBox.max.array[2] = -1e-20;\n        }\n        cullingBoundingBox.applyProjection(cullingMatrix);\n        var min = cullingBoundingBox.min.array;\n        var max = cullingBoundingBox.max.array;\n        if (max[0] < -1 || min[0] > 1 || max[1] < -1 || min[1] > 1 || max[2] < -1 || min[2] > 1) {\n          return true;\n        }\n      }\n      return false;\n    };\n  }(),\n  _updateLightUniforms: function () {\n    var lights = this.lights;\n    // Put the light cast shadow before the light not cast shadow\n    lights.sort(lightSortFunc);\n    var lightUniforms = this._lightUniforms;\n    for (var group in lightUniforms) {\n      for (var symbol in lightUniforms[group]) {\n        lightUniforms[group][symbol].value.length = 0;\n      }\n    }\n    for (var i = 0; i < lights.length; i++) {\n      var light = lights[i];\n      if (light.invisible) {\n        continue;\n      }\n      var group = light.group;\n      for (var symbol in light.uniformTemplates) {\n        var uniformTpl = light.uniformTemplates[symbol];\n        var value = uniformTpl.value(light);\n        if (value == null) {\n          continue;\n        }\n        if (!lightUniforms[group]) {\n          lightUniforms[group] = {};\n        }\n        if (!lightUniforms[group][symbol]) {\n          lightUniforms[group][symbol] = {\n            type: '',\n            value: []\n          };\n        }\n        var lu = lightUniforms[group][symbol];\n        lu.type = uniformTpl.type + 'v';\n        switch (uniformTpl.type) {\n          case '1i':\n          case '1f':\n          case 't':\n            lu.value.push(value);\n            break;\n          case '2f':\n          case '3f':\n          case '4f':\n            for (var j = 0; j < value.length; j++) {\n              lu.value.push(value[j]);\n            }\n            break;\n          default:\n            console.error('Unkown light uniform type ' + uniformTpl.type);\n        }\n      }\n    }\n  },\n  getLightGroups: function () {\n    var lightGroups = [];\n    for (var groupId in this._lightNumber) {\n      lightGroups.push(groupId);\n    }\n    return lightGroups;\n  },\n  getNumberChangedLightGroups: function () {\n    var lightGroups = [];\n    for (var groupId in this._lightNumber) {\n      if (this.isLightNumberChanged(groupId)) {\n        lightGroups.push(groupId);\n      }\n    }\n    return lightGroups;\n  },\n  // Determine if light group is different with since last frame\n  // Used to determine whether to update shader and scene's uniforms in Renderer.render\n  isLightNumberChanged: function (lightGroup) {\n    var prevLightNumber = this._previousLightNumber;\n    var currentLightNumber = this._lightNumber;\n    // PENDING Performance\n    for (var type in currentLightNumber[lightGroup]) {\n      if (!prevLightNumber[lightGroup]) {\n        return true;\n      }\n      if (currentLightNumber[lightGroup][type] !== prevLightNumber[lightGroup][type]) {\n        return true;\n      }\n    }\n    for (var type in prevLightNumber[lightGroup]) {\n      if (!currentLightNumber[lightGroup]) {\n        return true;\n      }\n      if (currentLightNumber[lightGroup][type] !== prevLightNumber[lightGroup][type]) {\n        return true;\n      }\n    }\n    return false;\n  },\n  getLightsNumbers: function (lightGroup) {\n    return this._lightNumber[lightGroup];\n  },\n  getProgramKey: function (lightGroup) {\n    return this._lightProgramKeys[lightGroup];\n  },\n  setLightUniforms: function () {\n    function setUniforms(uniforms, program, renderer) {\n      for (var symbol in uniforms) {\n        var lu = uniforms[symbol];\n        if (lu.type === 'tv') {\n          if (!program.hasUniform(symbol)) {\n            continue;\n          }\n          var texSlots = [];\n          for (var i = 0; i < lu.value.length; i++) {\n            var texture = lu.value[i];\n            var slot = program.takeCurrentTextureSlot(renderer, texture);\n            texSlots.push(slot);\n          }\n          program.setUniform(renderer.gl, '1iv', symbol, texSlots);\n        } else {\n          program.setUniform(renderer.gl, lu.type, symbol, lu.value);\n        }\n      }\n    }\n    return function (program, lightGroup, renderer) {\n      setUniforms(this._lightUniforms[lightGroup], program, renderer);\n      // Set shadows\n      setUniforms(this.shadowUniforms, program, renderer);\n    };\n  }(),\n  /**\n   * Dispose self, clear all the scene objects\n   * But resources of gl like texuture, shader will not be disposed.\n   * Mostly you should use disposeScene method in Renderer to do dispose.\n   */\n  dispose: function () {\n    this.material = null;\n    this._opaqueList = [];\n    this._transparentList = [];\n    this.lights = [];\n    this._lightUniforms = {};\n    this._lightNumber = {};\n    this._nodeRepository = {};\n  }\n});\nfunction lightSortFunc(a, b) {\n  if (b.castShadow && !a.castShadow) {\n    return true;\n  }\n}\nexport default Scene;","map":{"version":3,"names":["Node","Light","Camera","BoundingBox","util","mat4","LRUCache","Matrix4","IDENTITY","create","WORLDVIEW","programKeyCache","getProgramKey","lightNumbers","defineStr","lightTypes","Object","keys","sort","i","length","lightType","push","key","join","id","genGUID","RenderList","opaque","transparent","_opaqueCount","_transparentCount","prototype","startCount","add","object","isTransparent","endCount","Scene","extend","material","lights","viewBoundingBoxLastFrame","shadowUniforms","_cameraList","_lightUniforms","_previousLightNumber","_lightNumber","_lightProgramKeys","_nodeRepository","_renderLists","_scene","addToScene","node","console","warn","name","removeFromScene","idx","indexOf","splice","getNode","setMainCamera","camera","unshift","getMainCamera","getLights","updateLights","lightNumber","light","invisible","group","type","groupId","_updateLightUniforms","cloneNode","newNode","clone","clonedNodesMap","buildNodesMap","sNode","tNode","__uid__","_children","sChild","tChild","traverse","newChild","skeleton","updateRenderList","updateSceneBoundingBox","renderList","get","put","min","set","Infinity","max","sceneMaterialTransparent","_doUpdateRenderList","getRenderList","parent","child","isRenderable","worldM","isSkinnedMesh","worldTransform","array","geometry","multiplyAffine","viewMatrix","boundingBox","isFrustumCulled","cullingBoundingBox","cullingMatrix","worldViewMat","geoBBox","transformFrom","castShadow","union","frustumCulling","intersectBoundingBox","frustum","projectionMatrix","applyProjection","lightSortFunc","lightUniforms","symbol","value","uniformTemplates","uniformTpl","lu","j","error","getLightGroups","lightGroups","getNumberChangedLightGroups","isLightNumberChanged","lightGroup","prevLightNumber","currentLightNumber","getLightsNumbers","setLightUniforms","setUniforms","uniforms","program","renderer","hasUniform","texSlots","texture","slot","takeCurrentTextureSlot","setUniform","gl","dispose","_opaqueList","_transparentList","a","b"],"sources":["E:/QuestionairePlanet_Fronted/mytest/node_modules/claygl/src/Scene.js"],"sourcesContent":["import Node from './Node';\nimport Light from './Light';\nimport Camera from './Camera';\nimport BoundingBox from './math/BoundingBox';\nimport util from './core/util';\nimport mat4 from './glmatrix/mat4';\nimport LRUCache from './core/LRU';\nimport Matrix4 from './math/Matrix4';\n\nvar IDENTITY = mat4.create();\nvar WORLDVIEW = mat4.create();\n\nvar programKeyCache = {};\n\nfunction getProgramKey(lightNumbers) {\n    var defineStr = [];\n    var lightTypes = Object.keys(lightNumbers);\n    lightTypes.sort();\n    for (var i = 0; i < lightTypes.length; i++) {\n        var lightType = lightTypes[i];\n        defineStr.push(lightType + ' ' + lightNumbers[lightType]);\n    }\n    var key = defineStr.join('\\n');\n\n    if (programKeyCache[key]) {\n        return programKeyCache[key];\n    }\n\n    var id = util.genGUID();\n    programKeyCache[key] = id;\n    return id;\n}\n\nfunction RenderList() {\n\n    this.opaque = [];\n    this.transparent = [];\n\n    this._opaqueCount = 0;\n    this._transparentCount = 0;\n}\n\nRenderList.prototype.startCount = function () {\n    this._opaqueCount = 0;\n    this._transparentCount = 0;\n};\n\nRenderList.prototype.add = function (object, isTransparent) {\n    if (isTransparent) {\n        this.transparent[this._transparentCount++] = object;\n    }\n    else {\n        this.opaque[this._opaqueCount++] = object;\n    }\n};\n\nRenderList.prototype.endCount = function () {\n    this.transparent.length = this._transparentCount;\n    this.opaque.length = this._opaqueCount;\n};\n\n/**\n * @typedef {Object} clay.Scene.RenderList\n * @property {Array.<clay.Renderable>} opaque\n * @property {Array.<clay.Renderable>} transparent\n */\n\n/**\n * @constructor clay.Scene\n * @extends clay.Node\n */\nvar Scene = Node.extend(function () {\n    return /** @lends clay.Scene# */ {\n        /**\n         * Global material of scene\n         * @type {clay.Material}\n         */\n        material: null,\n\n        lights: [],\n\n        /**\n         * Scene bounding box in view space.\n         * Used when camera needs to adujst the near and far plane automatically\n         * so that the view frustum contains the visible objects as tightly as possible.\n         * Notice:\n         *  It is updated after rendering (in the step of frustum culling passingly). So may be not so accurate, but saves a lot of calculation\n         *\n         * @type {clay.BoundingBox}\n         */\n        viewBoundingBoxLastFrame: new BoundingBox(),\n\n        // Uniforms for shadow map.\n        shadowUniforms: {},\n\n        _cameraList: [],\n\n        // Properties to save the light information in the scene\n        // Will be set in the render function\n        _lightUniforms: {},\n\n        _previousLightNumber: {},\n\n        _lightNumber: {\n            // groupId: {\n                // POINT_LIGHT: 0,\n                // DIRECTIONAL_LIGHT: 0,\n                // SPOT_LIGHT: 0,\n                // AMBIENT_LIGHT: 0,\n                // AMBIENT_SH_LIGHT: 0\n            // }\n        },\n\n        _lightProgramKeys: {},\n\n        _nodeRepository: {},\n\n        _renderLists: new LRUCache(20)\n\n    };\n}, function () {\n    this._scene = this;\n},\n/** @lends clay.Scene.prototype. */\n{\n\n    // Add node to scene\n    addToScene: function (node) {\n        if (node instanceof Camera) {\n            if (this._cameraList.length > 0) {\n                console.warn('Found multiple camera in one scene. Use the fist one.');\n            }\n            this._cameraList.push(node);\n        }\n        else if (node instanceof Light) {\n            this.lights.push(node);\n        }\n        if (node.name) {\n            this._nodeRepository[node.name] = node;\n        }\n    },\n\n    // Remove node from scene\n    removeFromScene: function (node) {\n        var idx;\n        if (node instanceof Camera) {\n            idx = this._cameraList.indexOf(node);\n            if (idx >= 0) {\n                this._cameraList.splice(idx, 1);\n            }\n        }\n        else if (node instanceof Light) {\n            idx = this.lights.indexOf(node);\n            if (idx >= 0) {\n                this.lights.splice(idx, 1);\n            }\n        }\n        if (node.name) {\n            delete this._nodeRepository[node.name];\n        }\n    },\n\n    /**\n     * Get node by name\n     * @param  {string} name\n     * @return {Node}\n     * @DEPRECATED\n     */\n    getNode: function (name) {\n        return this._nodeRepository[name];\n    },\n\n    /**\n     * Set main camera of the scene.\n     * @param {claygl.Camera} camera\n     */\n    setMainCamera: function (camera) {\n        var idx = this._cameraList.indexOf(camera);\n        if (idx >= 0) {\n            this._cameraList.splice(idx, 1);\n        }\n        this._cameraList.unshift(camera);\n    },\n    /**\n     * Get main camera of the scene.\n     */\n    getMainCamera: function () {\n        return this._cameraList[0];\n    },\n\n    getLights: function () {\n        return this.lights;\n    },\n\n    updateLights: function () {\n        var lights = this.lights;\n        this._previousLightNumber = this._lightNumber;\n\n        var lightNumber = {};\n        for (var i = 0; i < lights.length; i++) {\n            var light = lights[i];\n            if (light.invisible) {\n                continue;\n            }\n            var group = light.group;\n            if (!lightNumber[group]) {\n                lightNumber[group] = {};\n            }\n            // User can use any type of light\n            lightNumber[group][light.type] = lightNumber[group][light.type] || 0;\n            lightNumber[group][light.type]++;\n        }\n        this._lightNumber = lightNumber;\n\n        for (var groupId in lightNumber) {\n            this._lightProgramKeys[groupId] = getProgramKey(lightNumber[groupId]);\n        }\n\n        this._updateLightUniforms();\n    },\n\n    /**\n     * Clone a node and it's children, including mesh, camera, light, etc.\n     * Unlike using `Node#clone`. It will clone skeleton and remap the joints. Material will also be cloned.\n     *\n     * @param {clay.Node} node\n     * @return {clay.Node}\n     */\n    cloneNode: function (node) {\n        var newNode = node.clone();\n        var clonedNodesMap = {};\n        function buildNodesMap(sNode, tNode) {\n            clonedNodesMap[sNode.__uid__] = tNode;\n\n            for (var i = 0; i < sNode._children.length; i++) {\n                var sChild = sNode._children[i];\n                var tChild = tNode._children[i];\n                buildNodesMap(sChild, tChild);\n            }\n        }\n        buildNodesMap(node, newNode);\n\n        newNode.traverse(function (newChild) {\n            if (newChild.skeleton) {\n                newChild.skeleton = newChild.skeleton.clone(clonedNodesMap);\n            }\n            if (newChild.material) {\n                newChild.material = newChild.material.clone();\n            }\n        });\n\n        return newNode;\n    },\n\n    /**\n     * Traverse the scene and add the renderable object to the render list.\n     * It needs camera for the frustum culling.\n     *\n     * @param {clay.Camera} camera\n     * @param {boolean} updateSceneBoundingBox\n     * @return {clay.Scene.RenderList}\n     */\n    updateRenderList: function (camera, updateSceneBoundingBox) {\n        var id = camera.__uid__;\n        var renderList = this._renderLists.get(id);\n        if (!renderList) {\n            renderList = new RenderList();\n            this._renderLists.put(id, renderList);\n        }\n        renderList.startCount();\n\n        if (updateSceneBoundingBox) {\n            this.viewBoundingBoxLastFrame.min.set(Infinity, Infinity, Infinity);\n            this.viewBoundingBoxLastFrame.max.set(-Infinity, -Infinity, -Infinity);\n        }\n\n        var sceneMaterialTransparent = this.material && this.material.transparent || false;\n        this._doUpdateRenderList(this, camera, sceneMaterialTransparent, renderList, updateSceneBoundingBox);\n\n        renderList.endCount();\n\n        return renderList;\n    },\n\n    /**\n     * Get render list. Used after {@link clay.Scene#updateRenderList}\n     * @param {clay.Camera} camera\n     * @return {clay.Scene.RenderList}\n     */\n    getRenderList: function (camera) {\n        return this._renderLists.get(camera.__uid__);\n    },\n\n    _doUpdateRenderList: function (parent, camera, sceneMaterialTransparent, renderList, updateSceneBoundingBox) {\n        if (parent.invisible) {\n            return;\n        }\n        // TODO Optimize\n        for (var i = 0; i < parent._children.length; i++) {\n            var child = parent._children[i];\n\n            if (child.isRenderable()) {\n                // Frustum culling\n                var worldM = child.isSkinnedMesh() ? IDENTITY : child.worldTransform.array;\n                var geometry = child.geometry;\n\n                mat4.multiplyAffine(WORLDVIEW, camera.viewMatrix.array, worldM);\n                if (updateSceneBoundingBox && !geometry.boundingBox || !this.isFrustumCulled(child, camera, WORLDVIEW)) {\n                    renderList.add(child, child.material.transparent || sceneMaterialTransparent);\n                }\n            }\n            if (child._children.length > 0) {\n                this._doUpdateRenderList(child, camera, sceneMaterialTransparent, renderList, updateSceneBoundingBox);\n            }\n        }\n    },\n\n    /**\n     * If an scene object is culled by camera frustum\n     *\n     * Object can be a renderable or a light\n     *\n     * @param {clay.Node} object\n     * @param {clay.Camera} camera\n     * @param {Array.<number>} worldViewMat represented with array\n     * @param {Array.<number>} projectionMat represented with array\n     */\n    isFrustumCulled: (function () {\n        // Frustum culling\n        // http://www.cse.chalmers.se/~uffe/vfc_bbox.pdf\n        var cullingBoundingBox = new BoundingBox();\n        var cullingMatrix = new Matrix4();\n        return function(object, camera, worldViewMat) {\n            // Bounding box can be a property of object(like light) or renderable.geometry\n            // PENDING\n            var geoBBox = object.boundingBox;\n            if (!geoBBox) {\n                if (object.skeleton && object.skeleton.boundingBox) {\n                    geoBBox = object.skeleton.boundingBox;\n                }\n                else {\n                    geoBBox = object.geometry.boundingBox;\n                }\n            }\n\n            if (!geoBBox) {\n                return false;\n            }\n\n            cullingMatrix.array = worldViewMat;\n            cullingBoundingBox.transformFrom(geoBBox, cullingMatrix);\n\n            // Passingly update the scene bounding box\n            // FIXME exclude very large mesh like ground plane or terrain ?\n            // FIXME Only rendererable which cast shadow ?\n\n            // FIXME boundingBox becomes much larger after transformd.\n            if (object.castShadow) {\n                this.viewBoundingBoxLastFrame.union(cullingBoundingBox);\n            }\n            // Ignore frustum culling if object is skinned mesh.\n            if (object.frustumCulling)  {\n                if (!cullingBoundingBox.intersectBoundingBox(camera.frustum.boundingBox)) {\n                    return true;\n                }\n\n                cullingMatrix.array = camera.projectionMatrix.array;\n                if (\n                    cullingBoundingBox.max.array[2] > 0 &&\n                    cullingBoundingBox.min.array[2] < 0\n                ) {\n                    // Clip in the near plane\n                    cullingBoundingBox.max.array[2] = -1e-20;\n                }\n\n                cullingBoundingBox.applyProjection(cullingMatrix);\n\n                var min = cullingBoundingBox.min.array;\n                var max = cullingBoundingBox.max.array;\n\n                if (\n                    max[0] < -1 || min[0] > 1\n                    || max[1] < -1 || min[1] > 1\n                    || max[2] < -1 || min[2] > 1\n                ) {\n                    return true;\n                }\n            }\n\n            return false;\n        };\n    })(),\n\n    _updateLightUniforms: function () {\n        var lights = this.lights;\n        // Put the light cast shadow before the light not cast shadow\n        lights.sort(lightSortFunc);\n\n        var lightUniforms = this._lightUniforms;\n        for (var group in lightUniforms) {\n            for (var symbol in lightUniforms[group]) {\n                lightUniforms[group][symbol].value.length = 0;\n            }\n        }\n        for (var i = 0; i < lights.length; i++) {\n\n            var light = lights[i];\n\n            if (light.invisible) {\n                continue;\n            }\n\n            var group = light.group;\n\n            for (var symbol in light.uniformTemplates) {\n                var uniformTpl = light.uniformTemplates[symbol];\n                var value = uniformTpl.value(light);\n                if (value == null) {\n                    continue;\n                }\n                if (!lightUniforms[group]) {\n                    lightUniforms[group] = {};\n                }\n                if (!lightUniforms[group][symbol]) {\n                    lightUniforms[group][symbol] = {\n                        type: '',\n                        value: []\n                    };\n                }\n                var lu = lightUniforms[group][symbol];\n                lu.type = uniformTpl.type + 'v';\n                switch (uniformTpl.type) {\n                    case '1i':\n                    case '1f':\n                    case 't':\n                        lu.value.push(value);\n                        break;\n                    case '2f':\n                    case '3f':\n                    case '4f':\n                        for (var j = 0; j < value.length; j++) {\n                            lu.value.push(value[j]);\n                        }\n                        break;\n                    default:\n                        console.error('Unkown light uniform type ' + uniformTpl.type);\n                }\n            }\n        }\n    },\n\n    getLightGroups: function () {\n        var lightGroups = [];\n        for (var groupId in this._lightNumber) {\n            lightGroups.push(groupId);\n        }\n        return lightGroups;\n    },\n\n    getNumberChangedLightGroups: function () {\n        var lightGroups = [];\n        for (var groupId in this._lightNumber) {\n            if (this.isLightNumberChanged(groupId)) {\n                lightGroups.push(groupId);\n            }\n        }\n        return lightGroups;\n    },\n\n    // Determine if light group is different with since last frame\n    // Used to determine whether to update shader and scene's uniforms in Renderer.render\n    isLightNumberChanged: function (lightGroup) {\n        var prevLightNumber = this._previousLightNumber;\n        var currentLightNumber = this._lightNumber;\n        // PENDING Performance\n        for (var type in currentLightNumber[lightGroup]) {\n            if (!prevLightNumber[lightGroup]) {\n                return true;\n            }\n            if (currentLightNumber[lightGroup][type] !== prevLightNumber[lightGroup][type]) {\n                return true;\n            }\n        }\n        for (var type in prevLightNumber[lightGroup]) {\n            if (!currentLightNumber[lightGroup]) {\n                return true;\n            }\n            if (currentLightNumber[lightGroup][type] !== prevLightNumber[lightGroup][type]) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n    getLightsNumbers: function (lightGroup) {\n        return this._lightNumber[lightGroup];\n    },\n\n    getProgramKey: function (lightGroup) {\n        return this._lightProgramKeys[lightGroup];\n    },\n\n    setLightUniforms: (function () {\n        function setUniforms(uniforms, program, renderer) {\n            for (var symbol in uniforms) {\n                var lu = uniforms[symbol];\n                if (lu.type === 'tv') {\n                    if (!program.hasUniform(symbol)) {\n                        continue;\n                    }\n                    var texSlots = [];\n                    for (var i = 0; i < lu.value.length; i++) {\n                        var texture = lu.value[i];\n                        var slot = program.takeCurrentTextureSlot(renderer, texture);\n                        texSlots.push(slot);\n                    }\n                    program.setUniform(renderer.gl, '1iv', symbol, texSlots);\n                }\n                else {\n                    program.setUniform(renderer.gl, lu.type, symbol, lu.value);\n                }\n            }\n        }\n\n        return function (program, lightGroup, renderer) {\n            setUniforms(this._lightUniforms[lightGroup], program, renderer);\n            // Set shadows\n            setUniforms(this.shadowUniforms, program, renderer);\n        };\n    })(),\n\n    /**\n     * Dispose self, clear all the scene objects\n     * But resources of gl like texuture, shader will not be disposed.\n     * Mostly you should use disposeScene method in Renderer to do dispose.\n     */\n    dispose: function () {\n        this.material = null;\n        this._opaqueList = [];\n        this._transparentList = [];\n\n        this.lights = [];\n\n        this._lightUniforms = {};\n\n        this._lightNumber = {};\n        this._nodeRepository = {};\n    }\n});\n\nfunction lightSortFunc(a, b) {\n    if (b.castShadow && !a.castShadow) {\n        return true;\n    }\n}\n\nexport default Scene;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}