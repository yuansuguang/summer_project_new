{"ast":null,"code":"import \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport * as echarts from 'echarts/lib/echarts';\nimport glmatrix from 'claygl/src/dep/glmatrix';\nvar vec3 = glmatrix.vec3;\nvar mat4 = glmatrix.mat4;\nimport textCoord from 'echarts/lib/coord/geo/fix/textCoord';\nimport geoCoord from 'echarts/lib/coord/geo/fix/geoCoord'; // Geo fix functions\n\nvar geoFixFuncs = [textCoord, geoCoord];\nfunction Geo3D(name, map, geoJson, specialAreas, nameMap) {\n  this.name = name;\n  this.map = map;\n  this.regionHeight = 0;\n  this.regions = [];\n  this._nameCoordMap = {};\n  this.loadGeoJson(geoJson, specialAreas, nameMap);\n  this.transform = mat4.identity(new Float64Array(16));\n  this.invTransform = mat4.identity(new Float64Array(16)); // Which dimension to extrude. Y or Z\n\n  this.extrudeY = true;\n  this.altitudeAxis;\n}\nGeo3D.prototype = {\n  constructor: Geo3D,\n  type: 'geo3D',\n  dimensions: ['lng', 'lat', 'alt'],\n  containPoint: function () {},\n  loadGeoJson: function (geoJson, specialAreas, nameMap) {\n    var parseGeoJSON = echarts.parseGeoJSON || echarts.parseGeoJson;\n    try {\n      this.regions = geoJson ? parseGeoJSON(geoJson) : [];\n    } catch (e) {\n      throw 'Invalid geoJson format\\n' + e;\n    }\n    specialAreas = specialAreas || {};\n    nameMap = nameMap || {};\n    var regions = this.regions;\n    var regionsMap = {};\n    for (var i = 0; i < regions.length; i++) {\n      var regionName = regions[i].name; // Try use the alias in nameMap\n\n      regionName = nameMap[regionName] || regionName;\n      regions[i].name = regionName;\n      regionsMap[regionName] = regions[i]; // Add geoJson\n\n      this.addGeoCoord(regionName, regions[i].getCenter()); // Some area like Alaska in USA map needs to be tansformed\n      // to look better\n\n      var specialArea = specialAreas[regionName];\n      if (specialArea) {\n        regions[i].transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);\n      }\n    }\n    this._regionsMap = regionsMap;\n    this._geoRect = null;\n    geoFixFuncs.forEach(function (fixFunc) {\n      fixFunc(this);\n    }, this);\n  },\n  getGeoBoundingRect: function () {\n    if (this._geoRect) {\n      return this._geoRect;\n    }\n    var rect;\n    var regions = this.regions;\n    for (var i = 0; i < regions.length; i++) {\n      var regionRect = regions[i].getBoundingRect();\n      rect = rect || regionRect.clone();\n      rect.union(regionRect);\n    } // FIXME Always return new ?\n\n    return this._geoRect = rect || new echarts.graphic.BoundingRect(0, 0, 0, 0);\n  },\n  /**\n   * Add geoCoord for indexing by name\n   * @param {string} name\n   * @param {Array.<number>} geoCoord\n   */\n  addGeoCoord: function (name, geoCoord) {\n    this._nameCoordMap[name] = geoCoord;\n  },\n  /**\n   * @param {string} name\n   * @return {module:echarts/coord/geo/Region}\n   */\n  getRegion: function (name) {\n    return this._regionsMap[name];\n  },\n  getRegionByCoord: function (coord) {\n    var regions = this.regions;\n    for (var i = 0; i < regions.length; i++) {\n      if (regions[i].contain(coord)) {\n        return regions[i];\n      }\n    }\n  },\n  setSize: function (width, height, depth) {\n    this.size = [width, height, depth];\n    var rect = this.getGeoBoundingRect();\n    var scaleX = width / rect.width;\n    var scaleZ = -depth / rect.height;\n    var translateX = -width / 2 - rect.x * scaleX;\n    var translateZ = depth / 2 - rect.y * scaleZ;\n    var position = this.extrudeY ? [translateX, 0, translateZ] : [translateX, translateZ, 0];\n    var scale = this.extrudeY ? [scaleX, 1, scaleZ] : [scaleX, scaleZ, 1];\n    var m = this.transform;\n    mat4.identity(m);\n    mat4.translate(m, m, position);\n    mat4.scale(m, m, scale);\n    mat4.invert(this.invTransform, m);\n  },\n  dataToPoint: function (data, out) {\n    out = out || [];\n    var extrudeCoordIndex = this.extrudeY ? 1 : 2;\n    var sideCoordIndex = this.extrudeY ? 2 : 1;\n    var altitudeVal = data[2]; // PENDING.\n\n    if (isNaN(altitudeVal)) {\n      altitudeVal = 0;\n    } // lng\n\n    out[0] = data[0]; // lat\n\n    out[sideCoordIndex] = data[1];\n    if (this.altitudeAxis) {\n      out[extrudeCoordIndex] = this.altitudeAxis.dataToCoord(altitudeVal);\n    } else {\n      out[extrudeCoordIndex] = 0;\n    } // PENDING different region height.\n\n    out[extrudeCoordIndex] += this.regionHeight;\n    vec3.transformMat4(out, out, this.transform);\n    return out;\n  },\n  pointToData: function (point, out) {// TODO\n  }\n};\nexport default Geo3D;","map":{"version":3,"names":["echarts","glmatrix","vec3","mat4","textCoord","geoCoord","geoFixFuncs","Geo3D","name","map","geoJson","specialAreas","nameMap","regionHeight","regions","_nameCoordMap","loadGeoJson","transform","identity","Float64Array","invTransform","extrudeY","altitudeAxis","prototype","constructor","type","dimensions","containPoint","parseGeoJSON","parseGeoJson","e","regionsMap","i","length","regionName","addGeoCoord","getCenter","specialArea","transformTo","left","top","width","height","_regionsMap","_geoRect","forEach","fixFunc","getGeoBoundingRect","rect","regionRect","getBoundingRect","clone","union","graphic","BoundingRect","getRegion","getRegionByCoord","coord","contain","setSize","depth","size","scaleX","scaleZ","translateX","x","translateZ","y","position","scale","m","translate","invert","dataToPoint","data","out","extrudeCoordIndex","sideCoordIndex","altitudeVal","isNaN","dataToCoord","transformMat4","pointToData","point"],"sources":["E:/mytest/node_modules/echarts-gl/lib/coord/geo3D/Geo3D.js"],"sourcesContent":["import * as echarts from 'echarts/lib/echarts';\nimport glmatrix from 'claygl/src/dep/glmatrix';\nvar vec3 = glmatrix.vec3;\nvar mat4 = glmatrix.mat4;\nimport textCoord from 'echarts/lib/coord/geo/fix/textCoord';\nimport geoCoord from 'echarts/lib/coord/geo/fix/geoCoord'; // Geo fix functions\n\nvar geoFixFuncs = [textCoord, geoCoord];\n\nfunction Geo3D(name, map, geoJson, specialAreas, nameMap) {\n  this.name = name;\n  this.map = map;\n  this.regionHeight = 0;\n  this.regions = [];\n  this._nameCoordMap = {};\n  this.loadGeoJson(geoJson, specialAreas, nameMap);\n  this.transform = mat4.identity(new Float64Array(16));\n  this.invTransform = mat4.identity(new Float64Array(16)); // Which dimension to extrude. Y or Z\n\n  this.extrudeY = true;\n  this.altitudeAxis;\n}\n\nGeo3D.prototype = {\n  constructor: Geo3D,\n  type: 'geo3D',\n  dimensions: ['lng', 'lat', 'alt'],\n  containPoint: function () {},\n  loadGeoJson: function (geoJson, specialAreas, nameMap) {\n    var parseGeoJSON = echarts.parseGeoJSON || echarts.parseGeoJson;\n\n    try {\n      this.regions = geoJson ? parseGeoJSON(geoJson) : [];\n    } catch (e) {\n      throw 'Invalid geoJson format\\n' + e;\n    }\n\n    specialAreas = specialAreas || {};\n    nameMap = nameMap || {};\n    var regions = this.regions;\n    var regionsMap = {};\n\n    for (var i = 0; i < regions.length; i++) {\n      var regionName = regions[i].name; // Try use the alias in nameMap\n\n      regionName = nameMap[regionName] || regionName;\n      regions[i].name = regionName;\n      regionsMap[regionName] = regions[i]; // Add geoJson\n\n      this.addGeoCoord(regionName, regions[i].getCenter()); // Some area like Alaska in USA map needs to be tansformed\n      // to look better\n\n      var specialArea = specialAreas[regionName];\n\n      if (specialArea) {\n        regions[i].transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);\n      }\n    }\n\n    this._regionsMap = regionsMap;\n    this._geoRect = null;\n    geoFixFuncs.forEach(function (fixFunc) {\n      fixFunc(this);\n    }, this);\n  },\n  getGeoBoundingRect: function () {\n    if (this._geoRect) {\n      return this._geoRect;\n    }\n\n    var rect;\n    var regions = this.regions;\n\n    for (var i = 0; i < regions.length; i++) {\n      var regionRect = regions[i].getBoundingRect();\n      rect = rect || regionRect.clone();\n      rect.union(regionRect);\n    } // FIXME Always return new ?\n\n\n    return this._geoRect = rect || new echarts.graphic.BoundingRect(0, 0, 0, 0);\n  },\n\n  /**\n   * Add geoCoord for indexing by name\n   * @param {string} name\n   * @param {Array.<number>} geoCoord\n   */\n  addGeoCoord: function (name, geoCoord) {\n    this._nameCoordMap[name] = geoCoord;\n  },\n\n  /**\n   * @param {string} name\n   * @return {module:echarts/coord/geo/Region}\n   */\n  getRegion: function (name) {\n    return this._regionsMap[name];\n  },\n  getRegionByCoord: function (coord) {\n    var regions = this.regions;\n\n    for (var i = 0; i < regions.length; i++) {\n      if (regions[i].contain(coord)) {\n        return regions[i];\n      }\n    }\n  },\n  setSize: function (width, height, depth) {\n    this.size = [width, height, depth];\n    var rect = this.getGeoBoundingRect();\n    var scaleX = width / rect.width;\n    var scaleZ = -depth / rect.height;\n    var translateX = -width / 2 - rect.x * scaleX;\n    var translateZ = depth / 2 - rect.y * scaleZ;\n    var position = this.extrudeY ? [translateX, 0, translateZ] : [translateX, translateZ, 0];\n    var scale = this.extrudeY ? [scaleX, 1, scaleZ] : [scaleX, scaleZ, 1];\n    var m = this.transform;\n    mat4.identity(m);\n    mat4.translate(m, m, position);\n    mat4.scale(m, m, scale);\n    mat4.invert(this.invTransform, m);\n  },\n  dataToPoint: function (data, out) {\n    out = out || [];\n    var extrudeCoordIndex = this.extrudeY ? 1 : 2;\n    var sideCoordIndex = this.extrudeY ? 2 : 1;\n    var altitudeVal = data[2]; // PENDING.\n\n    if (isNaN(altitudeVal)) {\n      altitudeVal = 0;\n    } // lng\n\n\n    out[0] = data[0]; // lat\n\n    out[sideCoordIndex] = data[1];\n\n    if (this.altitudeAxis) {\n      out[extrudeCoordIndex] = this.altitudeAxis.dataToCoord(altitudeVal);\n    } else {\n      out[extrudeCoordIndex] = 0;\n    } // PENDING different region height.\n\n\n    out[extrudeCoordIndex] += this.regionHeight;\n    vec3.transformMat4(out, out, this.transform);\n    return out;\n  },\n  pointToData: function (point, out) {// TODO\n  }\n};\nexport default Geo3D;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}