{"ast":null,"code":"import \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport * as echarts from 'echarts/lib/echarts';\nimport graphicGL from '../../util/graphicGL';\nimport glmatrix from 'claygl/src/dep/glmatrix';\nimport trianglesSortMixin from '../../util/geometry/trianglesSortMixin';\nimport { getItemVisualColor, getItemVisualOpacity } from '../../util/visual';\nvar vec3 = glmatrix.vec3;\nfunction isPointsNaN(pt) {\n  return isNaN(pt[0]) || isNaN(pt[1]) || isNaN(pt[2]);\n}\nexport default echarts.ChartView.extend({\n  type: 'surface',\n  __ecgl__: true,\n  init: function (ecModel, api) {\n    this.groupGL = new graphicGL.Node();\n  },\n  render: function (seriesModel, ecModel, api) {\n    // Swap surfaceMesh\n    var tmp = this._prevSurfaceMesh;\n    this._prevSurfaceMesh = this._surfaceMesh;\n    this._surfaceMesh = tmp;\n    if (!this._surfaceMesh) {\n      this._surfaceMesh = this._createSurfaceMesh();\n    }\n    this.groupGL.remove(this._prevSurfaceMesh);\n    this.groupGL.add(this._surfaceMesh);\n    var coordSys = seriesModel.coordinateSystem;\n    var shading = seriesModel.get('shading');\n    var data = seriesModel.getData();\n    var shadingPrefix = 'ecgl.' + shading;\n    if (!this._surfaceMesh.material || this._surfaceMesh.material.shader.name !== shadingPrefix) {\n      this._surfaceMesh.material = graphicGL.createMaterial(shadingPrefix, ['VERTEX_COLOR', 'DOUBLE_SIDED']);\n    }\n    graphicGL.setMaterialFromModel(shading, this._surfaceMesh.material, seriesModel, api);\n    if (coordSys && coordSys.viewGL) {\n      coordSys.viewGL.add(this.groupGL);\n      var methodName = coordSys.viewGL.isLinearSpace() ? 'define' : 'undefine';\n      this._surfaceMesh.material[methodName]('fragment', 'SRGB_DECODE');\n    }\n    var isParametric = seriesModel.get('parametric');\n    var dataShape = seriesModel.get('dataShape');\n    if (!dataShape) {\n      dataShape = this._getDataShape(data, isParametric);\n      if (process.env.NODE_ENV !== 'production') {\n        if (seriesModel.get('data')) {\n          console.warn('dataShape is not provided. Guess it is ', dataShape);\n        }\n      }\n    }\n    var wireframeModel = seriesModel.getModel('wireframe');\n    var wireframeLineWidth = wireframeModel.get('lineStyle.width');\n    var showWireframe = wireframeModel.get('show') && wireframeLineWidth > 0;\n    this._updateSurfaceMesh(this._surfaceMesh, seriesModel, dataShape, showWireframe);\n    var material = this._surfaceMesh.material;\n    if (showWireframe) {\n      material.define('WIREFRAME_QUAD');\n      material.set('wireframeLineWidth', wireframeLineWidth);\n      material.set('wireframeLineColor', graphicGL.parseColor(wireframeModel.get('lineStyle.color')));\n    } else {\n      material.undefine('WIREFRAME_QUAD');\n    }\n    this._initHandler(seriesModel, api);\n    this._updateAnimation(seriesModel);\n  },\n  _updateAnimation: function (seriesModel) {\n    graphicGL.updateVertexAnimation([['prevPosition', 'position'], ['prevNormal', 'normal']], this._prevSurfaceMesh, this._surfaceMesh, seriesModel);\n  },\n  _createSurfaceMesh: function () {\n    var mesh = new graphicGL.Mesh({\n      geometry: new graphicGL.Geometry({\n        dynamic: true,\n        sortTriangles: true\n      }),\n      shadowDepthMaterial: new graphicGL.Material({\n        shader: new graphicGL.Shader(graphicGL.Shader.source('ecgl.sm.depth.vertex'), graphicGL.Shader.source('ecgl.sm.depth.fragment'))\n      }),\n      culling: false,\n      // Render after axes\n      renderOrder: 10,\n      // Render normal in normal pass\n      renderNormal: true\n    });\n    mesh.geometry.createAttribute('barycentric', 'float', 4);\n    mesh.geometry.createAttribute('prevPosition', 'float', 3);\n    mesh.geometry.createAttribute('prevNormal', 'float', 3);\n    Object.assign(mesh.geometry, trianglesSortMixin);\n    return mesh;\n  },\n  _initHandler: function (seriesModel, api) {\n    var data = seriesModel.getData();\n    var surfaceMesh = this._surfaceMesh;\n    var coordSys = seriesModel.coordinateSystem;\n    function getNearestPointIdx(triangle, point) {\n      var nearestDist = Infinity;\n      var nearestIdx = -1;\n      var pos = [];\n      for (var i = 0; i < triangle.length; i++) {\n        surfaceMesh.geometry.attributes.position.get(triangle[i], pos);\n        var dist = vec3.dist(point.array, pos);\n        if (dist < nearestDist) {\n          nearestDist = dist;\n          nearestIdx = triangle[i];\n        }\n      }\n      return nearestIdx;\n    }\n    surfaceMesh.seriesIndex = seriesModel.seriesIndex;\n    var lastDataIndex = -1;\n    surfaceMesh.off('mousemove');\n    surfaceMesh.off('mouseout');\n    surfaceMesh.on('mousemove', function (e) {\n      var idx = getNearestPointIdx(e.triangle, e.point);\n      if (idx >= 0) {\n        var point = [];\n        surfaceMesh.geometry.attributes.position.get(idx, point);\n        var value = coordSys.pointToData(point);\n        var minDist = Infinity;\n        var dataIndex = -1;\n        var item = [];\n        for (var i = 0; i < data.count(); i++) {\n          item[0] = data.get('x', i);\n          item[1] = data.get('y', i);\n          item[2] = data.get('z', i);\n          var dist = vec3.squaredDistance(item, value);\n          if (dist < minDist) {\n            dataIndex = i;\n            minDist = dist;\n          }\n        }\n        if (dataIndex !== lastDataIndex) {\n          api.dispatchAction({\n            type: 'grid3DShowAxisPointer',\n            value: value\n          });\n        }\n        lastDataIndex = dataIndex;\n        surfaceMesh.dataIndex = dataIndex;\n      } else {\n        surfaceMesh.dataIndex = -1;\n      }\n    }, this);\n    surfaceMesh.on('mouseout', function (e) {\n      lastDataIndex = -1;\n      surfaceMesh.dataIndex = -1;\n      api.dispatchAction({\n        type: 'grid3DHideAxisPointer'\n      });\n    }, this);\n  },\n  _updateSurfaceMesh: function (surfaceMesh, seriesModel, dataShape, showWireframe) {\n    var geometry = surfaceMesh.geometry;\n    var data = seriesModel.getData();\n    var pointsArr = data.getLayout('points');\n    var invalidDataCount = 0;\n    data.each(function (idx) {\n      if (!data.hasValue(idx)) {\n        invalidDataCount++;\n      }\n    });\n    var needsSplitQuad = invalidDataCount || showWireframe;\n    var positionAttr = geometry.attributes.position;\n    var normalAttr = geometry.attributes.normal;\n    var texcoordAttr = geometry.attributes.texcoord0;\n    var barycentricAttr = geometry.attributes.barycentric;\n    var colorAttr = geometry.attributes.color;\n    var row = dataShape[0];\n    var column = dataShape[1];\n    var shading = seriesModel.get('shading');\n    var needsNormal = shading !== 'color';\n    if (needsSplitQuad) {\n      // TODO, If needs remove the invalid points, or set color transparent.\n      var vertexCount = (row - 1) * (column - 1) * 4;\n      positionAttr.init(vertexCount);\n      if (showWireframe) {\n        barycentricAttr.init(vertexCount);\n      }\n    } else {\n      positionAttr.value = new Float32Array(pointsArr);\n    }\n    colorAttr.init(geometry.vertexCount);\n    texcoordAttr.init(geometry.vertexCount);\n    var quadToTriangle = [0, 3, 1, 1, 3, 2]; // 3----2\n    // 0----1\n    // Make sure pixels on 1---3 edge will not have channel 0.\n    // And pixels on four edges have at least one channel 0.\n\n    var quadBarycentric = [[1, 1, 0, 0], [0, 1, 0, 1], [1, 0, 0, 1], [1, 0, 1, 0]];\n    var indices = geometry.indices = new (geometry.vertexCount > 0xffff ? Uint32Array : Uint16Array)((row - 1) * (column - 1) * 6);\n    var getQuadIndices = function (i, j, out) {\n      out[1] = i * column + j;\n      out[0] = i * column + j + 1;\n      out[3] = (i + 1) * column + j + 1;\n      out[2] = (i + 1) * column + j;\n    };\n    var isTransparent = false;\n    if (needsSplitQuad) {\n      var quadIndices = [];\n      var pos = [];\n      var faceOffset = 0;\n      if (needsNormal) {\n        normalAttr.init(geometry.vertexCount);\n      } else {\n        normalAttr.value = null;\n      }\n      var pts = [[], [], []];\n      var v21 = [],\n        v32 = [];\n      var normal = vec3.create();\n      var getFromArray = function (arr, idx, out) {\n        var idx3 = idx * 3;\n        out[0] = arr[idx3];\n        out[1] = arr[idx3 + 1];\n        out[2] = arr[idx3 + 2];\n        return out;\n      };\n      var vertexNormals = new Float32Array(pointsArr.length);\n      var vertexColors = new Float32Array(pointsArr.length / 3 * 4);\n      for (var i = 0; i < data.count(); i++) {\n        if (data.hasValue(i)) {\n          var rgbaArr = graphicGL.parseColor(getItemVisualColor(data, i));\n          var opacity = getItemVisualOpacity(data, i);\n          opacity != null && (rgbaArr[3] *= opacity);\n          if (rgbaArr[3] < 0.99) {\n            isTransparent = true;\n          }\n          for (var k = 0; k < 4; k++) {\n            vertexColors[i * 4 + k] = rgbaArr[k];\n          }\n        }\n      }\n      var farPoints = [1e7, 1e7, 1e7];\n      for (var i = 0; i < row - 1; i++) {\n        for (var j = 0; j < column - 1; j++) {\n          var dataIndex = i * (column - 1) + j;\n          var vertexOffset = dataIndex * 4;\n          getQuadIndices(i, j, quadIndices);\n          var invisibleQuad = false;\n          for (var k = 0; k < 4; k++) {\n            getFromArray(pointsArr, quadIndices[k], pos);\n            if (isPointsNaN(pos)) {\n              // Quad is invisible if any point is NaN\n              invisibleQuad = true;\n            }\n          }\n          for (var k = 0; k < 4; k++) {\n            if (invisibleQuad) {\n              // Move point far away\n              positionAttr.set(vertexOffset + k, farPoints);\n            } else {\n              getFromArray(pointsArr, quadIndices[k], pos);\n              positionAttr.set(vertexOffset + k, pos);\n            }\n            if (showWireframe) {\n              barycentricAttr.set(vertexOffset + k, quadBarycentric[k]);\n            }\n          }\n          for (var k = 0; k < 6; k++) {\n            indices[faceOffset++] = quadToTriangle[k] + vertexOffset;\n          } // Vertex normals\n\n          if (needsNormal && !invisibleQuad) {\n            for (var k = 0; k < 2; k++) {\n              var k3 = k * 3;\n              for (var m = 0; m < 3; m++) {\n                var idx = quadIndices[quadToTriangle[k3] + m];\n                getFromArray(pointsArr, idx, pts[m]);\n              }\n              vec3.sub(v21, pts[0], pts[1]);\n              vec3.sub(v32, pts[1], pts[2]);\n              vec3.cross(normal, v21, v32); // Weighted by the triangle area\n\n              for (var m = 0; m < 3; m++) {\n                var idx3 = quadIndices[quadToTriangle[k3] + m] * 3;\n                vertexNormals[idx3] = vertexNormals[idx3] + normal[0];\n                vertexNormals[idx3 + 1] = vertexNormals[idx3 + 1] + normal[1];\n                vertexNormals[idx3 + 2] = vertexNormals[idx3 + 2] + normal[2];\n              }\n            }\n          }\n        }\n      }\n      if (needsNormal) {\n        for (var i = 0; i < vertexNormals.length / 3; i++) {\n          getFromArray(vertexNormals, i, normal);\n          vec3.normalize(normal, normal);\n          vertexNormals[i * 3] = normal[0];\n          vertexNormals[i * 3 + 1] = normal[1];\n          vertexNormals[i * 3 + 2] = normal[2];\n        }\n      } // Split normal and colors, write to the attributes.\n\n      var rgbaArr = [];\n      var uvArr = [];\n      for (var i = 0; i < row - 1; i++) {\n        for (var j = 0; j < column - 1; j++) {\n          var dataIndex = i * (column - 1) + j;\n          var vertexOffset = dataIndex * 4;\n          getQuadIndices(i, j, quadIndices);\n          for (var k = 0; k < 4; k++) {\n            for (var m = 0; m < 4; m++) {\n              rgbaArr[m] = vertexColors[quadIndices[k] * 4 + m];\n            }\n            colorAttr.set(vertexOffset + k, rgbaArr);\n            if (needsNormal) {\n              getFromArray(vertexNormals, quadIndices[k], normal);\n              normalAttr.set(vertexOffset + k, normal);\n            }\n            var idx = quadIndices[k];\n            uvArr[0] = idx % column / (column - 1);\n            uvArr[1] = Math.floor(idx / column) / (row - 1);\n            texcoordAttr.set(vertexOffset + k, uvArr);\n          }\n          dataIndex++;\n        }\n      }\n    } else {\n      var uvArr = [];\n      for (var i = 0; i < data.count(); i++) {\n        uvArr[0] = i % column / (column - 1);\n        uvArr[1] = Math.floor(i / column) / (row - 1);\n        var rgbaArr = graphicGL.parseColor(getItemVisualColor(data, i));\n        var opacity = getItemVisualOpacity(data, i);\n        opacity != null && (rgbaArr[3] *= opacity);\n        if (rgbaArr[3] < 0.99) {\n          isTransparent = true;\n        }\n        colorAttr.set(i, rgbaArr);\n        texcoordAttr.set(i, uvArr);\n      }\n      var quadIndices = []; // Triangles\n\n      var cursor = 0;\n      for (var i = 0; i < row - 1; i++) {\n        for (var j = 0; j < column - 1; j++) {\n          getQuadIndices(i, j, quadIndices);\n          for (var k = 0; k < 6; k++) {\n            indices[cursor++] = quadIndices[quadToTriangle[k]];\n          }\n        }\n      }\n      if (needsNormal) {\n        geometry.generateVertexNormals();\n      } else {\n        normalAttr.value = null;\n      }\n    }\n    if (surfaceMesh.material.get('normalMap')) {\n      geometry.generateTangents();\n    }\n    geometry.updateBoundingBox();\n    geometry.dirty();\n    surfaceMesh.material.transparent = isTransparent;\n    surfaceMesh.material.depthMask = !isTransparent;\n  },\n  _getDataShape: function (data, isParametric) {\n    var prevX = -Infinity;\n    var rowCount = 0;\n    var columnCount = 0;\n    var prevColumnCount = 0;\n    var mayInvalid = false;\n    var rowDim = isParametric ? 'u' : 'x';\n    var dataCount = data.count(); // Check data format\n\n    for (var i = 0; i < dataCount; i++) {\n      var x = data.get(rowDim, i);\n      if (x < prevX) {\n        if (prevColumnCount && prevColumnCount !== columnCount) {\n          if (process.env.NODE_ENV !== 'production') {\n            mayInvalid = true;\n          }\n        } // A new row.\n\n        prevColumnCount = columnCount;\n        columnCount = 0;\n        rowCount++;\n      }\n      prevX = x;\n      columnCount++;\n    }\n    if (!rowCount || columnCount === 1) {\n      mayInvalid = true;\n    }\n    if (!mayInvalid) {\n      return [rowCount + 1, columnCount];\n    }\n    var rows = Math.floor(Math.sqrt(dataCount));\n    while (rows > 0) {\n      if (Math.floor(dataCount / rows) === dataCount / rows) {\n        // Can be divided\n        return [rows, dataCount / rows];\n      }\n      rows--;\n    } // Bailout\n\n    rows = Math.floor(Math.sqrt(dataCount));\n    return [rows, rows];\n  },\n  dispose: function () {\n    this.groupGL.removeAll();\n  },\n  remove: function () {\n    this.groupGL.removeAll();\n  }\n});","map":{"version":3,"names":["echarts","graphicGL","glmatrix","trianglesSortMixin","getItemVisualColor","getItemVisualOpacity","vec3","isPointsNaN","pt","isNaN","ChartView","extend","type","__ecgl__","init","ecModel","api","groupGL","Node","render","seriesModel","tmp","_prevSurfaceMesh","_surfaceMesh","_createSurfaceMesh","remove","add","coordSys","coordinateSystem","shading","get","data","getData","shadingPrefix","material","shader","name","createMaterial","setMaterialFromModel","viewGL","methodName","isLinearSpace","isParametric","dataShape","_getDataShape","process","env","NODE_ENV","console","warn","wireframeModel","getModel","wireframeLineWidth","showWireframe","_updateSurfaceMesh","define","set","parseColor","undefine","_initHandler","_updateAnimation","updateVertexAnimation","mesh","Mesh","geometry","Geometry","dynamic","sortTriangles","shadowDepthMaterial","Material","Shader","source","culling","renderOrder","renderNormal","createAttribute","Object","assign","surfaceMesh","getNearestPointIdx","triangle","point","nearestDist","Infinity","nearestIdx","pos","i","length","attributes","position","dist","array","seriesIndex","lastDataIndex","off","on","e","idx","value","pointToData","minDist","dataIndex","item","count","squaredDistance","dispatchAction","pointsArr","getLayout","invalidDataCount","each","hasValue","needsSplitQuad","positionAttr","normalAttr","normal","texcoordAttr","texcoord0","barycentricAttr","barycentric","colorAttr","color","row","column","needsNormal","vertexCount","Float32Array","quadToTriangle","quadBarycentric","indices","Uint32Array","Uint16Array","getQuadIndices","j","out","isTransparent","quadIndices","faceOffset","pts","v21","v32","create","getFromArray","arr","idx3","vertexNormals","vertexColors","rgbaArr","opacity","k","farPoints","vertexOffset","invisibleQuad","k3","m","sub","cross","normalize","uvArr","Math","floor","cursor","generateVertexNormals","generateTangents","updateBoundingBox","dirty","transparent","depthMask","prevX","rowCount","columnCount","prevColumnCount","mayInvalid","rowDim","dataCount","x","rows","sqrt","dispose","removeAll"],"sources":["E:/QuestionairePlanet_Fronted/mytest/node_modules/echarts-gl/lib/chart/surface/SurfaceView.js"],"sourcesContent":["import * as echarts from 'echarts/lib/echarts';\nimport graphicGL from '../../util/graphicGL';\nimport glmatrix from 'claygl/src/dep/glmatrix';\nimport trianglesSortMixin from '../../util/geometry/trianglesSortMixin';\nimport { getItemVisualColor, getItemVisualOpacity } from '../../util/visual';\nvar vec3 = glmatrix.vec3;\n\nfunction isPointsNaN(pt) {\n  return isNaN(pt[0]) || isNaN(pt[1]) || isNaN(pt[2]);\n}\n\nexport default echarts.ChartView.extend({\n  type: 'surface',\n  __ecgl__: true,\n  init: function (ecModel, api) {\n    this.groupGL = new graphicGL.Node();\n  },\n  render: function (seriesModel, ecModel, api) {\n    // Swap surfaceMesh\n    var tmp = this._prevSurfaceMesh;\n    this._prevSurfaceMesh = this._surfaceMesh;\n    this._surfaceMesh = tmp;\n\n    if (!this._surfaceMesh) {\n      this._surfaceMesh = this._createSurfaceMesh();\n    }\n\n    this.groupGL.remove(this._prevSurfaceMesh);\n    this.groupGL.add(this._surfaceMesh);\n    var coordSys = seriesModel.coordinateSystem;\n    var shading = seriesModel.get('shading');\n    var data = seriesModel.getData();\n    var shadingPrefix = 'ecgl.' + shading;\n\n    if (!this._surfaceMesh.material || this._surfaceMesh.material.shader.name !== shadingPrefix) {\n      this._surfaceMesh.material = graphicGL.createMaterial(shadingPrefix, ['VERTEX_COLOR', 'DOUBLE_SIDED']);\n    }\n\n    graphicGL.setMaterialFromModel(shading, this._surfaceMesh.material, seriesModel, api);\n\n    if (coordSys && coordSys.viewGL) {\n      coordSys.viewGL.add(this.groupGL);\n      var methodName = coordSys.viewGL.isLinearSpace() ? 'define' : 'undefine';\n\n      this._surfaceMesh.material[methodName]('fragment', 'SRGB_DECODE');\n    }\n\n    var isParametric = seriesModel.get('parametric');\n    var dataShape = seriesModel.get('dataShape');\n\n    if (!dataShape) {\n      dataShape = this._getDataShape(data, isParametric);\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (seriesModel.get('data')) {\n          console.warn('dataShape is not provided. Guess it is ', dataShape);\n        }\n      }\n    }\n\n    var wireframeModel = seriesModel.getModel('wireframe');\n    var wireframeLineWidth = wireframeModel.get('lineStyle.width');\n    var showWireframe = wireframeModel.get('show') && wireframeLineWidth > 0;\n\n    this._updateSurfaceMesh(this._surfaceMesh, seriesModel, dataShape, showWireframe);\n\n    var material = this._surfaceMesh.material;\n\n    if (showWireframe) {\n      material.define('WIREFRAME_QUAD');\n      material.set('wireframeLineWidth', wireframeLineWidth);\n      material.set('wireframeLineColor', graphicGL.parseColor(wireframeModel.get('lineStyle.color')));\n    } else {\n      material.undefine('WIREFRAME_QUAD');\n    }\n\n    this._initHandler(seriesModel, api);\n\n    this._updateAnimation(seriesModel);\n  },\n  _updateAnimation: function (seriesModel) {\n    graphicGL.updateVertexAnimation([['prevPosition', 'position'], ['prevNormal', 'normal']], this._prevSurfaceMesh, this._surfaceMesh, seriesModel);\n  },\n  _createSurfaceMesh: function () {\n    var mesh = new graphicGL.Mesh({\n      geometry: new graphicGL.Geometry({\n        dynamic: true,\n        sortTriangles: true\n      }),\n      shadowDepthMaterial: new graphicGL.Material({\n        shader: new graphicGL.Shader(graphicGL.Shader.source('ecgl.sm.depth.vertex'), graphicGL.Shader.source('ecgl.sm.depth.fragment'))\n      }),\n      culling: false,\n      // Render after axes\n      renderOrder: 10,\n      // Render normal in normal pass\n      renderNormal: true\n    });\n    mesh.geometry.createAttribute('barycentric', 'float', 4);\n    mesh.geometry.createAttribute('prevPosition', 'float', 3);\n    mesh.geometry.createAttribute('prevNormal', 'float', 3);\n    Object.assign(mesh.geometry, trianglesSortMixin);\n    return mesh;\n  },\n  _initHandler: function (seriesModel, api) {\n    var data = seriesModel.getData();\n    var surfaceMesh = this._surfaceMesh;\n    var coordSys = seriesModel.coordinateSystem;\n\n    function getNearestPointIdx(triangle, point) {\n      var nearestDist = Infinity;\n      var nearestIdx = -1;\n      var pos = [];\n\n      for (var i = 0; i < triangle.length; i++) {\n        surfaceMesh.geometry.attributes.position.get(triangle[i], pos);\n        var dist = vec3.dist(point.array, pos);\n\n        if (dist < nearestDist) {\n          nearestDist = dist;\n          nearestIdx = triangle[i];\n        }\n      }\n\n      return nearestIdx;\n    }\n\n    surfaceMesh.seriesIndex = seriesModel.seriesIndex;\n    var lastDataIndex = -1;\n    surfaceMesh.off('mousemove');\n    surfaceMesh.off('mouseout');\n    surfaceMesh.on('mousemove', function (e) {\n      var idx = getNearestPointIdx(e.triangle, e.point);\n\n      if (idx >= 0) {\n        var point = [];\n        surfaceMesh.geometry.attributes.position.get(idx, point);\n        var value = coordSys.pointToData(point);\n        var minDist = Infinity;\n        var dataIndex = -1;\n        var item = [];\n\n        for (var i = 0; i < data.count(); i++) {\n          item[0] = data.get('x', i);\n          item[1] = data.get('y', i);\n          item[2] = data.get('z', i);\n          var dist = vec3.squaredDistance(item, value);\n\n          if (dist < minDist) {\n            dataIndex = i;\n            minDist = dist;\n          }\n        }\n\n        if (dataIndex !== lastDataIndex) {\n          api.dispatchAction({\n            type: 'grid3DShowAxisPointer',\n            value: value\n          });\n        }\n\n        lastDataIndex = dataIndex;\n        surfaceMesh.dataIndex = dataIndex;\n      } else {\n        surfaceMesh.dataIndex = -1;\n      }\n    }, this);\n    surfaceMesh.on('mouseout', function (e) {\n      lastDataIndex = -1;\n      surfaceMesh.dataIndex = -1;\n      api.dispatchAction({\n        type: 'grid3DHideAxisPointer'\n      });\n    }, this);\n  },\n  _updateSurfaceMesh: function (surfaceMesh, seriesModel, dataShape, showWireframe) {\n    var geometry = surfaceMesh.geometry;\n    var data = seriesModel.getData();\n    var pointsArr = data.getLayout('points');\n    var invalidDataCount = 0;\n    data.each(function (idx) {\n      if (!data.hasValue(idx)) {\n        invalidDataCount++;\n      }\n    });\n    var needsSplitQuad = invalidDataCount || showWireframe;\n    var positionAttr = geometry.attributes.position;\n    var normalAttr = geometry.attributes.normal;\n    var texcoordAttr = geometry.attributes.texcoord0;\n    var barycentricAttr = geometry.attributes.barycentric;\n    var colorAttr = geometry.attributes.color;\n    var row = dataShape[0];\n    var column = dataShape[1];\n    var shading = seriesModel.get('shading');\n    var needsNormal = shading !== 'color';\n\n    if (needsSplitQuad) {\n      // TODO, If needs remove the invalid points, or set color transparent.\n      var vertexCount = (row - 1) * (column - 1) * 4;\n      positionAttr.init(vertexCount);\n\n      if (showWireframe) {\n        barycentricAttr.init(vertexCount);\n      }\n    } else {\n      positionAttr.value = new Float32Array(pointsArr);\n    }\n\n    colorAttr.init(geometry.vertexCount);\n    texcoordAttr.init(geometry.vertexCount);\n    var quadToTriangle = [0, 3, 1, 1, 3, 2]; // 3----2\n    // 0----1\n    // Make sure pixels on 1---3 edge will not have channel 0.\n    // And pixels on four edges have at least one channel 0.\n\n    var quadBarycentric = [[1, 1, 0, 0], [0, 1, 0, 1], [1, 0, 0, 1], [1, 0, 1, 0]];\n    var indices = geometry.indices = new (geometry.vertexCount > 0xffff ? Uint32Array : Uint16Array)((row - 1) * (column - 1) * 6);\n\n    var getQuadIndices = function (i, j, out) {\n      out[1] = i * column + j;\n      out[0] = i * column + j + 1;\n      out[3] = (i + 1) * column + j + 1;\n      out[2] = (i + 1) * column + j;\n    };\n\n    var isTransparent = false;\n\n    if (needsSplitQuad) {\n      var quadIndices = [];\n      var pos = [];\n      var faceOffset = 0;\n\n      if (needsNormal) {\n        normalAttr.init(geometry.vertexCount);\n      } else {\n        normalAttr.value = null;\n      }\n\n      var pts = [[], [], []];\n      var v21 = [],\n          v32 = [];\n      var normal = vec3.create();\n\n      var getFromArray = function (arr, idx, out) {\n        var idx3 = idx * 3;\n        out[0] = arr[idx3];\n        out[1] = arr[idx3 + 1];\n        out[2] = arr[idx3 + 2];\n        return out;\n      };\n\n      var vertexNormals = new Float32Array(pointsArr.length);\n      var vertexColors = new Float32Array(pointsArr.length / 3 * 4);\n\n      for (var i = 0; i < data.count(); i++) {\n        if (data.hasValue(i)) {\n          var rgbaArr = graphicGL.parseColor(getItemVisualColor(data, i));\n          var opacity = getItemVisualOpacity(data, i);\n          opacity != null && (rgbaArr[3] *= opacity);\n\n          if (rgbaArr[3] < 0.99) {\n            isTransparent = true;\n          }\n\n          for (var k = 0; k < 4; k++) {\n            vertexColors[i * 4 + k] = rgbaArr[k];\n          }\n        }\n      }\n\n      var farPoints = [1e7, 1e7, 1e7];\n\n      for (var i = 0; i < row - 1; i++) {\n        for (var j = 0; j < column - 1; j++) {\n          var dataIndex = i * (column - 1) + j;\n          var vertexOffset = dataIndex * 4;\n          getQuadIndices(i, j, quadIndices);\n          var invisibleQuad = false;\n\n          for (var k = 0; k < 4; k++) {\n            getFromArray(pointsArr, quadIndices[k], pos);\n\n            if (isPointsNaN(pos)) {\n              // Quad is invisible if any point is NaN\n              invisibleQuad = true;\n            }\n          }\n\n          for (var k = 0; k < 4; k++) {\n            if (invisibleQuad) {\n              // Move point far away\n              positionAttr.set(vertexOffset + k, farPoints);\n            } else {\n              getFromArray(pointsArr, quadIndices[k], pos);\n              positionAttr.set(vertexOffset + k, pos);\n            }\n\n            if (showWireframe) {\n              barycentricAttr.set(vertexOffset + k, quadBarycentric[k]);\n            }\n          }\n\n          for (var k = 0; k < 6; k++) {\n            indices[faceOffset++] = quadToTriangle[k] + vertexOffset;\n          } // Vertex normals\n\n\n          if (needsNormal && !invisibleQuad) {\n            for (var k = 0; k < 2; k++) {\n              var k3 = k * 3;\n\n              for (var m = 0; m < 3; m++) {\n                var idx = quadIndices[quadToTriangle[k3] + m];\n                getFromArray(pointsArr, idx, pts[m]);\n              }\n\n              vec3.sub(v21, pts[0], pts[1]);\n              vec3.sub(v32, pts[1], pts[2]);\n              vec3.cross(normal, v21, v32); // Weighted by the triangle area\n\n              for (var m = 0; m < 3; m++) {\n                var idx3 = quadIndices[quadToTriangle[k3] + m] * 3;\n                vertexNormals[idx3] = vertexNormals[idx3] + normal[0];\n                vertexNormals[idx3 + 1] = vertexNormals[idx3 + 1] + normal[1];\n                vertexNormals[idx3 + 2] = vertexNormals[idx3 + 2] + normal[2];\n              }\n            }\n          }\n        }\n      }\n\n      if (needsNormal) {\n        for (var i = 0; i < vertexNormals.length / 3; i++) {\n          getFromArray(vertexNormals, i, normal);\n          vec3.normalize(normal, normal);\n          vertexNormals[i * 3] = normal[0];\n          vertexNormals[i * 3 + 1] = normal[1];\n          vertexNormals[i * 3 + 2] = normal[2];\n        }\n      } // Split normal and colors, write to the attributes.\n\n\n      var rgbaArr = [];\n      var uvArr = [];\n\n      for (var i = 0; i < row - 1; i++) {\n        for (var j = 0; j < column - 1; j++) {\n          var dataIndex = i * (column - 1) + j;\n          var vertexOffset = dataIndex * 4;\n          getQuadIndices(i, j, quadIndices);\n\n          for (var k = 0; k < 4; k++) {\n            for (var m = 0; m < 4; m++) {\n              rgbaArr[m] = vertexColors[quadIndices[k] * 4 + m];\n            }\n\n            colorAttr.set(vertexOffset + k, rgbaArr);\n\n            if (needsNormal) {\n              getFromArray(vertexNormals, quadIndices[k], normal);\n              normalAttr.set(vertexOffset + k, normal);\n            }\n\n            var idx = quadIndices[k];\n            uvArr[0] = idx % column / (column - 1);\n            uvArr[1] = Math.floor(idx / column) / (row - 1);\n            texcoordAttr.set(vertexOffset + k, uvArr);\n          }\n\n          dataIndex++;\n        }\n      }\n    } else {\n      var uvArr = [];\n\n      for (var i = 0; i < data.count(); i++) {\n        uvArr[0] = i % column / (column - 1);\n        uvArr[1] = Math.floor(i / column) / (row - 1);\n        var rgbaArr = graphicGL.parseColor(getItemVisualColor(data, i));\n        var opacity = getItemVisualOpacity(data, i);\n        opacity != null && (rgbaArr[3] *= opacity);\n\n        if (rgbaArr[3] < 0.99) {\n          isTransparent = true;\n        }\n\n        colorAttr.set(i, rgbaArr);\n        texcoordAttr.set(i, uvArr);\n      }\n\n      var quadIndices = []; // Triangles\n\n      var cursor = 0;\n\n      for (var i = 0; i < row - 1; i++) {\n        for (var j = 0; j < column - 1; j++) {\n          getQuadIndices(i, j, quadIndices);\n\n          for (var k = 0; k < 6; k++) {\n            indices[cursor++] = quadIndices[quadToTriangle[k]];\n          }\n        }\n      }\n\n      if (needsNormal) {\n        geometry.generateVertexNormals();\n      } else {\n        normalAttr.value = null;\n      }\n    }\n\n    if (surfaceMesh.material.get('normalMap')) {\n      geometry.generateTangents();\n    }\n\n    geometry.updateBoundingBox();\n    geometry.dirty();\n    surfaceMesh.material.transparent = isTransparent;\n    surfaceMesh.material.depthMask = !isTransparent;\n  },\n  _getDataShape: function (data, isParametric) {\n    var prevX = -Infinity;\n    var rowCount = 0;\n    var columnCount = 0;\n    var prevColumnCount = 0;\n    var mayInvalid = false;\n    var rowDim = isParametric ? 'u' : 'x';\n    var dataCount = data.count(); // Check data format\n\n    for (var i = 0; i < dataCount; i++) {\n      var x = data.get(rowDim, i);\n\n      if (x < prevX) {\n        if (prevColumnCount && prevColumnCount !== columnCount) {\n          if (process.env.NODE_ENV !== 'production') {\n            mayInvalid = true;\n          }\n        } // A new row.\n\n\n        prevColumnCount = columnCount;\n        columnCount = 0;\n        rowCount++;\n      }\n\n      prevX = x;\n      columnCount++;\n    }\n\n    if (!rowCount || columnCount === 1) {\n      mayInvalid = true;\n    }\n\n    if (!mayInvalid) {\n      return [rowCount + 1, columnCount];\n    }\n\n    var rows = Math.floor(Math.sqrt(dataCount));\n\n    while (rows > 0) {\n      if (Math.floor(dataCount / rows) === dataCount / rows) {\n        // Can be divided\n        return [rows, dataCount / rows];\n      }\n\n      rows--;\n    } // Bailout\n\n\n    rows = Math.floor(Math.sqrt(dataCount));\n    return [rows, rows];\n  },\n  dispose: function () {\n    this.groupGL.removeAll();\n  },\n  remove: function () {\n    this.groupGL.removeAll();\n  }\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}