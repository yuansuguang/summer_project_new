{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Base from './core/Base';\nimport Vector3 from './math/Vector3';\nimport Quaternion from './math/Quaternion';\nimport Matrix4 from './math/Matrix4';\nimport mat4 from './glmatrix/mat4';\nimport BoundingBox from './math/BoundingBox';\nvar nameId = 0;\n\n/**\n * @constructor clay.Node\n * @extends clay.core.Base\n */\nvar Node = Base.extend( /** @lends clay.Node# */{\n  /**\n   * Scene node name\n   * @type {string}\n   */\n  name: '',\n  /**\n   * Position relative to its parent node. aka translation.\n   * @type {clay.Vector3}\n   */\n  position: null,\n  /**\n   * Rotation relative to its parent node. Represented by a quaternion\n   * @type {clay.Quaternion}\n   */\n  rotation: null,\n  /**\n   * Scale relative to its parent node\n   * @type {clay.Vector3}\n   */\n  scale: null,\n  /**\n   * Affine transform matrix relative to its root scene.\n   * @type {clay.Matrix4}\n   */\n  worldTransform: null,\n  /**\n   * Affine transform matrix relative to its parent node.\n   * Composited with position, rotation and scale.\n   * @type {clay.Matrix4}\n   */\n  localTransform: null,\n  /**\n   * If the local transform is update from SRT(scale, rotation, translation, which is position here) each frame\n   * @type {boolean}\n   */\n  autoUpdateLocalTransform: true,\n  /**\n   * Parent of current scene node\n   * @type {?clay.Node}\n   * @private\n   */\n  _parent: null,\n  /**\n   * The root scene mounted. Null if it is a isolated node\n   * @type {?clay.Scene}\n   * @private\n   */\n  _scene: null,\n  /**\n   * @type {boolean}\n   * @private\n   */\n  _needsUpdateWorldTransform: true,\n  /**\n   * @type {boolean}\n   * @private\n   */\n  _inIterating: false,\n  // Depth for transparent list sorting\n  __depth: 0\n}, function () {\n  if (!this.name) {\n    this.name = (this.type || 'NODE') + '_' + nameId++;\n  }\n  if (!this.position) {\n    this.position = new Vector3();\n  }\n  if (!this.rotation) {\n    this.rotation = new Quaternion();\n  }\n  if (!this.scale) {\n    this.scale = new Vector3(1, 1, 1);\n  }\n  this.worldTransform = new Matrix4();\n  this.localTransform = new Matrix4();\n  this._children = [];\n}, /**@lends clay.Node.prototype. */\n{\n  /**\n   * @type {?clay.Vector3}\n   * @instance\n   */\n  target: null,\n  /**\n   * If node and its chilren invisible\n   * @type {boolean}\n   * @instance\n   */\n  invisible: false,\n  /**\n   * If Node is a skinned mesh\n   * @return {boolean}\n   */\n  isSkinnedMesh: function () {\n    return false;\n  },\n  /**\n   * Return true if it is a renderable scene node, like Mesh and ParticleSystem\n   * @return {boolean}\n   */\n  isRenderable: function () {\n    return false;\n  },\n  /**\n   * Set the name of the scene node\n   * @param {string} name\n   */\n  setName: function (name) {\n    var scene = this._scene;\n    if (scene) {\n      var nodeRepository = scene._nodeRepository;\n      delete nodeRepository[this.name];\n      nodeRepository[name] = this;\n    }\n    this.name = name;\n  },\n  /**\n   * Add a child node\n   * @param {clay.Node} node\n   */\n  add: function (node) {\n    var originalParent = node._parent;\n    if (originalParent === this) {\n      return;\n    }\n    if (originalParent) {\n      originalParent.remove(node);\n    }\n    node._parent = this;\n    this._children.push(node);\n    var scene = this._scene;\n    if (scene && scene !== node.scene) {\n      node.traverse(this._addSelfToScene, this);\n    }\n    // Mark children needs update transform\n    // In case child are remove and added again after parent moved\n    node._needsUpdateWorldTransform = true;\n  },\n  /**\n   * Remove the given child scene node\n   * @param {clay.Node} node\n   */\n  remove: function (node) {\n    var children = this._children;\n    var idx = children.indexOf(node);\n    if (idx < 0) {\n      return;\n    }\n    children.splice(idx, 1);\n    node._parent = null;\n    if (this._scene) {\n      node.traverse(this._removeSelfFromScene, this);\n    }\n  },\n  /**\n   * Remove all children\n   */\n  removeAll: function () {\n    var children = this._children;\n    for (var idx = 0; idx < children.length; idx++) {\n      children[idx]._parent = null;\n      if (this._scene) {\n        children[idx].traverse(this._removeSelfFromScene, this);\n      }\n    }\n    this._children = [];\n  },\n  /**\n   * Get the scene mounted\n   * @return {clay.Scene}\n   */\n  getScene: function () {\n    return this._scene;\n  },\n  /**\n   * Get parent node\n   * @return {clay.Scene}\n   */\n  getParent: function () {\n    return this._parent;\n  },\n  _removeSelfFromScene: function (descendant) {\n    descendant._scene.removeFromScene(descendant);\n    descendant._scene = null;\n  },\n  _addSelfToScene: function (descendant) {\n    this._scene.addToScene(descendant);\n    descendant._scene = this._scene;\n  },\n  /**\n   * Return true if it is ancestor of the given scene node\n   * @param {clay.Node} node\n   */\n  isAncestor: function (node) {\n    var parent = node._parent;\n    while (parent) {\n      if (parent === this) {\n        return true;\n      }\n      parent = parent._parent;\n    }\n    return false;\n  },\n  /**\n   * Get a new created array of all children nodes\n   * @return {clay.Node[]}\n   */\n  children: function () {\n    return this._children.slice();\n  },\n  /**\n   * Get child scene node at given index.\n   * @param {number} idx\n   * @return {clay.Node}\n   */\n  childAt: function (idx) {\n    return this._children[idx];\n  },\n  /**\n   * Get first child with the given name\n   * @param {string} name\n   * @return {clay.Node}\n   */\n  getChildByName: function (name) {\n    var children = this._children;\n    for (var i = 0; i < children.length; i++) {\n      if (children[i].name === name) {\n        return children[i];\n      }\n    }\n  },\n  /**\n   * Get first descendant have the given name\n   * @param {string} name\n   * @return {clay.Node}\n   */\n  getDescendantByName: function (name) {\n    var children = this._children;\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n      if (child.name === name) {\n        return child;\n      } else {\n        var res = child.getDescendantByName(name);\n        if (res) {\n          return res;\n        }\n      }\n    }\n  },\n  /**\n   * Query descendant node by path\n   * @param {string} path\n   * @return {clay.Node}\n   * @example\n   *  node.queryNode('root/parent/child');\n   */\n  queryNode: function (path) {\n    if (!path) {\n      return;\n    }\n    // TODO Name have slash ?\n    var pathArr = path.split('/');\n    var current = this;\n    for (var i = 0; i < pathArr.length; i++) {\n      var name = pathArr[i];\n      // Skip empty\n      if (!name) {\n        continue;\n      }\n      var found = false;\n      var children = current._children;\n      for (var j = 0; j < children.length; j++) {\n        var child = children[j];\n        if (child.name === name) {\n          current = child;\n          found = true;\n          break;\n        }\n      }\n      // Early return if not found\n      if (!found) {\n        return;\n      }\n    }\n    return current;\n  },\n  /**\n   * Get query path, relative to rootNode(default is scene)\n   * @param {clay.Node} [rootNode]\n   * @return {string}\n   */\n  getPath: function (rootNode) {\n    if (!this._parent) {\n      return '/';\n    }\n    var current = this._parent;\n    var path = this.name;\n    while (current._parent) {\n      path = current.name + '/' + path;\n      if (current._parent == rootNode) {\n        break;\n      }\n      current = current._parent;\n    }\n    if (!current._parent && rootNode) {\n      return null;\n    }\n    return path;\n  },\n  /**\n   * Depth first traverse all its descendant scene nodes.\n   *\n   * **WARN** Don't do `add`, `remove` operation in the callback during traverse.\n   * @param {Function} callback\n   * @param {Node} [context]\n   */\n  traverse: function (callback, context) {\n    callback.call(context, this);\n    var _children = this._children;\n    for (var i = 0, len = _children.length; i < len; i++) {\n      _children[i].traverse(callback, context);\n    }\n  },\n  /**\n   * Traverse all children nodes.\n   *\n   * **WARN** DON'T do `add`, `remove` operation in the callback during iteration.\n   *\n   * @param {Function} callback\n   * @param {Node} [context]\n   */\n  eachChild: function (callback, context) {\n    var _children = this._children;\n    for (var i = 0, len = _children.length; i < len; i++) {\n      var child = _children[i];\n      callback.call(context, child, i);\n    }\n  },\n  /**\n   * Set the local transform and decompose to SRT\n   * @param {clay.Matrix4} matrix\n   */\n  setLocalTransform: function (matrix) {\n    mat4.copy(this.localTransform.array, matrix.array);\n    this.decomposeLocalTransform();\n  },\n  /**\n   * Decompose the local transform to SRT\n   */\n  decomposeLocalTransform: function (keepScale) {\n    var scale = !keepScale ? this.scale : null;\n    this.localTransform.decomposeMatrix(scale, this.rotation, this.position);\n  },\n  /**\n   * Set the world transform and decompose to SRT\n   * @param {clay.Matrix4} matrix\n   */\n  setWorldTransform: function (matrix) {\n    mat4.copy(this.worldTransform.array, matrix.array);\n    this.decomposeWorldTransform();\n  },\n  /**\n   * Decompose the world transform to SRT\n   * @function\n   */\n  decomposeWorldTransform: function () {\n    var tmp = mat4.create();\n    return function (keepScale) {\n      var localTransform = this.localTransform;\n      var worldTransform = this.worldTransform;\n      // Assume world transform is updated\n      if (this._parent) {\n        mat4.invert(tmp, this._parent.worldTransform.array);\n        mat4.multiply(localTransform.array, tmp, worldTransform.array);\n      } else {\n        mat4.copy(localTransform.array, worldTransform.array);\n      }\n      var scale = !keepScale ? this.scale : null;\n      localTransform.decomposeMatrix(scale, this.rotation, this.position);\n    };\n  }(),\n  transformNeedsUpdate: function () {\n    return this.position._dirty || this.rotation._dirty || this.scale._dirty;\n  },\n  /**\n   * Update local transform from SRT\n   * Notice that local transform will not be updated if _dirty mark of position, rotation, scale is all false\n   */\n  updateLocalTransform: function () {\n    var position = this.position;\n    var rotation = this.rotation;\n    var scale = this.scale;\n    if (this.transformNeedsUpdate()) {\n      var m = this.localTransform.array;\n\n      // Transform order, scale->rotation->position\n      mat4.fromRotationTranslation(m, rotation.array, position.array);\n      mat4.scale(m, m, scale.array);\n      rotation._dirty = false;\n      scale._dirty = false;\n      position._dirty = false;\n      this._needsUpdateWorldTransform = true;\n    }\n  },\n  /**\n   * Update world transform, assume its parent world transform have been updated\n   * @private\n   */\n  _updateWorldTransformTopDown: function () {\n    var localTransform = this.localTransform.array;\n    var worldTransform = this.worldTransform.array;\n    if (this._parent) {\n      mat4.multiplyAffine(worldTransform, this._parent.worldTransform.array, localTransform);\n    } else {\n      mat4.copy(worldTransform, localTransform);\n    }\n  },\n  /**\n   * Update world transform before whole scene is updated.\n   */\n  updateWorldTransform: function () {\n    // Find the root node which transform needs update;\n    var rootNodeIsDirty = this;\n    while (rootNodeIsDirty && rootNodeIsDirty.getParent() && rootNodeIsDirty.getParent().transformNeedsUpdate()) {\n      rootNodeIsDirty = rootNodeIsDirty.getParent();\n    }\n    rootNodeIsDirty.update();\n  },\n  /**\n   * Update local transform and world transform recursively\n   * @param {boolean} forceUpdateWorld\n   */\n  update: function (forceUpdateWorld) {\n    if (this.autoUpdateLocalTransform) {\n      this.updateLocalTransform();\n    } else {\n      // Transform is manually setted\n      forceUpdateWorld = true;\n    }\n    if (forceUpdateWorld || this._needsUpdateWorldTransform) {\n      this._updateWorldTransformTopDown();\n      forceUpdateWorld = true;\n      this._needsUpdateWorldTransform = false;\n    }\n    var children = this._children;\n    for (var i = 0, len = children.length; i < len; i++) {\n      children[i].update(forceUpdateWorld);\n    }\n  },\n  /**\n   * Get bounding box of node\n   * @param  {Function} [filter]\n   * @param  {clay.BoundingBox} [out]\n   * @return {clay.BoundingBox}\n   */\n  // TODO Skinning\n  getBoundingBox: function () {\n    function defaultFilter(el) {\n      return !el.invisible && el.geometry;\n    }\n    var tmpBBox = new BoundingBox();\n    var tmpMat4 = new Matrix4();\n    var invWorldTransform = new Matrix4();\n    return function (filter, out) {\n      out = out || new BoundingBox();\n      filter = filter || defaultFilter;\n      if (this._parent) {\n        Matrix4.invert(invWorldTransform, this._parent.worldTransform);\n      } else {\n        Matrix4.identity(invWorldTransform);\n      }\n      this.traverse(function (mesh) {\n        if (mesh.geometry && mesh.geometry.boundingBox) {\n          tmpBBox.copy(mesh.geometry.boundingBox);\n          Matrix4.multiply(tmpMat4, invWorldTransform, mesh.worldTransform);\n          tmpBBox.applyTransform(tmpMat4);\n          out.union(tmpBBox);\n        }\n      }, this, defaultFilter);\n      return out;\n    };\n  }(),\n  /**\n   * Get world position, extracted from world transform\n   * @param  {clay.Vector3} [out]\n   * @return {clay.Vector3}\n   */\n  getWorldPosition: function (out) {\n    // PENDING\n    if (this.transformNeedsUpdate()) {\n      this.updateWorldTransform();\n    }\n    var m = this.worldTransform.array;\n    if (out) {\n      var arr = out.array;\n      arr[0] = m[12];\n      arr[1] = m[13];\n      arr[2] = m[14];\n      return out;\n    } else {\n      return new Vector3(m[12], m[13], m[14]);\n    }\n  },\n  /**\n   * Clone a new node\n   * @return {Node}\n   */\n  clone: function () {\n    var node = new this.constructor();\n    var children = this._children;\n    node.setName(this.name);\n    node.position.copy(this.position);\n    node.rotation.copy(this.rotation);\n    node.scale.copy(this.scale);\n    for (var i = 0; i < children.length; i++) {\n      node.add(children[i].clone());\n    }\n    return node;\n  },\n  /**\n   * Rotate the node around a axis by angle degrees, axis passes through point\n   * @param {clay.Vector3} point Center point\n   * @param {clay.Vector3} axis  Center axis\n   * @param {number}       angle Rotation angle\n   * @see http://docs.unity3d.com/Documentation/ScriptReference/Transform.RotateAround.html\n   * @function\n   */\n  rotateAround: function () {\n    var v = new Vector3();\n    var RTMatrix = new Matrix4();\n\n    // TODO improve performance\n    return function (point, axis, angle) {\n      v.copy(this.position).subtract(point);\n      var localTransform = this.localTransform;\n      localTransform.identity();\n      // parent node\n      localTransform.translate(point);\n      localTransform.rotate(angle, axis);\n      RTMatrix.fromRotationTranslation(this.rotation, v);\n      localTransform.multiply(RTMatrix);\n      localTransform.scale(this.scale);\n      this.decomposeLocalTransform();\n      this._needsUpdateWorldTransform = true;\n    };\n  }(),\n  /**\n   * @param {clay.Vector3} target\n   * @param {clay.Vector3} [up]\n   * @see http://www.opengl.org/sdk/docs/man2/xhtml/gluLookAt.xml\n   * @function\n   */\n  lookAt: function () {\n    var m = new Matrix4();\n    return function (target, up) {\n      m.lookAt(this.position, target, up || this.localTransform.y).invert();\n      this.setLocalTransform(m);\n      this.target = target;\n    };\n  }()\n});\nexport default Node;","map":{"version":3,"names":["Base","Vector3","Quaternion","Matrix4","mat4","BoundingBox","nameId","Node","extend","name","position","rotation","scale","worldTransform","localTransform","autoUpdateLocalTransform","_parent","_scene","_needsUpdateWorldTransform","_inIterating","__depth","type","_children","target","invisible","isSkinnedMesh","isRenderable","setName","scene","nodeRepository","_nodeRepository","add","node","originalParent","remove","push","traverse","_addSelfToScene","children","idx","indexOf","splice","_removeSelfFromScene","removeAll","length","getScene","getParent","descendant","removeFromScene","addToScene","isAncestor","parent","slice","childAt","getChildByName","i","getDescendantByName","child","res","queryNode","path","pathArr","split","current","found","j","getPath","rootNode","callback","context","call","len","eachChild","setLocalTransform","matrix","copy","array","decomposeLocalTransform","keepScale","decomposeMatrix","setWorldTransform","decomposeWorldTransform","tmp","create","invert","multiply","transformNeedsUpdate","_dirty","updateLocalTransform","m","fromRotationTranslation","_updateWorldTransformTopDown","multiplyAffine","updateWorldTransform","rootNodeIsDirty","update","forceUpdateWorld","getBoundingBox","defaultFilter","el","geometry","tmpBBox","tmpMat4","invWorldTransform","filter","out","identity","mesh","boundingBox","applyTransform","union","getWorldPosition","arr","clone","constructor","rotateAround","v","RTMatrix","point","axis","angle","subtract","translate","rotate","lookAt","up","y"],"sources":["E:/mytest/node_modules/claygl/src/Node.js"],"sourcesContent":["import Base from './core/Base';\nimport Vector3 from './math/Vector3';\nimport Quaternion from './math/Quaternion';\nimport Matrix4 from './math/Matrix4';\nimport mat4 from './glmatrix/mat4';\nimport BoundingBox from './math/BoundingBox';\n\nvar nameId = 0;\n\n/**\n * @constructor clay.Node\n * @extends clay.core.Base\n */\nvar Node = Base.extend(/** @lends clay.Node# */{\n    /**\n     * Scene node name\n     * @type {string}\n     */\n    name: '',\n\n    /**\n     * Position relative to its parent node. aka translation.\n     * @type {clay.Vector3}\n     */\n    position: null,\n\n    /**\n     * Rotation relative to its parent node. Represented by a quaternion\n     * @type {clay.Quaternion}\n     */\n    rotation: null,\n\n    /**\n     * Scale relative to its parent node\n     * @type {clay.Vector3}\n     */\n    scale: null,\n\n    /**\n     * Affine transform matrix relative to its root scene.\n     * @type {clay.Matrix4}\n     */\n    worldTransform: null,\n\n    /**\n     * Affine transform matrix relative to its parent node.\n     * Composited with position, rotation and scale.\n     * @type {clay.Matrix4}\n     */\n    localTransform: null,\n\n    /**\n     * If the local transform is update from SRT(scale, rotation, translation, which is position here) each frame\n     * @type {boolean}\n     */\n    autoUpdateLocalTransform: true,\n\n    /**\n     * Parent of current scene node\n     * @type {?clay.Node}\n     * @private\n     */\n    _parent: null,\n    /**\n     * The root scene mounted. Null if it is a isolated node\n     * @type {?clay.Scene}\n     * @private\n     */\n    _scene: null,\n    /**\n     * @type {boolean}\n     * @private\n     */\n    _needsUpdateWorldTransform: true,\n    /**\n     * @type {boolean}\n     * @private\n     */\n    _inIterating: false,\n\n    // Depth for transparent list sorting\n    __depth: 0\n\n}, function () {\n\n    if (!this.name) {\n        this.name = (this.type || 'NODE') + '_' + (nameId++);\n    }\n\n    if (!this.position) {\n        this.position = new Vector3();\n    }\n    if (!this.rotation) {\n        this.rotation = new Quaternion();\n    }\n    if (!this.scale) {\n        this.scale = new Vector3(1, 1, 1);\n    }\n\n    this.worldTransform = new Matrix4();\n    this.localTransform = new Matrix4();\n\n    this._children = [];\n\n},\n/**@lends clay.Node.prototype. */\n{\n\n    /**\n     * @type {?clay.Vector3}\n     * @instance\n     */\n    target: null,\n    /**\n     * If node and its chilren invisible\n     * @type {boolean}\n     * @instance\n     */\n    invisible: false,\n\n    /**\n     * If Node is a skinned mesh\n     * @return {boolean}\n     */\n    isSkinnedMesh: function () {\n        return false;\n    },\n    /**\n     * Return true if it is a renderable scene node, like Mesh and ParticleSystem\n     * @return {boolean}\n     */\n    isRenderable: function () {\n        return false;\n    },\n\n    /**\n     * Set the name of the scene node\n     * @param {string} name\n     */\n    setName: function (name) {\n        var scene = this._scene;\n        if (scene) {\n            var nodeRepository = scene._nodeRepository;\n            delete nodeRepository[this.name];\n            nodeRepository[name] = this;\n        }\n        this.name = name;\n    },\n\n    /**\n     * Add a child node\n     * @param {clay.Node} node\n     */\n    add: function (node) {\n        var originalParent = node._parent;\n        if (originalParent === this) {\n            return;\n        }\n        if (originalParent) {\n            originalParent.remove(node);\n        }\n        node._parent = this;\n        this._children.push(node);\n\n        var scene = this._scene;\n        if (scene && scene !== node.scene) {\n            node.traverse(this._addSelfToScene, this);\n        }\n        // Mark children needs update transform\n        // In case child are remove and added again after parent moved\n        node._needsUpdateWorldTransform = true;\n    },\n\n    /**\n     * Remove the given child scene node\n     * @param {clay.Node} node\n     */\n    remove: function (node) {\n        var children = this._children;\n        var idx = children.indexOf(node);\n        if (idx < 0) {\n            return;\n        }\n\n        children.splice(idx, 1);\n        node._parent = null;\n\n        if (this._scene) {\n            node.traverse(this._removeSelfFromScene, this);\n        }\n    },\n\n    /**\n     * Remove all children\n     */\n    removeAll: function () {\n        var children = this._children;\n\n        for (var idx = 0; idx < children.length; idx++) {\n            children[idx]._parent = null;\n\n            if (this._scene) {\n                children[idx].traverse(this._removeSelfFromScene, this);\n            }\n        }\n\n        this._children = [];\n    },\n\n    /**\n     * Get the scene mounted\n     * @return {clay.Scene}\n     */\n    getScene: function () {\n        return this._scene;\n    },\n\n    /**\n     * Get parent node\n     * @return {clay.Scene}\n     */\n    getParent: function () {\n        return this._parent;\n    },\n\n    _removeSelfFromScene: function (descendant) {\n        descendant._scene.removeFromScene(descendant);\n        descendant._scene = null;\n    },\n\n    _addSelfToScene: function (descendant) {\n        this._scene.addToScene(descendant);\n        descendant._scene = this._scene;\n    },\n\n    /**\n     * Return true if it is ancestor of the given scene node\n     * @param {clay.Node} node\n     */\n    isAncestor: function (node) {\n        var parent = node._parent;\n        while(parent) {\n            if (parent === this) {\n                return true;\n            }\n            parent = parent._parent;\n        }\n        return false;\n    },\n\n    /**\n     * Get a new created array of all children nodes\n     * @return {clay.Node[]}\n     */\n    children: function () {\n        return this._children.slice();\n    },\n\n    /**\n     * Get child scene node at given index.\n     * @param {number} idx\n     * @return {clay.Node}\n     */\n    childAt: function (idx) {\n        return this._children[idx];\n    },\n\n    /**\n     * Get first child with the given name\n     * @param {string} name\n     * @return {clay.Node}\n     */\n    getChildByName: function (name) {\n        var children = this._children;\n        for (var i = 0; i < children.length; i++) {\n            if (children[i].name === name) {\n                return children[i];\n            }\n        }\n    },\n\n    /**\n     * Get first descendant have the given name\n     * @param {string} name\n     * @return {clay.Node}\n     */\n    getDescendantByName: function (name) {\n        var children = this._children;\n        for (var i = 0; i < children.length; i++) {\n            var child = children[i];\n            if (child.name === name) {\n                return child;\n            } else {\n                var res = child.getDescendantByName(name);\n                if (res) {\n                    return res;\n                }\n            }\n        }\n    },\n\n    /**\n     * Query descendant node by path\n     * @param {string} path\n     * @return {clay.Node}\n     * @example\n     *  node.queryNode('root/parent/child');\n     */\n    queryNode: function (path) {\n        if (!path) {\n            return;\n        }\n        // TODO Name have slash ?\n        var pathArr = path.split('/');\n        var current = this;\n        for (var i = 0; i < pathArr.length; i++) {\n            var name = pathArr[i];\n            // Skip empty\n            if (!name) {\n                continue;\n            }\n            var found = false;\n            var children = current._children;\n            for (var j = 0; j < children.length; j++) {\n                var child = children[j];\n                if (child.name === name) {\n                    current = child;\n                    found = true;\n                    break;\n                }\n            }\n            // Early return if not found\n            if (!found) {\n                return;\n            }\n        }\n\n        return current;\n    },\n\n    /**\n     * Get query path, relative to rootNode(default is scene)\n     * @param {clay.Node} [rootNode]\n     * @return {string}\n     */\n    getPath: function (rootNode) {\n        if (!this._parent) {\n            return '/';\n        }\n\n        var current = this._parent;\n        var path = this.name;\n        while (current._parent) {\n            path = current.name + '/' + path;\n            if (current._parent == rootNode) {\n                break;\n            }\n            current = current._parent;\n        }\n        if (!current._parent && rootNode) {\n            return null;\n        }\n        return path;\n    },\n\n    /**\n     * Depth first traverse all its descendant scene nodes.\n     *\n     * **WARN** Don't do `add`, `remove` operation in the callback during traverse.\n     * @param {Function} callback\n     * @param {Node} [context]\n     */\n    traverse: function (callback, context) {\n        callback.call(context, this);\n        var _children = this._children;\n        for(var i = 0, len = _children.length; i < len; i++) {\n            _children[i].traverse(callback, context);\n        }\n    },\n\n    /**\n     * Traverse all children nodes.\n     *\n     * **WARN** DON'T do `add`, `remove` operation in the callback during iteration.\n     *\n     * @param {Function} callback\n     * @param {Node} [context]\n     */\n    eachChild: function (callback, context) {\n        var _children = this._children;\n        for(var i = 0, len = _children.length; i < len; i++) {\n            var child = _children[i];\n            callback.call(context, child, i);\n        }\n    },\n\n    /**\n     * Set the local transform and decompose to SRT\n     * @param {clay.Matrix4} matrix\n     */\n    setLocalTransform: function (matrix) {\n        mat4.copy(this.localTransform.array, matrix.array);\n        this.decomposeLocalTransform();\n    },\n\n    /**\n     * Decompose the local transform to SRT\n     */\n    decomposeLocalTransform: function (keepScale) {\n        var scale = !keepScale ? this.scale: null;\n        this.localTransform.decomposeMatrix(scale, this.rotation, this.position);\n    },\n\n    /**\n     * Set the world transform and decompose to SRT\n     * @param {clay.Matrix4} matrix\n     */\n    setWorldTransform: function (matrix) {\n        mat4.copy(this.worldTransform.array, matrix.array);\n        this.decomposeWorldTransform();\n    },\n\n    /**\n     * Decompose the world transform to SRT\n     * @function\n     */\n    decomposeWorldTransform: (function () {\n\n        var tmp = mat4.create();\n\n        return function (keepScale) {\n            var localTransform = this.localTransform;\n            var worldTransform = this.worldTransform;\n            // Assume world transform is updated\n            if (this._parent) {\n                mat4.invert(tmp, this._parent.worldTransform.array);\n                mat4.multiply(localTransform.array, tmp, worldTransform.array);\n            } else {\n                mat4.copy(localTransform.array, worldTransform.array);\n            }\n            var scale = !keepScale ? this.scale: null;\n            localTransform.decomposeMatrix(scale, this.rotation, this.position);\n        };\n    })(),\n\n    transformNeedsUpdate: function () {\n        return this.position._dirty\n            || this.rotation._dirty\n            || this.scale._dirty;\n    },\n\n    /**\n     * Update local transform from SRT\n     * Notice that local transform will not be updated if _dirty mark of position, rotation, scale is all false\n     */\n    updateLocalTransform: function () {\n        var position = this.position;\n        var rotation = this.rotation;\n        var scale = this.scale;\n\n        if (this.transformNeedsUpdate()) {\n            var m = this.localTransform.array;\n\n            // Transform order, scale->rotation->position\n            mat4.fromRotationTranslation(m, rotation.array, position.array);\n\n            mat4.scale(m, m, scale.array);\n\n            rotation._dirty = false;\n            scale._dirty = false;\n            position._dirty = false;\n\n            this._needsUpdateWorldTransform = true;\n        }\n    },\n\n    /**\n     * Update world transform, assume its parent world transform have been updated\n     * @private\n     */\n    _updateWorldTransformTopDown: function () {\n        var localTransform = this.localTransform.array;\n        var worldTransform = this.worldTransform.array;\n        if (this._parent) {\n            mat4.multiplyAffine(\n                worldTransform,\n                this._parent.worldTransform.array,\n                localTransform\n            );\n        }\n        else {\n            mat4.copy(worldTransform, localTransform);\n        }\n    },\n\n    /**\n     * Update world transform before whole scene is updated.\n     */\n    updateWorldTransform: function () {\n        // Find the root node which transform needs update;\n        var rootNodeIsDirty = this;\n        while (rootNodeIsDirty && rootNodeIsDirty.getParent()\n            && rootNodeIsDirty.getParent().transformNeedsUpdate()\n        ) {\n            rootNodeIsDirty = rootNodeIsDirty.getParent();\n        }\n        rootNodeIsDirty.update();\n    },\n\n    /**\n     * Update local transform and world transform recursively\n     * @param {boolean} forceUpdateWorld\n     */\n    update: function (forceUpdateWorld) {\n        if (this.autoUpdateLocalTransform) {\n            this.updateLocalTransform();\n        }\n        else {\n            // Transform is manually setted\n            forceUpdateWorld = true;\n        }\n\n        if (forceUpdateWorld || this._needsUpdateWorldTransform) {\n            this._updateWorldTransformTopDown();\n            forceUpdateWorld = true;\n            this._needsUpdateWorldTransform = false;\n        }\n\n        var children = this._children;\n        for(var i = 0, len = children.length; i < len; i++) {\n            children[i].update(forceUpdateWorld);\n        }\n    },\n\n    /**\n     * Get bounding box of node\n     * @param  {Function} [filter]\n     * @param  {clay.BoundingBox} [out]\n     * @return {clay.BoundingBox}\n     */\n    // TODO Skinning\n    getBoundingBox: (function () {\n        function defaultFilter (el) {\n            return !el.invisible && el.geometry;\n        }\n        var tmpBBox = new BoundingBox();\n        var tmpMat4 = new Matrix4();\n        var invWorldTransform = new Matrix4();\n        return function (filter, out) {\n            out = out || new BoundingBox();\n            filter = filter || defaultFilter;\n\n            if (this._parent) {\n                Matrix4.invert(invWorldTransform, this._parent.worldTransform);\n            }\n            else {\n                Matrix4.identity(invWorldTransform);\n            }\n\n            this.traverse(function (mesh) {\n                if (mesh.geometry && mesh.geometry.boundingBox) {\n                    tmpBBox.copy(mesh.geometry.boundingBox);\n                    Matrix4.multiply(tmpMat4, invWorldTransform, mesh.worldTransform);\n                    tmpBBox.applyTransform(tmpMat4);\n                    out.union(tmpBBox);\n                }\n            }, this, defaultFilter);\n\n            return out;\n        };\n    })(),\n\n    /**\n     * Get world position, extracted from world transform\n     * @param  {clay.Vector3} [out]\n     * @return {clay.Vector3}\n     */\n    getWorldPosition: function (out) {\n        // PENDING\n        if (this.transformNeedsUpdate()) {\n            this.updateWorldTransform();\n        }\n        var m = this.worldTransform.array;\n        if (out) {\n            var arr = out.array;\n            arr[0] = m[12];\n            arr[1] = m[13];\n            arr[2] = m[14];\n            return out;\n        }\n        else {\n            return new Vector3(m[12], m[13], m[14]);\n        }\n    },\n\n    /**\n     * Clone a new node\n     * @return {Node}\n     */\n    clone: function () {\n        var node = new this.constructor();\n\n        var children = this._children;\n\n        node.setName(this.name);\n        node.position.copy(this.position);\n        node.rotation.copy(this.rotation);\n        node.scale.copy(this.scale);\n\n        for (var i = 0; i < children.length; i++) {\n            node.add(children[i].clone());\n        }\n\n        return node;\n    },\n\n    /**\n     * Rotate the node around a axis by angle degrees, axis passes through point\n     * @param {clay.Vector3} point Center point\n     * @param {clay.Vector3} axis  Center axis\n     * @param {number}       angle Rotation angle\n     * @see http://docs.unity3d.com/Documentation/ScriptReference/Transform.RotateAround.html\n     * @function\n     */\n    rotateAround: (function () {\n        var v = new Vector3();\n        var RTMatrix = new Matrix4();\n\n        // TODO improve performance\n        return function (point, axis, angle) {\n\n            v.copy(this.position).subtract(point);\n\n            var localTransform = this.localTransform;\n            localTransform.identity();\n            // parent node\n            localTransform.translate(point);\n            localTransform.rotate(angle, axis);\n\n            RTMatrix.fromRotationTranslation(this.rotation, v);\n            localTransform.multiply(RTMatrix);\n            localTransform.scale(this.scale);\n\n            this.decomposeLocalTransform();\n            this._needsUpdateWorldTransform = true;\n        };\n    })(),\n\n    /**\n     * @param {clay.Vector3} target\n     * @param {clay.Vector3} [up]\n     * @see http://www.opengl.org/sdk/docs/man2/xhtml/gluLookAt.xml\n     * @function\n     */\n    lookAt: (function () {\n        var m = new Matrix4();\n        return function (target, up) {\n            m.lookAt(this.position, target, up || this.localTransform.y).invert();\n            this.setLocalTransform(m);\n\n            this.target = target;\n        };\n    })()\n});\n\nexport default Node;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}