{"ast":null,"code":"import ShaderBase, { VANTA } from './_shaderBase.js';\nconst win = typeof window == 'object';\nlet THREE = win && window.THREE;\nclass Halo extends ShaderBase {\n  constructor(userOptions) {\n    THREE = userOptions.THREE || THREE;\n    super(userOptions);\n  }\n  getDefaultOptions() {\n    return {\n      baseColor: 0x001a59,\n      color2: 0xf2e735,\n      backgroundColor: 0x131a43,\n      amplitudeFactor: 1.0,\n      ringFactor: 1.0,\n      rotationFactor: 1.0,\n      xOffset: 0,\n      yOffset: 0,\n      size: 1.0,\n      speed: 1.0,\n      mouseEase: true,\n      // scaleMobile: window.devicePixelRatio,\n      // scale: window.devicePixelRatio,\n      scaleMobile: 1,\n      scale: 1\n    };\n  }\n  onInit() {\n    const pars = {\n      minFilter: THREE.LinearFilter,\n      magFilter: THREE.LinearFilter,\n      format: THREE.RGBFormat\n    };\n    const ww = this.width * window.devicePixelRatio / this.scale;\n    const hh = this.height * window.devicePixelRatio / this.scale;\n    this.bufferTarget = new THREE.WebGLRenderTarget(ww, hh, pars);\n    this.bufferFeedback = new THREE.WebGLRenderTarget(ww, hh, pars);\n  }\n  initBasicShader(fragmentShader, vertexShader) {\n    super.initBasicShader(fragmentShader, vertexShader);\n    this.uniforms.iBuffer = {\n      type: 't',\n      value: this.bufferTarget.texture\n    };\n  }\n  onUpdate() {\n    this.uniforms.iBuffer.value = this.bufferFeedback.texture;\n    const renderer = this.renderer;\n    renderer.setRenderTarget(this.bufferTarget);\n    // renderer.clear()\n    renderer.render(this.scene, this.camera);\n    renderer.setRenderTarget(null);\n    renderer.clear();\n\n    // Swap, to prevent shader using the same input as output\n    let temp = this.bufferTarget;\n    this.bufferTarget = this.bufferFeedback;\n    this.bufferFeedback = temp;\n  }\n  onResize() {\n    if (this.bufferTarget) {\n      const ww = this.width * window.devicePixelRatio / this.scale;\n      const hh = this.height * window.devicePixelRatio / this.scale;\n      this.bufferTarget.setSize(ww, hh);\n      this.bufferFeedback.setSize(ww, hh);\n    }\n  }\n  onDestroy() {\n    this.bufferTarget = null;\n    this.bufferFeedback = null;\n  }\n}\nexport default VANTA.register('HALO', Halo);\nHalo.prototype.fragmentShader = `\\\nuniform vec2 iResolution;\nuniform float iDpr;\nuniform vec2 iMouse;\nuniform float iTime;\n\nuniform float xOffset;\nuniform float yOffset;\nuniform vec3 baseColor;\nuniform vec3 color2;\nuniform vec3 backgroundColor;\nuniform float size;\nuniform float shape;\nuniform float ringFactor;\nuniform float rotationFactor;\nuniform float amplitudeFactor;\n\nuniform sampler2D iBuffer;\nuniform sampler2D iTex;\nconst float PI = 3.14159265359;\n\n// float length2(vec2 p) { return dot(p, p); }\n\n// float noise(vec2 p){\n//   return fract(sin(fract(sin(p.x) * (43.13311)) + p.y) * 31.0011);\n// }\n\n// float worley(vec2 p) {\n//     float d = 1e30;\n//     for (int xo = -1; xo <= 1; ++xo) {\n//         for (int yo = -1; yo <= 1; ++yo) {\n//             vec2 tp = floor(p) + vec2(xo, yo);\n//             d = min(d, length2(p - tp - vec2(noise(tp))));\n//         }\n//     }\n//     vec2 uv = gl_FragCoord.xy / iResolution.xy;\n//     float timeOffset =  0.15 * sin(iTime * 2.0 + 10.0*(uv.x - uv.y));\n//     return 3.0*exp(-4.0*abs(2.0*d - 1.0 + timeOffset));\n// }\n\n// float fworley(vec2 p) {\n//     return sqrt(\n//     1.1 * // light\n//     worley(p*10. + .3 + iTime*.0525) *\n//     sqrt(worley(p * 50. / size + 0.1 + iTime * -0.75)) *\n//     4.1 *\n//     sqrt(sqrt(worley(p * -1. + 9.3))));\n// }\n\nvec4 j2hue(float c) {\n  return .5+.5*cos(6.28*c+vec4(0,-2.1,2.1,0));\n}\n\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nvec2 sincos( float x ){return vec2(sin(x), cos(x));}\nvec2 rotate2d(vec2 uv, float phi){vec2 t = sincos(phi); return vec2(uv.x*t.y-uv.y*t.x, uv.x*t.x+uv.y*t.y);}\nvec3 rotate3d(vec3 p, vec3 v, float phi){ v = normalize(v); vec2 t = sincos(-phi); float s = t.x, c = t.y, x =-v.x, y =-v.y, z =-v.z; mat4 M = mat4(x*x*(1.-c)+c,x*y*(1.-c)-z*s,x*z*(1.-c)+y*s,0.,y*x*(1.-c)+z*s,y*y*(1.-c)+c,y*z*(1.-c)-x*s,0.,z*x*(1.-c)-y*s,z*y*(1.-c)+x*s,z*z*(1.-c)+c,0.,0.,0.,0.,1.);return (vec4(p,1.)*M).xyz;}\n\n// Classic Perlin 3D Noise\n// by Stefan Gustavson\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nfloat p3d(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n\nvoid main() {\n  vec2 res2 = iResolution.xy * iDpr;\n  vec2 pixel = vec2(gl_FragCoord.xy - 0.5 * res2) / res2.y; // center-origin pixel coord\n  pixel.x -= xOffset * res2.x / res2.y;\n  pixel.y -= yOffset;\n\n  vec2 uv = gl_FragCoord.xy / res2; // 0 to 1\n\n  // float nn1 = snoise(uv * 0.25 + iTime * 0.005 + mixedColor.b * 0.01) * 0.1;\n  // float nn2 = snoise(uv * 0.25 + iTime * 0.005 + mixedColor.b * 0.01 + 1000.) * 0.1;\n  // uv += vec2(nn1, nn2);\n\n  // PERLIN DISTORTION\n  // float noiseScale = 10.;\n  // float timeScale = 0.5;\n  // uv += vec2( p3d(vec3(uv * noiseScale, iTime * timeScale)), p3d(vec3(1000. + uv * noiseScale , iTime * timeScale)) ) * 0.001;\n\n  // uv = rotate2d(uv, 0.001);\n  // pixel = rotate2d(pixel, 0.001);\n\n  vec2 mouse2 = (iMouse * iDpr / res2 - 0.5) * vec2(1.,-1.);\n  vec2 uvBig = (uv - 0.5) * 0.996 + 0.5;\n\n  vec4 oldImage = texture2D(iBuffer, uv);\n  vec3 mixedColor = oldImage.rgb - backgroundColor;\n\n  // float spinDist = 0.002 + 0.002 * sin(iTime * 0.4);\n  float cropDist = 0.01;\n  float cropXOffset = 0.2;\n  float cropYOffset = 0.2;\n  // float cropXOffset = 0.4 + 0.1 * sin(iTime * 0.4);\n  // float cropYOffset = 0.4 + 0.1 * cos(iTime * 0.6);\n\n  vec2 offset = uv + vec2((mixedColor.g - cropXOffset) * cropDist, (mixedColor.r - cropYOffset) * cropDist);\n\n  // float nn = snoise(uv * 10.) * 0.001;\n  // offset += nn;\n\n  float spinDist = 0.001;\n  float spinSpeed = 0.2 + 0.15 * cos(iTime * 0.5);\n  float timeFrac = mod(iTime, 6.5);\n  vec2 offset2 = uvBig + vec2(cos(timeFrac * spinSpeed) * spinDist, sin(timeFrac * spinSpeed) * spinDist);\n\n  mixedColor = texture2D(iBuffer, offset).rgb * 0.4\n    + texture2D(iBuffer, offset2).rgb * 0.6\n    - backgroundColor;\n\n\n  // mixedColor *= .875;\n  float fadeAmt = 0.0015; // fade this amount each frame // 0.002\n  mixedColor = (mixedColor - fadeAmt) * .995;\n\n  // float nn = snoise(uvBig * 10.) * 20.;\n  // mixedColor *= clamp(nn, 0.98, 1.0);\n\n  vec4 spectrum = abs( abs( .95*atan(uv.x, uv.y) -vec4(0,2,4,0) ) -3. )-1.;\n  float angle = atan(pixel.x, pixel.y);\n  float dist = length(pixel - mouse2*0.15) * 8. + sin(iTime) * .01;\n\n  // mixedColor *= pow(1.-dist*0.002, 2.);\n\n\n  // Flowery shapes\n  // float edge = abs(dist * 0.5);\n  float flowerPeaks = .05 * amplitudeFactor * size;\n  float flowerPetals = 7.;\n  float edge = abs((dist + sin(angle * flowerPetals + iTime * 0.5) * sin(iTime * 1.5) * flowerPeaks) * 0.65 / size);\n  // float edge = abs((dist + sin(angle * 4. + iTime * 2.) * sin(iTime * 3.) * 0.75) * 1.);\n\n  // vec4 rainbow = abs( abs( .95*mod(iTime * 1., 2. * PI) - vec4(0,2,4,0) ) -3. )-1.;\n  // vec4 rainbow = vec4(0,2,4,0);\n\n  float colorChangeSpeed = 0.75 + 0.05 * sin(iTime) * 1.5;\n  float rainbowInput = timeFrac * colorChangeSpeed;\n  // NOISE!\n  // float nn = snoise(uv * 0.25 + iTime * 0.005 + mixedColor.b * 0.01) * 20.;\n  // rainbowInput += nn;\n\n  float brightness = 0.7;\n  vec4 rainbow = sqrt(j2hue(cos(rainbowInput))) + vec4(baseColor,0) - 1.0 + brightness;\n  float factor = smoothstep(1., .9, edge) * pow(edge, 2.);\n  vec3 color = rainbow.rgb * smoothstep(1., .9, edge) * pow(edge, 20.);\n  vec4 ring = vec4(\n    backgroundColor + clamp( mixedColor + color, 0., 1.)\n    , 1.0);\n\n  // float t = fworley(uv * u_resolution.xy / 1500.0);\n  // t *= exp(-length2(abs(0.7*uv - 1.0)));\n  // float tExp = pow(t, 2. - t);\n  // vec3 c1 = color1 * (1.0 - t);\n  // vec3 c2 = color2 * tExp;\n  // vec4 cells = vec4(mixedColor * 0.25, 1.) + vec4(pow(t, 1.0 - t) * (c1 + c2), 1.0);\n  // gl_FragColor = clamp(ring + cells * 0.5, 0.0, 1.0);\n\n  // float nn = snoise(uv * 10.) * 0.01; // creepy!\n  gl_FragColor = ring;\n}\n`;","map":{"version":3,"names":["ShaderBase","VANTA","win","window","THREE","Halo","constructor","userOptions","getDefaultOptions","baseColor","color2","backgroundColor","amplitudeFactor","ringFactor","rotationFactor","xOffset","yOffset","size","speed","mouseEase","scaleMobile","scale","onInit","pars","minFilter","LinearFilter","magFilter","format","RGBFormat","ww","width","devicePixelRatio","hh","height","bufferTarget","WebGLRenderTarget","bufferFeedback","initBasicShader","fragmentShader","vertexShader","uniforms","iBuffer","type","value","texture","onUpdate","renderer","setRenderTarget","render","scene","camera","clear","temp","onResize","setSize","onDestroy","register","prototype"],"sources":["E:/mytest/node_modules/vanta/src/vanta.halo.js"],"sourcesContent":["import ShaderBase, {VANTA} from './_shaderBase.js'\r\n\r\nconst win = typeof window == 'object'\r\nlet THREE = win && window.THREE\r\n\r\nclass Halo extends ShaderBase {\r\n\r\n  constructor(userOptions) {\r\n    THREE = userOptions.THREE || THREE\r\n    super(userOptions)\r\n  }\r\n\r\n  getDefaultOptions() {\r\n    return {\r\n      baseColor: 0x001a59,\r\n      color2: 0xf2e735,\r\n      backgroundColor: 0x131a43,\r\n      amplitudeFactor: 1.0,\r\n      ringFactor: 1.0,\r\n      rotationFactor: 1.0,\r\n      xOffset: 0,\r\n      yOffset: 0,\r\n      size: 1.0,\r\n      speed: 1.0,\r\n      mouseEase: true,\r\n      // scaleMobile: window.devicePixelRatio,\r\n      // scale: window.devicePixelRatio,\r\n      scaleMobile: 1,\r\n      scale: 1,\r\n    }\r\n  }\r\n\r\n  onInit() {\r\n    const pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat }\r\n    const ww = this.width * window.devicePixelRatio / this.scale\r\n    const hh = this.height * window.devicePixelRatio / this.scale\r\n    this.bufferTarget = new THREE.WebGLRenderTarget( ww, hh, pars )\r\n    this.bufferFeedback = new THREE.WebGLRenderTarget( ww, hh, pars )\r\n  }\r\n  initBasicShader(fragmentShader, vertexShader) {\r\n    super.initBasicShader(fragmentShader, vertexShader)\r\n    this.uniforms.iBuffer = {\r\n      type: 't',\r\n      value: this.bufferTarget.texture,\r\n    }\r\n  }\r\n  onUpdate() {\r\n    this.uniforms.iBuffer.value = this.bufferFeedback.texture\r\n\r\n    const renderer = this.renderer\r\n    renderer.setRenderTarget( this.bufferTarget )\r\n    // renderer.clear()\r\n    renderer.render( this.scene, this.camera )\r\n    renderer.setRenderTarget( null )\r\n    renderer.clear()\r\n\r\n    // Swap, to prevent shader using the same input as output\r\n    let temp = this.bufferTarget\r\n    this.bufferTarget = this.bufferFeedback\r\n    this.bufferFeedback = temp\r\n  }\r\n  onResize() {\r\n    if (this.bufferTarget) {\r\n      const ww = this.width * window.devicePixelRatio / this.scale\r\n      const hh = this.height * window.devicePixelRatio / this.scale\r\n      this.bufferTarget.setSize( ww, hh )\r\n      this.bufferFeedback.setSize( ww, hh )\r\n    }\r\n  }\r\n  onDestroy() {\r\n    this.bufferTarget = null\r\n    this.bufferFeedback = null\r\n  }\r\n}\r\nexport default VANTA.register('HALO', Halo)\r\n\r\nHalo.prototype.fragmentShader = `\\\r\nuniform vec2 iResolution;\r\nuniform float iDpr;\r\nuniform vec2 iMouse;\r\nuniform float iTime;\r\n\r\nuniform float xOffset;\r\nuniform float yOffset;\r\nuniform vec3 baseColor;\r\nuniform vec3 color2;\r\nuniform vec3 backgroundColor;\r\nuniform float size;\r\nuniform float shape;\r\nuniform float ringFactor;\r\nuniform float rotationFactor;\r\nuniform float amplitudeFactor;\r\n\r\nuniform sampler2D iBuffer;\r\nuniform sampler2D iTex;\r\nconst float PI = 3.14159265359;\r\n\r\n// float length2(vec2 p) { return dot(p, p); }\r\n\r\n// float noise(vec2 p){\r\n//   return fract(sin(fract(sin(p.x) * (43.13311)) + p.y) * 31.0011);\r\n// }\r\n\r\n// float worley(vec2 p) {\r\n//     float d = 1e30;\r\n//     for (int xo = -1; xo <= 1; ++xo) {\r\n//         for (int yo = -1; yo <= 1; ++yo) {\r\n//             vec2 tp = floor(p) + vec2(xo, yo);\r\n//             d = min(d, length2(p - tp - vec2(noise(tp))));\r\n//         }\r\n//     }\r\n//     vec2 uv = gl_FragCoord.xy / iResolution.xy;\r\n//     float timeOffset =  0.15 * sin(iTime * 2.0 + 10.0*(uv.x - uv.y));\r\n//     return 3.0*exp(-4.0*abs(2.0*d - 1.0 + timeOffset));\r\n// }\r\n\r\n// float fworley(vec2 p) {\r\n//     return sqrt(\r\n//     1.1 * // light\r\n//     worley(p*10. + .3 + iTime*.0525) *\r\n//     sqrt(worley(p * 50. / size + 0.1 + iTime * -0.75)) *\r\n//     4.1 *\r\n//     sqrt(sqrt(worley(p * -1. + 9.3))));\r\n// }\r\n\r\nvec4 j2hue(float c) {\r\n  return .5+.5*cos(6.28*c+vec4(0,-2.1,2.1,0));\r\n}\r\n\r\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\r\n\r\nfloat snoise(vec2 v){\r\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\r\n           -0.577350269189626, 0.024390243902439);\r\n  vec2 i  = floor(v + dot(v, C.yy) );\r\n  vec2 x0 = v -   i + dot(i, C.xx);\r\n  vec2 i1;\r\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\r\n  vec4 x12 = x0.xyxy + C.xxzz;\r\n  x12.xy -= i1;\r\n  i = mod(i, 289.0);\r\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\r\n  + i.x + vec3(0.0, i1.x, 1.0 ));\r\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\r\n    dot(x12.zw,x12.zw)), 0.0);\r\n  m = m*m ;\r\n  m = m*m ;\r\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\r\n  vec3 h = abs(x) - 0.5;\r\n  vec3 ox = floor(x + 0.5);\r\n  vec3 a0 = x - ox;\r\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\r\n  vec3 g;\r\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\r\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\r\n  return 130.0 * dot(m, g);\r\n}\r\n\r\nvec2 sincos( float x ){return vec2(sin(x), cos(x));}\r\nvec2 rotate2d(vec2 uv, float phi){vec2 t = sincos(phi); return vec2(uv.x*t.y-uv.y*t.x, uv.x*t.x+uv.y*t.y);}\r\nvec3 rotate3d(vec3 p, vec3 v, float phi){ v = normalize(v); vec2 t = sincos(-phi); float s = t.x, c = t.y, x =-v.x, y =-v.y, z =-v.z; mat4 M = mat4(x*x*(1.-c)+c,x*y*(1.-c)-z*s,x*z*(1.-c)+y*s,0.,y*x*(1.-c)+z*s,y*y*(1.-c)+c,y*z*(1.-c)-x*s,0.,z*x*(1.-c)-y*s,z*y*(1.-c)+x*s,z*z*(1.-c)+c,0.,0.,0.,0.,1.);return (vec4(p,1.)*M).xyz;}\r\n\r\n// Classic Perlin 3D Noise\r\n// by Stefan Gustavson\r\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\r\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\r\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\r\nfloat p3d(vec3 P){\r\n  vec3 Pi0 = floor(P); // Integer part for indexing\r\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\r\n  Pi0 = mod(Pi0, 289.0);\r\n  Pi1 = mod(Pi1, 289.0);\r\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\r\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\r\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\r\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\r\n  vec4 iz0 = Pi0.zzzz;\r\n  vec4 iz1 = Pi1.zzzz;\r\n\r\n  vec4 ixy = permute(permute(ix) + iy);\r\n  vec4 ixy0 = permute(ixy + iz0);\r\n  vec4 ixy1 = permute(ixy + iz1);\r\n\r\n  vec4 gx0 = ixy0 / 7.0;\r\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\r\n  gx0 = fract(gx0);\r\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\r\n  vec4 sz0 = step(gz0, vec4(0.0));\r\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\r\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\r\n\r\n  vec4 gx1 = ixy1 / 7.0;\r\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\r\n  gx1 = fract(gx1);\r\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\r\n  vec4 sz1 = step(gz1, vec4(0.0));\r\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\r\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\r\n\r\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\r\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\r\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\r\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\r\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\r\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\r\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\r\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\r\n\r\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\r\n  g000 *= norm0.x;\r\n  g010 *= norm0.y;\r\n  g100 *= norm0.z;\r\n  g110 *= norm0.w;\r\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\r\n  g001 *= norm1.x;\r\n  g011 *= norm1.y;\r\n  g101 *= norm1.z;\r\n  g111 *= norm1.w;\r\n\r\n  float n000 = dot(g000, Pf0);\r\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\r\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\r\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\r\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\r\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\r\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\r\n  float n111 = dot(g111, Pf1);\r\n\r\n  vec3 fade_xyz = fade(Pf0);\r\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\r\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\r\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\r\n  return 2.2 * n_xyz;\r\n}\r\n\r\n\r\nvoid main() {\r\n  vec2 res2 = iResolution.xy * iDpr;\r\n  vec2 pixel = vec2(gl_FragCoord.xy - 0.5 * res2) / res2.y; // center-origin pixel coord\r\n  pixel.x -= xOffset * res2.x / res2.y;\r\n  pixel.y -= yOffset;\r\n\r\n  vec2 uv = gl_FragCoord.xy / res2; // 0 to 1\r\n\r\n  // float nn1 = snoise(uv * 0.25 + iTime * 0.005 + mixedColor.b * 0.01) * 0.1;\r\n  // float nn2 = snoise(uv * 0.25 + iTime * 0.005 + mixedColor.b * 0.01 + 1000.) * 0.1;\r\n  // uv += vec2(nn1, nn2);\r\n\r\n  // PERLIN DISTORTION\r\n  // float noiseScale = 10.;\r\n  // float timeScale = 0.5;\r\n  // uv += vec2( p3d(vec3(uv * noiseScale, iTime * timeScale)), p3d(vec3(1000. + uv * noiseScale , iTime * timeScale)) ) * 0.001;\r\n\r\n  // uv = rotate2d(uv, 0.001);\r\n  // pixel = rotate2d(pixel, 0.001);\r\n\r\n  vec2 mouse2 = (iMouse * iDpr / res2 - 0.5) * vec2(1.,-1.);\r\n  vec2 uvBig = (uv - 0.5) * 0.996 + 0.5;\r\n\r\n  vec4 oldImage = texture2D(iBuffer, uv);\r\n  vec3 mixedColor = oldImage.rgb - backgroundColor;\r\n\r\n  // float spinDist = 0.002 + 0.002 * sin(iTime * 0.4);\r\n  float cropDist = 0.01;\r\n  float cropXOffset = 0.2;\r\n  float cropYOffset = 0.2;\r\n  // float cropXOffset = 0.4 + 0.1 * sin(iTime * 0.4);\r\n  // float cropYOffset = 0.4 + 0.1 * cos(iTime * 0.6);\r\n\r\n  vec2 offset = uv + vec2((mixedColor.g - cropXOffset) * cropDist, (mixedColor.r - cropYOffset) * cropDist);\r\n\r\n  // float nn = snoise(uv * 10.) * 0.001;\r\n  // offset += nn;\r\n\r\n  float spinDist = 0.001;\r\n  float spinSpeed = 0.2 + 0.15 * cos(iTime * 0.5);\r\n  float timeFrac = mod(iTime, 6.5);\r\n  vec2 offset2 = uvBig + vec2(cos(timeFrac * spinSpeed) * spinDist, sin(timeFrac * spinSpeed) * spinDist);\r\n\r\n  mixedColor = texture2D(iBuffer, offset).rgb * 0.4\r\n    + texture2D(iBuffer, offset2).rgb * 0.6\r\n    - backgroundColor;\r\n\r\n\r\n  // mixedColor *= .875;\r\n  float fadeAmt = 0.0015; // fade this amount each frame // 0.002\r\n  mixedColor = (mixedColor - fadeAmt) * .995;\r\n\r\n  // float nn = snoise(uvBig * 10.) * 20.;\r\n  // mixedColor *= clamp(nn, 0.98, 1.0);\r\n\r\n  vec4 spectrum = abs( abs( .95*atan(uv.x, uv.y) -vec4(0,2,4,0) ) -3. )-1.;\r\n  float angle = atan(pixel.x, pixel.y);\r\n  float dist = length(pixel - mouse2*0.15) * 8. + sin(iTime) * .01;\r\n\r\n  // mixedColor *= pow(1.-dist*0.002, 2.);\r\n\r\n\r\n  // Flowery shapes\r\n  // float edge = abs(dist * 0.5);\r\n  float flowerPeaks = .05 * amplitudeFactor * size;\r\n  float flowerPetals = 7.;\r\n  float edge = abs((dist + sin(angle * flowerPetals + iTime * 0.5) * sin(iTime * 1.5) * flowerPeaks) * 0.65 / size);\r\n  // float edge = abs((dist + sin(angle * 4. + iTime * 2.) * sin(iTime * 3.) * 0.75) * 1.);\r\n\r\n  // vec4 rainbow = abs( abs( .95*mod(iTime * 1., 2. * PI) - vec4(0,2,4,0) ) -3. )-1.;\r\n  // vec4 rainbow = vec4(0,2,4,0);\r\n\r\n  float colorChangeSpeed = 0.75 + 0.05 * sin(iTime) * 1.5;\r\n  float rainbowInput = timeFrac * colorChangeSpeed;\r\n  // NOISE!\r\n  // float nn = snoise(uv * 0.25 + iTime * 0.005 + mixedColor.b * 0.01) * 20.;\r\n  // rainbowInput += nn;\r\n\r\n  float brightness = 0.7;\r\n  vec4 rainbow = sqrt(j2hue(cos(rainbowInput))) + vec4(baseColor,0) - 1.0 + brightness;\r\n  float factor = smoothstep(1., .9, edge) * pow(edge, 2.);\r\n  vec3 color = rainbow.rgb * smoothstep(1., .9, edge) * pow(edge, 20.);\r\n  vec4 ring = vec4(\r\n    backgroundColor + clamp( mixedColor + color, 0., 1.)\r\n    , 1.0);\r\n\r\n  // float t = fworley(uv * u_resolution.xy / 1500.0);\r\n  // t *= exp(-length2(abs(0.7*uv - 1.0)));\r\n  // float tExp = pow(t, 2. - t);\r\n  // vec3 c1 = color1 * (1.0 - t);\r\n  // vec3 c2 = color2 * tExp;\r\n  // vec4 cells = vec4(mixedColor * 0.25, 1.) + vec4(pow(t, 1.0 - t) * (c1 + c2), 1.0);\r\n  // gl_FragColor = clamp(ring + cells * 0.5, 0.0, 1.0);\r\n\r\n  // float nn = snoise(uv * 10.) * 0.01; // creepy!\r\n  gl_FragColor = ring;\r\n}\r\n`\r\n"],"mappings":"AAAA,OAAOA,UAAU,IAAGC,KAAK,QAAO,kBAAkB;AAElD,MAAMC,GAAG,GAAG,OAAOC,MAAM,IAAI,QAAQ;AACrC,IAAIC,KAAK,GAAGF,GAAG,IAAIC,MAAM,CAACC,KAAK;AAE/B,MAAMC,IAAI,SAASL,UAAU,CAAC;EAE5BM,WAAWA,CAACC,WAAW,EAAE;IACvBH,KAAK,GAAGG,WAAW,CAACH,KAAK,IAAIA,KAAK;IAClC,KAAK,CAACG,WAAW,CAAC;EACpB;EAEAC,iBAAiBA,CAAA,EAAG;IAClB,OAAO;MACLC,SAAS,EAAE,QAAQ;MACnBC,MAAM,EAAE,QAAQ;MAChBC,eAAe,EAAE,QAAQ;MACzBC,eAAe,EAAE,GAAG;MACpBC,UAAU,EAAE,GAAG;MACfC,cAAc,EAAE,GAAG;MACnBC,OAAO,EAAE,CAAC;MACVC,OAAO,EAAE,CAAC;MACVC,IAAI,EAAE,GAAG;MACTC,KAAK,EAAE,GAAG;MACVC,SAAS,EAAE,IAAI;MACf;MACA;MACAC,WAAW,EAAE,CAAC;MACdC,KAAK,EAAE;IACT,CAAC;EACH;EAEAC,MAAMA,CAAA,EAAG;IACP,MAAMC,IAAI,GAAG;MAAEC,SAAS,EAAEpB,KAAK,CAACqB,YAAY;MAAEC,SAAS,EAAEtB,KAAK,CAACqB,YAAY;MAAEE,MAAM,EAAEvB,KAAK,CAACwB;IAAU,CAAC;IACtG,MAAMC,EAAE,GAAG,IAAI,CAACC,KAAK,GAAG3B,MAAM,CAAC4B,gBAAgB,GAAG,IAAI,CAACV,KAAK;IAC5D,MAAMW,EAAE,GAAG,IAAI,CAACC,MAAM,GAAG9B,MAAM,CAAC4B,gBAAgB,GAAG,IAAI,CAACV,KAAK;IAC7D,IAAI,CAACa,YAAY,GAAG,IAAI9B,KAAK,CAAC+B,iBAAiB,CAAEN,EAAE,EAAEG,EAAE,EAAET,IAAK,CAAC;IAC/D,IAAI,CAACa,cAAc,GAAG,IAAIhC,KAAK,CAAC+B,iBAAiB,CAAEN,EAAE,EAAEG,EAAE,EAAET,IAAK,CAAC;EACnE;EACAc,eAAeA,CAACC,cAAc,EAAEC,YAAY,EAAE;IAC5C,KAAK,CAACF,eAAe,CAACC,cAAc,EAAEC,YAAY,CAAC;IACnD,IAAI,CAACC,QAAQ,CAACC,OAAO,GAAG;MACtBC,IAAI,EAAE,GAAG;MACTC,KAAK,EAAE,IAAI,CAACT,YAAY,CAACU;IAC3B,CAAC;EACH;EACAC,QAAQA,CAAA,EAAG;IACT,IAAI,CAACL,QAAQ,CAACC,OAAO,CAACE,KAAK,GAAG,IAAI,CAACP,cAAc,CAACQ,OAAO;IAEzD,MAAME,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC9BA,QAAQ,CAACC,eAAe,CAAE,IAAI,CAACb,YAAa,CAAC;IAC7C;IACAY,QAAQ,CAACE,MAAM,CAAE,IAAI,CAACC,KAAK,EAAE,IAAI,CAACC,MAAO,CAAC;IAC1CJ,QAAQ,CAACC,eAAe,CAAE,IAAK,CAAC;IAChCD,QAAQ,CAACK,KAAK,CAAC,CAAC;;IAEhB;IACA,IAAIC,IAAI,GAAG,IAAI,CAAClB,YAAY;IAC5B,IAAI,CAACA,YAAY,GAAG,IAAI,CAACE,cAAc;IACvC,IAAI,CAACA,cAAc,GAAGgB,IAAI;EAC5B;EACAC,QAAQA,CAAA,EAAG;IACT,IAAI,IAAI,CAACnB,YAAY,EAAE;MACrB,MAAML,EAAE,GAAG,IAAI,CAACC,KAAK,GAAG3B,MAAM,CAAC4B,gBAAgB,GAAG,IAAI,CAACV,KAAK;MAC5D,MAAMW,EAAE,GAAG,IAAI,CAACC,MAAM,GAAG9B,MAAM,CAAC4B,gBAAgB,GAAG,IAAI,CAACV,KAAK;MAC7D,IAAI,CAACa,YAAY,CAACoB,OAAO,CAAEzB,EAAE,EAAEG,EAAG,CAAC;MACnC,IAAI,CAACI,cAAc,CAACkB,OAAO,CAAEzB,EAAE,EAAEG,EAAG,CAAC;IACvC;EACF;EACAuB,SAASA,CAAA,EAAG;IACV,IAAI,CAACrB,YAAY,GAAG,IAAI;IACxB,IAAI,CAACE,cAAc,GAAG,IAAI;EAC5B;AACF;AACA,eAAenC,KAAK,CAACuD,QAAQ,CAAC,MAAM,EAAEnD,IAAI,CAAC;AAE3CA,IAAI,CAACoD,SAAS,CAACnB,cAAc,GAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}