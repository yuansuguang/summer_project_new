{"ast":null,"code":"import Light from '../Light';\nimport Vector3 from '../math/Vector3';\n\n/**\n * @constructor clay.light.Directional\n * @extends clay.Light\n *\n * @example\n *     var light = new clay.light.Directional({\n *         intensity: 0.5,\n *         color: [1.0, 0.0, 0.0]\n *     });\n *     light.position.set(10, 10, 10);\n *     light.lookAt(clay.Vector3.ZERO);\n *     scene.add(light);\n */\nvar DirectionalLight = Light.extend( /** @lends clay.light.Directional# */{\n  /**\n   * @type {number}\n   */\n  shadowBias: 0.001,\n  /**\n   * @type {number}\n   */\n  shadowSlopeScale: 2.0,\n  /**\n   * Shadow cascade.\n   * Use PSSM technique when it is larger than 1 and have a unique directional light in scene.\n   * @type {number}\n   */\n  shadowCascade: 1,\n  /**\n   * Available when shadowCascade is larger than 1 and have a unique directional light in scene.\n   * @type {number}\n   */\n  cascadeSplitLogFactor: 0.2\n}, {\n  type: 'DIRECTIONAL_LIGHT',\n  uniformTemplates: {\n    directionalLightDirection: {\n      type: '3f',\n      value: function (instance) {\n        instance.__dir = instance.__dir || new Vector3();\n        // Direction is target to eye\n        return instance.__dir.copy(instance.worldTransform.z).normalize().negate().array;\n      }\n    },\n    directionalLightColor: {\n      type: '3f',\n      value: function (instance) {\n        var color = instance.color;\n        var intensity = instance.intensity;\n        return [color[0] * intensity, color[1] * intensity, color[2] * intensity];\n      }\n    }\n  },\n  /**\n   * @return {clay.light.Directional}\n   * @memberOf clay.light.Directional.prototype\n   */\n  clone: function () {\n    var light = Light.prototype.clone.call(this);\n    light.shadowBias = this.shadowBias;\n    light.shadowSlopeScale = this.shadowSlopeScale;\n    return light;\n  }\n});\nexport default DirectionalLight;","map":{"version":3,"names":["Light","Vector3","DirectionalLight","extend","shadowBias","shadowSlopeScale","shadowCascade","cascadeSplitLogFactor","type","uniformTemplates","directionalLightDirection","value","instance","__dir","copy","worldTransform","z","normalize","negate","array","directionalLightColor","color","intensity","clone","light","prototype","call"],"sources":["E:/QuestionairePlanet_Fronted/mytest/node_modules/claygl/src/light/Directional.js"],"sourcesContent":["import Light from '../Light';\nimport Vector3 from '../math/Vector3';\n\n/**\n * @constructor clay.light.Directional\n * @extends clay.Light\n *\n * @example\n *     var light = new clay.light.Directional({\n *         intensity: 0.5,\n *         color: [1.0, 0.0, 0.0]\n *     });\n *     light.position.set(10, 10, 10);\n *     light.lookAt(clay.Vector3.ZERO);\n *     scene.add(light);\n */\nvar DirectionalLight = Light.extend(/** @lends clay.light.Directional# */ {\n    /**\n     * @type {number}\n     */\n    shadowBias: 0.001,\n    /**\n     * @type {number}\n     */\n    shadowSlopeScale: 2.0,\n    /**\n     * Shadow cascade.\n     * Use PSSM technique when it is larger than 1 and have a unique directional light in scene.\n     * @type {number}\n     */\n    shadowCascade: 1,\n\n    /**\n     * Available when shadowCascade is larger than 1 and have a unique directional light in scene.\n     * @type {number}\n     */\n    cascadeSplitLogFactor: 0.2\n}, {\n\n    type: 'DIRECTIONAL_LIGHT',\n\n    uniformTemplates: {\n        directionalLightDirection: {\n            type: '3f',\n            value: function (instance) {\n                instance.__dir = instance.__dir || new Vector3();\n                // Direction is target to eye\n                return instance.__dir.copy(instance.worldTransform.z).normalize().negate().array;\n            }\n        },\n        directionalLightColor: {\n            type: '3f',\n            value: function (instance) {\n                var color = instance.color;\n                var intensity = instance.intensity;\n                return [color[0] * intensity, color[1] * intensity, color[2] * intensity];\n            }\n        }\n    },\n    /**\n     * @return {clay.light.Directional}\n     * @memberOf clay.light.Directional.prototype\n     */\n    clone: function () {\n        var light = Light.prototype.clone.call(this);\n        light.shadowBias = this.shadowBias;\n        light.shadowSlopeScale = this.shadowSlopeScale;\n        return light;\n    }\n});\n\nexport default DirectionalLight;\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,UAAU;AAC5B,OAAOC,OAAO,MAAM,iBAAiB;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,gBAAgB,GAAGF,KAAK,CAACG,MAAM,EAAC,qCAAsC;EACtE;AACJ;AACA;EACIC,UAAU,EAAE,KAAK;EACjB;AACJ;AACA;EACIC,gBAAgB,EAAE,GAAG;EACrB;AACJ;AACA;AACA;AACA;EACIC,aAAa,EAAE,CAAC;EAEhB;AACJ;AACA;AACA;EACIC,qBAAqB,EAAE;AAC3B,CAAC,EAAE;EAECC,IAAI,EAAE,mBAAmB;EAEzBC,gBAAgB,EAAE;IACdC,yBAAyB,EAAE;MACvBF,IAAI,EAAE,IAAI;MACVG,KAAK,EAAE,SAAAA,CAAUC,QAAQ,EAAE;QACvBA,QAAQ,CAACC,KAAK,GAAGD,QAAQ,CAACC,KAAK,IAAI,IAAIZ,OAAO,CAAC,CAAC;QAChD;QACA,OAAOW,QAAQ,CAACC,KAAK,CAACC,IAAI,CAACF,QAAQ,CAACG,cAAc,CAACC,CAAC,CAAC,CAACC,SAAS,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC,CAACC,KAAK;MACpF;IACJ,CAAC;IACDC,qBAAqB,EAAE;MACnBZ,IAAI,EAAE,IAAI;MACVG,KAAK,EAAE,SAAAA,CAAUC,QAAQ,EAAE;QACvB,IAAIS,KAAK,GAAGT,QAAQ,CAACS,KAAK;QAC1B,IAAIC,SAAS,GAAGV,QAAQ,CAACU,SAAS;QAClC,OAAO,CAACD,KAAK,CAAC,CAAC,CAAC,GAAGC,SAAS,EAAED,KAAK,CAAC,CAAC,CAAC,GAAGC,SAAS,EAAED,KAAK,CAAC,CAAC,CAAC,GAAGC,SAAS,CAAC;MAC7E;IACJ;EACJ,CAAC;EACD;AACJ;AACA;AACA;EACIC,KAAK,EAAE,SAAAA,CAAA,EAAY;IACf,IAAIC,KAAK,GAAGxB,KAAK,CAACyB,SAAS,CAACF,KAAK,CAACG,IAAI,CAAC,IAAI,CAAC;IAC5CF,KAAK,CAACpB,UAAU,GAAG,IAAI,CAACA,UAAU;IAClCoB,KAAK,CAACnB,gBAAgB,GAAG,IAAI,CAACA,gBAAgB;IAC9C,OAAOmB,KAAK;EAChB;AACJ,CAAC,CAAC;AAEF,eAAetB,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}